**********************************************************************
*
* TSTXHEXI: Tests ASSIST XHEXI instruction
*
* All tests should succeed.
*
* Default output only shows number of passed tests and number of
* failed tests. Use PARM(v) to also show the tests (v means verbose).
*
* --------------------------------------------------------------------
*
* Return codes: Value  Meaning
*               -----  -------------------------
*                 0    All tests were successful
*                 8    At least one test failed
*
* --------------------------------------------------------------------
*
* Information from the ASSIST User's Manual for "XHEXI REG,ADDRESS"
*
* 1. Beginning at the location ADDRESS, memory is scanned until the
*    the first non-blank character is found.
* 2. If the first character found is anything but a legal hexadecimal
*    character (0-9, A-F), the condition code is set to 3 (overflow)
*    and this address is placed in register 1. If REG is anything
*    but 1, its contents remain unchanged.
* 3. From one to eight hexadecimal characters are scanned, the number
*    converted to hexadecimal, and the result is placed in REG. The
*    value placed in REG is internal hexadecimal with leading zeros
*    included and the number is right justified.
* 4. Register 1 is set to the address of the first non-hexadecimal
*    character. With this in mind, the user should not code register
*    1 as REG. This allows you to scan across the card for any
*    number of character strings. The strings should be separated
*    by blanks. The end of the string could be flagged with any
*    non-hexadecimal character and a test could be made after a
*    Branch Overflow.
* 5. If more than eight hexadecimal characters are found, register 1
*    is set to the address of the ninth. This allows the user to
*    scan across long strings of numbers.
*
* NB: The ASSIST XHEXI code has some non-intuitive behavior that
*     could be considered to be bugs. The z390 implementation
*     maintains the behavior.
*
*     1. The condition code is only set in step 2. Otherwise, the
*        condition code is unchanged. If the condition code is 3
*        before XHEXI is executed, then it will still be 3 after
*        it is executed, even if step 3 completes successfully.
*        Tests 1-4 illustrate this behavior.
*     2. Read the comments for steps 4 and 5 carefully.
*     3. The existing ASSIST assembler source was examined to verify
*        that the ASSIST code does behave as described here.
*
* --------------------------------------------------------------------
*
* 2021-10-29 TSTXHEXI.MLC as part of issue 305 fix.
*
**********************************************************************
*
TSTXHEXI CSECT
         STM   14,12,12(13)    Save caller's registers
         LR    12,15           R12 = base register
         USING TSTXHEXI,12     Establish addressability
         LA    14,SA           R14 --> usable save area
         ST    14,8(,13)       Set caller's forward chain
         ST    13,4(,14)       Set current back chain
         LR    13,14           R13 = current save area
*
         MVI   PrtFlag,PFNo    Default is to not print each test
         L     2,0(,1)         R2 --> PARM value
         LH    3,0(,2)         R3 = length of value
         CHI   3,1             Must be exactly 1 byte
         BNE   ParmDone        Not 1; done with PARM
         CLI   2(2),C'v'       Only value is C'v' (verbose)
         BNE   ParmDone        Not lowercase v; done with PARM
         MVI   PrtFlag,PFYes   Set to print each test
ParmDone DS    0H
*
         SR    0,0             Initialize
         ST    0,#Pass         ... number of passed tests
         ST    0,#Fail         ... number of failed tests
*
         LM    3,5,TESTS       R3 --> 1st, R4 = len 1, R5 --> last
LOOP     DS    0H
         BAS   14,CHKXHEXI     Perform one test
         BXLE  3,4,LOOP        Perform all tests
*
         L     0,#Pass         Number of tests that passed
         CVD   0,DW            Convert # passes to decimal
         MVC   TL#Pass,Patt1   Copy edit pattern
         ED    TL#Pass,DW+6    Put # passes in print line
         L     0,#Fail         Number of tests that failed
         CVD   0,DW            Convert # fails to decimal
         MVC   TL#Fail,Patt1   Copy edit pattern
         ED    TL#Fail,DW+6    Put # passes in print line
         XPRNT TotLine,TLLen   Print totals
*
         LT    15,#Fail        Number of tests that failed
         BZ    RetCdSet        None; return code is zero
         LA    15,8            At least 1; return code is eight
RetCdSet DS    0H
         L     13,4(,13)       Caller's save area
         L     14,12(,13)      Restore caller's registers
         LM    0,12,20(13)     ... except R15
         BR    14              Return to caller
*
**********************************************************************
*
* CHKXHEXI: Perform one test
*
* Input: R3 --> test case; DSECT TESTDATA
*        R7  =  count successful tests
*        R8  =  count failed tests
*        R14 =  return address
*
**********************************************************************
*
CHKXHEXI DS    0H
         STM   14,12,12(13)        Save caller's registers
*
*        WARNING: no save area
*
         USING TESTDATA,3          Overlay test data
*
         MVI   ErrFlag,X'00'       No error yet
*
         MVC   Desc,TESTDESC       Copy test description to message
         LA    0,INPUTVAL          Address of XHEXI input
         ST    0,FW                Convert
         UNPK  DW(9),FW(5)         ... to printable hex
         TR    DW,H2P              Finish conversion
         MVC   Addr,DW+4           Copy low 4 digits of address
         MVC   Input,INPUTVAL      Copy input for XHEXI
         CLI   PrtFlag,PFYes       Print the test?
         BNE   PrtDone             No
         XPRNT InfoLine,ILLen      Show information for test
PrtDone  DS    0H
*
         SR    1,1                 Clear R1
         SR    5,5                 Clear R5; XHEXI output
*
         MVC   INPUTWK,INPUTVAL    Ensure sentinel value follows input
*
*        Preset CC
*
         LH    0,INITCC            Get initial condition code
         CHI   0,3                 CC 3?
         BE    SETCC3              Yes; preset CC 3
         CHI   0,0                 CC 0?
         BE    SETCC0              Yes; preset CC 0
         CHI   0,1                 CC 1?
         BE    SETCC1              Yes; preset CC 1
         LTR   0,0                 Otherwise CC 2; preset CC 2
         B     SETCCEND            Continue
SETCC3   DS    0H
         TM    *,X'91'             Set CC 3
         B     SETCCEND            Continue
SETCC1   DS    0H
         LHI   0,-1                Get negative value
         LTR   0,0                 Set CC 1
         B     SETCCEND            Continue
SETCC0   DS    0H
         SR    0,0                 Set CC 0
*NSI     B     SETCCEND            Continue
SETCCEND DS    0H
*
         XHEXI 5,INPUTWK           Perform XHEXI instruction
*
         IPM   0                   Get CC, pgm mask
         SRL   0,28                Isolate CC
*
         LA    15,INPUTVAL         Relocate
         LA    14,INPUTWK          ... R1
         SR    15,14               ... from INPUTWK
         AR    1,15                ... back to INPUTVAL
*
*        Check CC
*
         CH    0,EXPCC             Is CC the expected CC?
         BE    CCCKEND             Yes; next check
*
*        Unexpected CC value
*
         STC   0,CCACT             Put CC in message
         OI    CCACT,X'F0'         Make it printable
         MVC   CCEXP,EXPCC+3
         OI    CCEXP,X'F0'         Make it printable
         XPRNT PCCERR,PCCERRL      Print error message
         OI    ErrFlag,EFCC        CC error
*NSI     B     CCCKEND             Continue checks
CCCKEND  DS    0H
*
*        Check output
*
         C     5,EXPOUT        Compare output to expected
         BE    OUTCKEND        Equal; next check
*
*        Wrong output
*
         ST    5,FW            Convert actual value
         UNPK  DW(9),FW(5)     ... to printable hex
         TR    DW,H2P          Finish conversion
         MVC   VALACT,DW       Copy to print line
         UNPK  DW(9),EXPOUT(5) Convert expected value to prt hex
         TR    DW,H2P          Finish conversion
         MVC   VALEXP,DW       Copy to print line
         XPRNT PVALERR,PVALERRL    Print error message
         OI    ErrFlag,EFOut   Output error
*NSI     B     OUTCKEND        Continue checks
OUTCKEND DS    0H
*
*        Check R1 value
*
CHKR1    DS    0H
         C     1,EXPR1         Compare R1 to expected R1
         BE    R1CKEND         Equal; next check
*
*        Wrong R1 value
*
         ST    1,FW            Convert actual value
         UNPK  DW(9),FW(5)     ... to printable hex
         TR    DW,H2P          Finish conversion
         MVC   R1ACT,DW        Copy to print line
         UNPK  DW(9),EXPR1(5)  Convert expected value to prt hex
         TR    DW,H2P          Finish conversion
         MVC   R1EXP,DW        Copy to print line
         XPRNT PR1ERR,PR1ERRL  Print error message
         OI    ErrFlag,EFR1    R1 error
*NSI     B     R1CKEND         Continue checks
R1CKEND  DS    0H
*
*        Done with checks
*
CHKDone  DS    0H
         CLI   ErrFlag,X'00'   Any errors?
         BE    CHKPass         No; test was successful
         L     0,#Fail         Yes; count
         AHI   0,1             ... failed
         ST    0,#Fail         ... test
         B     CHKExit         Done
CHKPass  DS    0H
         L     0,#Pass         Count
         AHI   0,1             ... passed
         ST    0,#Pass         ... test
*NSI     B     CHKExit         Done
CHKExit  DS    0H
         LM    14,12,12(13)    Restore caller's registers
         BR    14              Return to caller
*
         LTORG ,
*
SA       DC    18F'-1'         Current save area
*
**********************************************************************
*        Print Flag
**********************************************************************
PrtFlag  DS    CL1             Print flag
PFNo     EQU   C'N'            Do not print
PFYes    EQU   C'Y'            Print
*
**********************************************************************
*        Error flag
**********************************************************************
ErrFlag  DS    XL1             Error flag
EFCC     EQU   X'80'           CC error
EFOut    EQU   X'40'           Output error
EFR1     EQU   X'20'           R1 error
*
**********************************************************************
*        Counts and edit pattern
**********************************************************************
*
#Pass    DS    F               Number of tests that passed
#Fail    DS    F               Number of tests that failed
*
Patt1    DC    X'40202120'     Edit pattern for 3-digit number
*
**********************************************************************
*        Messages
**********************************************************************
InfoLine DS    0C
         DC    C' '
         DC    C'***'
         DC    C' '
Desc     DS    CL(L'TESTDESC)  Test description
         DC    CL4' '
         DC    C'InAddr '
Addr     DS    CL4             Last four bytes of A(INPUTVAL)
         DC    C'  InData '
         DC    C'C'''
Input    DS    CL(L'INPUTVAL)  Input data
         DC    C''',C''$'''    Added sentinel byte
ILLen    EQU   *-InfoLine
*
TotLine  DS    0C
         DC    C' '
         DC    C'Number of passed tests ='
TL#Pass  DS    CL(L'Patt1)                     Num tests that passed
         DC    C'   Number of failed tests ='
TL#Fail  DS    CL(L'Patt1)                     Num tests that failed
TLLen    EQU   *-TotLine
*
**********************************************************************
*        Error messages
**********************************************************************
PCCERR   DS    0C
         DC    C' '
         DC    C'ERROR: CC = '
CCACT    DS    CL1           Actual CC
         DC    C'  Expected CC = '
CCEXP    DS    CL1           Expected CC
PCCERRL  EQU   *-PCCERR      Length of line
*
PVALERR  DS    0C
         DC    C' '
         DC    C'ERROR: Value = '
VALACT   DS    CL8           Actual value
         DC    C'  Expected value = '
VALEXP   DS    CL8           Excected value
PVALERRL EQU   *-PVALERR     Length of line
*
PR1ERR   DS    0C
         DC    C' '
         DC    C'ERROR: R1 = '
R1ACT    DS    CL8           Actual R1
         DC    C'  Expected R1 = '
R1EXP    DS    CL8           Excected R1
PR1ERRL  EQU   *-PR1ERR      Length of line
*
**********************************************************************
*        Input work area; sentinel byte at end
**********************************************************************
INPUTWK  DS    CL(L'INPUTVAL)
         DC    C'$'          Sentinel byte
*
**********************************************************************
*        Storage used to convert to printable hexadecimal
**********************************************************************
DW       DS    D,XL1         Doubleword work and pad
FW       DS    F,XL1         Fullword work and pad
H2P      EQU   *-240         Convert to printable hex
         DC    C'0123456789ABCDEF'
*
**********************************************************************
*        Test conditions table - specify input and expected output
**********************************************************************
*
         PRINT DATA
TESTS    DC    A(TEST1,TDATALEN,TESTN,0)   A(1st,len 1, last,0)
*
TEST1    DS    0D
*        Test 1
         DC    XL4'00'                             Exp output
         DC    H'0'                                Exp CC
         DC    H'0'                                Init CC
         DC    A(*+4+1)                            Exp R1
         DC    CL(L'INPUTVAL)'0 '                  Input
         DC    CL(L'TESTDESC)'Check "0" CC 0'
*
*        Test 2
         DC    XL4'00'                             Exp output
         DC    H'1'                                Exp CC
         DC    H'1'                                Init CC
         DC    A(*+4+1)                            Exp R1
         DC    CL(L'INPUTVAL)'0 '                  Input
         DC    CL(L'TESTDESC)'Check "0" CC 1'
*
*        Test 3
         DC    XL4'00'                             Exp output
         DC    H'2'                                Exp CC
         DC    H'2'                                Init CC
         DC    A(*+4+1)                            Exp R1
         DC    CL(L'INPUTVAL)'0 '                  Input
         DC    CL(L'TESTDESC)'Check "0" CC 2'
*
*        Test 4
         DC    XL4'00'                             Exp output
         DC    H'3'                                Exp CC
         DC    H'3'                                Init CC
         DC    A(*+4+1)                            Exp R1
         DC    CL(L'INPUTVAL)'0 '                  Input
         DC    CL(L'TESTDESC)'Check "0" CC 3'
*
*        Test 5
         DC    XL4'0123ABCD'                       Exp output
         DC    H'2'                                Exp CC
         DC    H'2'                                Init CC
         DC    A(*+4+11)                           Exp R1
         DC    CL(L'INPUTVAL)'   0123ABCD '        Input
         DC    CL(L'TESTDESC)'Check "   0123ABCD"'
*
*        Test 6
         DC    XL4'1A2B'                           Exp output
         DC    H'2'                                Exp CC
         DC    H'2'                                Init CC
         DC    A(*+4+6)                            Exp R1
         DC    CL(L'INPUTVAL)'  1A2B '             Input
         DC    CL(L'TESTDESC)'Check "  1A2B"'
*
*        Test 7
         DC    XL4'1F9'                            Exp output
         DC    H'2'                                Exp CC
         DC    H'2'                                Init CC
         DC    A(*+4+5)                            Exp R1
         DC    CL(L'INPUTVAL)'  1F9 '              Input
         DC    CL(L'TESTDESC)'Check "  1F9"'
*
*        Test 8
         DC    XL4'1F9'                            Exp output
         DC    H'2'                                Exp CC
         DC    H'2'                                Init CC
         DC    A(*+4+5)                            Exp R1
         DC    CL(L'INPUTVAL)'  1F9Z '             Input
         DC    CL(L'TESTDESC)'Check "  1F9Z"'
*
*        Test 9
         DC    XL4'00'                             Exp output
         DC    H'3'                                Exp CC
         DC    H'0'                                Init CC
         DC    A(*+4+1)                            Exp R1
         DC    CL(L'INPUTVAL)' X1A'                Input
         DC    CL(L'TESTDESC)'Check bad 1st char'
*
*        Test 10
         DC    XL4'1A2B3C4D'                       Exp output
         DC    H'2'                                Exp CC
         DC    H'2'                                Init CC
         DC    A(*+4+10)                           Exp R1
         DC    CL(L'INPUTVAL)'  1A2B3C4D '         Input
         DC    CL(L'TESTDESC)'Check max digits (8)'
*
*        Test 11
         DC    XL4'1A2B3C4D'                       Exp output
         DC    H'2'                                Exp CC
         DC    H'2'                                Init CC
         DC    A(*+4+10)                           Exp R1
         DC    CL(L'INPUTVAL)'  1A2B3C4D5E6F '     Input
         DC    CL(L'TESTDESC)'Check 12 digits'
*
*        Test 12
         DC    XL4'00'                             Exp output
         DC    H'3'                                Exp CC
         DC    H'0'                                Init CC
         DC    A(*+4+20)                           Exp R1
         DC    CL(L'INPUTVAL)' '                   Input
         DC    CL(L'TESTDESC)'Check all blanks ERR'
**********************************************************************
*        Add new tests above this line
**********************************************************************
TESTN    EQU   *-TDATALEN      Last test
*
**********************************************************************
*        DSECT for one test
**********************************************************************
TESTDATA DSECT ,
EXPOUT   DS    F               Expected output
EXPCC    DS    H               Expected condition code
INITCC   DS    H               Initial condition code
EXPR1    DS    F               Expected R1 value
INPUTVAL DS    CL20            Input value
TESTDESC DS    CL20            Test description
TDATALEN EQU   *-TESTDATA      Length of test data
         END
