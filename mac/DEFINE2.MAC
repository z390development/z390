         MACRO
.**********************************************************************
.* Copyright 2007 Automated Software Tools Corporation                *
.* This source code is part of z390 assembler/emulator package        *
.* The z390 package is distributed under GNU general public license   *
.* Author - Don Higgins                                               *
.* Date   - 04/19/07                                                  *
.* Modified by Melvyn Maltz                                           *
.* Date   - 02/16/16                                                  *
.**********************************************************************
.* 07/31/07 RPI 668 INITIAL CODING
.* 08/04/07 RPI 668 ADD VCDTTIOT FOR ACCESSING TIOT PATH/FILE
.* 09/02/07 RPI 681 EXPAND DEFINE TO DEFINE ENTIRE VSAM CATALOG
.* 09/23/07 RPI 704 ADD CLUSTER SUPPORT FOR CONTROLINTERVALSIZE=
.* 04/19/08 RPI 833 add SETC quotes for HLASM compatibility
.* 10/14/10 RPI 1130 change keyword parms and check for errors:
.*             REUSE=NO,UNIQUEKEY=YES,UPGRADE=YES,UPDATE=YES
.* 02/16/16 ZVSAM rewrite
.*          Bugs VSEDSN s/be VESDSN
.*          VX0DSN removed
.*          VXNDSN replaced with VESDSN
.*          DCB, MODELDCB and VCDTDCBA removed
.*          DATABLOCKSIZE/INDEXBLOCKSIZE added to CLUSTER and AIX
.*             in bytes or nK
.*             to replace CONTROLINTERVALSIZE
.*          DATAFREESPACE=(n%)/INDEXFREESPACE=(n%)
.*          DATAFREEBLOCKS=(x,y)/INDEXFREEBLOCKS=(x,y)
.*          SPANNED=YES/NO (default NO)
.*          DATAADJUST/INDEXADJUST=YES/NO (default NO)
.*             This optimizes DATABLOCKSIZE/INDEXBLOCKSIZE (if YES)
.*             DATAADJUST only applicable to FIXED datasets/unique AIX
.*          Not supporting DISP=MOD overrides
.*          VES now changed to DTA
.*********************************************************************
.*
.* DEFINE - define z390 VSAM catalog loadable table entries:
.*
.*           1. DEFINE CATALOG,        DEFINE VCDT VSAM CATALOG TABLE
.*                     NAME=,          NAME OF VCDT CATALOG TABLE
.*                     VERSION=        VERSION ID
.*
.*           2. DEFINE CLUSTER,        DEFINE CLUSTER (DATA/INDEX)
.*                     NAME=,          CLUSTER NAME
.*                     INDEX=INDEXED/NONINDEXED/NUMBERED/LINEAR TYPE
.*                     RECORDSIZE=(average,max), or fixed length, V/F
.*                     SPANNED=NO,     SPANNED NO/YES
.*                     KEYS=(64,0),    KSDS PRIMARY KEY LENGTH, OFFSET
.*                     REUSE=YES,      ERASE ALL DATA AT OPEN RPI 1130
.*                     DTADSN=,        OPTIONAL DSNAME FOR DTA FILE
.*                     DATABLOCKSIZE=4K,  DATA BLOCKSIZE
.*                     INDEXBLOCKSIZE=4K, INDEX BLOCKSIZE
.*                     DATAADJUST=YES,  ADJUST DATABLOCKSIZE NO/YES
.*                     INDEXADJUST=YES, ADJUST INDEXBLOCKSIZE NO/YES
.*                     DATAFREESPACE=n,  DATA FREESPACE %
.*                     INDEXFREESPACE=n, INDEX FREESPACE %
.*                     DATAFREEBLOCKS=(x,y), DATA x FREE BLOCKS aft y
.*                     INDEXFREESPACE=(x,y)  INDEX x FREE BLOCKS aft y
.*
.*           3. DEFINE ALTERNATEINDEX, DEFINE KSDS ALTERNATE INDEX KEY
.*                     NAME=,          NAME OF KSDS ALT IDX
.*                     RELATE=,        NAME OF CLUSTER
.*                     KEYS=(64,0),    ALTERNATE KEY IN CLUSTER
.*                     UNIQUEKEY=YES,  DO NOT ALLOW DUPLICATES RPI 1130
.*                     MAXELEMENTS=N,  WHEN UNIQUEKEY=NO, ADJUST BLKSZ
.*                     UPGRADE=YES,    UPDATE AIX FOR BASE CHANGE  1130
.*                     REUSE=YES,      ERASE ALL DATA AT OPEN RPI 1130
.*                     SPANNED=NO,     SPANNED NO/YES
.*                     DTADSN=,        OPTIONAL DSNAME FOR AIX
.*                     DATABLOCKSIZE=4K,  DATA BLOCKSIZE
.*                     INDEXBLOCKSIZE=4K, INDEX BLOCKSIZE
.*                     DATAADJUST=YES,  ADJUST DATABLOCKSIZE NO/YES
.*                     INDEXADJUST=YES, ADJUST INDEXBLOCKSIZE NO/YES
.*                     DATAFREESPACE=n,  DATA FREESPACE %
.*                     INDEXFREESPACE=n, INDEX FREESPACE %
.*                     DATAFREEBLOCKS=(x,y), DATA x FREE BLOCKS aft y
.*                     INDEXFREESPACE=(x,y)  INDEX x FREE BLOCKS aft y
.*
.*           4. DEFINE PATH,           DEFINE PATH FOR KSDS ACCESS
.*                     NAME=,          NAME OF PATH
.*                     ENTRY=,         NAME OF AIX OR BASE     RPI 1130
.*                     UPDATE=YES      UPDATE AIX FOR BASE CHANGE  1130
.*
.*           5. DEFINE END             GENERATE CATALOG TABLE
.*
.*   See example in vsam\demo and vsam\test directories:
.*     1.  vsam\demo\DEMOCAT.MLC defines demo VSAM files
.*     2.  vsam\test\TESTCAT.MLC defines test VSAM files
.*
.*     The DDNAME in ACB must point to the VCDT loadable catalog
.*     containing the base cluster or alternate path to be opened
.*     The DDNAME may have optional specific name appended to catalog
.*     name separated by period otherwise the ACB label field name will
.*     be the name used to search VCDT catalog for matching cluster
.*     or alternate path name
.*
.*  Notes:
.*    1.  Variable length VSAM records are prefixed by 4 byte length
.*        which is not included in RECORDSIZE=(average,maximum)
.*    2.  Specify INDEXED=INDEXED    for KSDS (default)
.*        Specify INDEXED=NONINDEXED for ESDS sequential file
.*        Specify INDEXED=NUMBERED   for RRDS relative record file
.*        Specify INDEXED=LINEAR     for LDS  CI size required
.*********************************************************************
         DEFINE2 &TYPE,        CATALOG,CLUSTER,ALTERNATEINDEX,PATH     X
               &NAME=,         NAME OF CATALOG, CLUSTER, AIX, OR PATH  X
               &VERSION=2,     CATALOG VERSION ID                      X
               &DATABLOCKSIZE=4K,  DATA BLOCKSIZE                      X
               &INDEXBLOCKSIZE=4K, INDEX BLOCKSIZE                     X
               &DATAADJUST=NO,     ADJUST DATA BLOCKSIZE               X
               &INDEXADJUST=NO,    ADJUST INDEX BLOCKSIZE              X
               &DATAFREESPACE=0,   DATA FREESPACE %                    X
               &INDEXFREESPACE=0,  INDEX FREESPACE %                   X
               &DATAFREEBLOCKS=(0,0),  FREE DATA BLOCKS AFTER NUMBER   X
               &INDEXFREEBLOCKS=(0,0), FREE INDEX BLOCKS AFTER NUMBER  X
               &ENTRY=,        AIX OR BASE CLUSTER NAME FOR PATH       X
               &INDEX=,        INDEXED/NONINDEXED/NUMBERED/LINEAR      X
               &KEYS=(0,0),    (LENGTH,OFFSET) FOR KSDS PRI/ALT KEY    X
               &RECORDSIZE=,   FIXED LENGTH OR VAR (AVG,MAX) CLUSTER   X
               &SPANNED=NO,    SPANNED NO/YES                          X
               &RELATE=,       CLUSTER NAME FOR ALTERNATEINDEX         X
               &REUSE=NO,      RESET HIGH XRBA AT OPEN FOR AIX/CLUSTER X
               &UNIQUEKEY=YES, REQUIRE UNIQUE AIX KEYS        RPI 1130 X
               &MAXELEMENTS=0, WHEN UNIQUEKEY=NO, ADJUST BLOCKSIZE     X
               &UPDATE=YES,    REQUIRE AIX UPDATES FOR THIS PATH  1130 X
               &UPGRADE=YES,   REQUIRE AIX UPDATE FOR THIS AIX    1130 X
               &DTADSN=,       OVERRIDE CLUSTER DSNAME FOR DTA         X
               &IDXDSN=        OVERRIDE CLUSTER DSNAME FOR IDX
.*
         COPY  ZDEFINE2.CPY    INCLUDE GLOBALS
.*
         AIF   (N'&SYSLIST LE 1).CHKTYPE
         MNOTE 12,'UNDEFINED PARAMETER - &SYSLIST(2)' RPI 1130
.*
.CHKTYPE ANOP
         AIF   ('&TYPE' EQ 'CATALOG').DEFINE_CATALOG
         AIF   ('&TYPE' EQ 'CLUSTER').DEFINE_CLUSTER
         AIF   ('&TYPE' EQ 'ALTERNATEINDEX').DEFINE_AIX
         AIF   ('&TYPE' EQ 'AIX').DEFINE_AIX
         AIF   ('&TYPE' EQ 'PATH').DEFINE_PATH
         AIF   ('&TYPE' EQ 'END').DEFINE_END
         MNOTE 12,'DEFINE INVALID TYPE - &TYPE'
.*
.******************
.* DEFINE CATALOG *
.******************
.DEFINE_CATALOG ANOP
         AIF   ('&NAME' NE '' AND K'&NAME LE 8).SET_CATALOG2
         MNOTE 12,'INVALID CATALOG NAME - &NAME'
.*
.SET_CATALOG2 ANOP
&CATALOG SETC '&NAME'
         AIF   (K'&VERSION EQ 1).GOODVER
         MNOTE 12,'INVALID CATALOG VERSION ID - &VERSION'
.GOODVER ANOP
&CATVERS SETC '&VERSION'
         MEXIT
.*
.******************
.* DEFINE CLUSTER *
.******************
.DEFINE_CLUSTER ANOP
&CLR_TOT SETA  &CLR_TOT+1
.*
.* SET CLUSTER DATABLOCKSIZE
.*
&LEN     SETA  &DATABLOCKSIZE
         AIF   ('&DATABLOCKSIZE'(K'&DATABLOCKSIZE,1) NE 'K')
               :&CLR_DBS(&CLR_TOT) SETA &DATABLOCKSIZE
         AELSE
               :&LEN SETA &LEN*1024
               :&CLR_DBS(&CLR_TOT) SETA &LEN
         AEND
         AIF   (&CLR_DBS(&CLR_TOT) LT 512)
         MNOTE 12,'CLUSTER DATABLOCKSIZE LESS THAN 512 BYTES'
         AEND
.*
.*
.* SET CLUSTER INDEXBLOCKSIZE
.*
&LEN     SETA  &INDEXBLOCKSIZE
.*
         AIF   ('&INDEXBLOCKSIZE'(K'&INDEXBLOCKSIZE,1) NE 'K')
               :&CLR_IBS(&CLR_TOT) SETA &INDEXBLOCKSIZE
         AELSE
               :&LEN SETA &LEN*1024
               :&CLR_IBS(&CLR_TOT) SETA &LEN
         AEND
         AIF   (&CLR_IBS(&CLR_TOT) LT 512)
         MNOTE 12,'CLUSTER INDEXBLOCKSIZE LESS THAN 512 BYTES'
         AEND
.*
.* SET CLUSTER DATAADJUST
.*
         AIF   ('&DATAADJUST' EQ 'NO').SET_CLR_NODADJ
         AIF   ('&DATAADJUST' EQ 'YES').SET_CLR_DADJ
         MNOTE 12,'CLUSTER DATAADJUST MUST BE YES/NO - &DATAADJUST'
.*
.SET_CLR_DADJ ANOP
&CLR_DADJ(&CLR_TOT) SETB 1
.*
.SET_CLR_NODADJ ANOP
.*
.* SET CLUSTER INDEXADJUST
.*
         AIF   ('&INDEXADJUST' EQ 'NO').SET_CLR_DFREE
         AIF   ('&INDEXADJUST' EQ 'YES').SET_CLR_IADJ
         MNOTE 12,'CLUSTER INDEXADJUST MUST BE YES/NO - &INDEXADJUST'
.*
.SET_CLR_IADJ ANOP
&CLR_IADJ(&CLR_TOT) SETB 1
.*
.SET_CLR_DFREE ANOP
.*
.* SET CLUSTER DATAFREESPACE
.*
         AIF   (&DATAFREESPACE GT 99)
         MNOTE 12,'INVALID CLUSTER DATAFREESPACE - &DATAFREESPACE'
         AELSE
               :&CLR_DFS(&CLR_TOT) SETA &DATAFREESPACE
         AEND
.*
.* SET CLUSTER INDEXFREESPACE
.*
         AIF   (&INDEXFREESPACE GT 99)
         MNOTE 12,'INVALID CLUSTER INDEXFREESPACE - &INDEXFREESPACE'
         AELSE
               :&CLR_IFS(&CLR_TOT) SETA &INDEXFREESPACE
         AEND
.*
.* SET CLUSTER DATAFREEBLOCKS
.*
         AIF   (&DATAFREEBLOCKS(1)+&DATAFREEBLOCKS(2) EQ 0).CDFBOK
         AIF   ('&INDEX' NE 'INDEXED').CDFBERR
         AIF   (N'&DATAFREEBLOCKS NE 2).CDFBERR
         AIF   (&DATAFREEBLOCKS(1) GT 65535).CDFBERR
         AIF   (&DATAFREEBLOCKS(2) GT 65535).CDFBERR
         AIF   (&DATAFREEBLOCKS(1) EQ 0 AND &DATAFREEBLOCKS(2) NE 0).CD-
               FBERR
         AGO   .CDFBOK
.*
.CDFBERR ANOP
         MNOTE 12,'INVALID CLUSTER DATAFREEBLOCKS - &DATAFREEBLOCKS'
         AGO   .DOCIFB
.*
.CDFBOK  ANOP
&CLR_DNB(&CLR_TOT) SETA &DATAFREEBLOCKS(1)
&CLR_DFB(&CLR_TOT) SETA &DATAFREEBLOCKS(2)
.*
.* SET CLUSTER INDEXFREEBLOCKS
.*
.DOCIFB  ANOP
         AIF   (&INDEXFREEBLOCKS(1)+&INDEXFREEBLOCKS(2) EQ 0).CIFBOK
         AIF   ('&INDEX' NE 'INDEXED').CIFBERR
         AIF   (N'&INDEXFREEBLOCKS NE 2).CIFBERR
         AIF   (&INDEXFREEBLOCKS(1) GT 65535).CIFBERR
         AIF   (&INDEXFREEBLOCKS(2) GT 65535).CIFBERR
         AIF   (&INDEXFREEBLOCKS(1) EQ 0 AND &INDEXFREEBLOCKS(2) NE 0).-
               CIFBERR
         AGO   .CIFBOK
.*
.CIFBERR ANOP
         MNOTE 12,'INVALID CLUSTER INDEXFREEBLOCKS - &INDEXFREEBLOCKS'
         AGO   .SET_CLR_NAME
.*
.CIFBOK  ANOP
&CLR_INB(&CLR_TOT) SETA &INDEXFREEBLOCKS(1)
&CLR_IFB(&CLR_TOT) SETA &INDEXFREEBLOCKS(2)
.*
.* SET CLUSTER NAME
.*
.SET_CLR_NAME ANOP
         AIF   ('&NAME' NE '' AND K'&NAME LE 8).SET_CLR_NAME2
         MNOTE 12,'INVALID CLUSTER NAME - &NAME'
.*
.SET_CLR_NAME2 ANOP
&CLR_NAME(&CLR_TOT) SETC '&NAME'
.*
.* SET CLUSTER TYPE
.*
         AIF   ('&INDEX' EQ 'INDEXED').SET_CLR_KSDS
         AIF   ('&INDEX' EQ 'NONINDEXED').SET_CLR_ESDS
         AIF   ('&INDEX' EQ 'NUMBERED').SET_CLR_RRDS
         AIF   ('&INDEX' EQ 'LINEAR').SET_CLR_LDS
         MNOTE 12,'INVALID INDEX TYPE - &INDEX'
.*
.SET_CLR_KSDS ANOP
&CLR_TYPE(&CLR_TOT) SETC 'KSDS'
&CLR_KSDS(&CLR_TOT) SETB 1
         AIF   (&DATAFREESPACE NE 0 AND N'&RECORDSIZE EQ 1 AND '&SPANNE-
               D' EQ 'YES')
            MNOTE 12,'FIXED SPANNED KSDS CANNOT HAVE FREESPACE'
         AEND
         AIF   (N'&RECORDSIZE EQ 1 AND '&SPANNED' EQ 'YES' AND &RECORDS-
               IZE LT &CLR_DBS(&CLR_TOT))
            MNOTE 4,'FIXED SPANNED KSDS AND RECORDSIZE<BLOCKSIZE'
         AEND
         AGO   .SET_CLR_VREC
.*
.SET_CLR_ESDS ANOP
&CLR_TYPE(&CLR_TOT) SETC 'ESDS'
&CLR_ESDS(&CLR_TOT) SETB 1
.* IF FIXED ESDS AND FREESPACE NOT ZERO IT'S AN ERROR
&FREE    SETA &DATAFREESPACE+&INDEXFREESPACE
         AIF  (&FREE NE 0 AND N'&RECORDSIZE EQ 1)
            MNOTE 12,'FIXED ESDS CANNOT HAVE FREESPACE'
         AEND
.* IF ESDS AND FREEBLOCKS NOT ZERO IT'S AN ERROR
&FREE    SETA  &DATAFREEBLOCKS(1)+&DATAFREEBLOCKS(2)+&INDEXFREEBLOCKS(1-
               )+&INDEXFREEBLOCKS(2)
         AIF  (&FREE NE 0)
            MNOTE 12,'ESDS CANNOT HAVE FREEBLOCKS'
         AEND
         AGO   .SET_CLR_VREC
.*
.SET_CLR_RRDS ANOP
&CLR_TYPE(&CLR_TOT) SETC 'RRDS'
&CLR_RRDS(&CLR_TOT) SETB 1
&FREE    SETA &DATAFREESPACE+&INDEXFREESPACE
         AIF  (&FREE NE 0 AND N'&RECORDSIZE EQ 1)
            MNOTE 12,'FIXED RRDS CANNOT HAVE FREESPACE'
         AEND
         AGO   .SET_CLR_VREC
.*
.SET_CLR_LDS ANOP
&CLR_TYPE(&CLR_TOT) SETC 'LDS'
&CLR_LDS(&CLR_TOT) SETB 1
         AGO   .SET_CLR_DTADSN
.*
.* SET CLUSTER VREC FLAG AND LAVG AND LMAX
.*
.SET_CLR_VREC ANOP
         AIF  (N'&RECORDSIZE EQ 2).SET_CLR_VREC2
&CLR_LMAX(&CLR_TOT) SETA &RECORDSIZE  SET FIXED RECORDSIZE
         AGO  .SET_CLR_DOSPAN
.*
.SET_CLR_VREC2 ANOP
&CLR_VREC(&CLR_TOT) SETB 1              INDICATE VARIABLE
&CLR_LAVG(&CLR_TOT) SETA &RECORDSIZE(1) SET AVG RECORDSIZE
&CLR_LMAX(&CLR_TOT) SETA &RECORDSIZE(2) SET MAX RECORDSIZE
.* CANNOT ADJUST IF VARIABLE
         AIF   ('&DATAADJUST' EQ 'YES').ADJERR
         AGO   .SET_CLR_DOSPAN
.*
.ADJERR  ANOP
         MNOTE 12,'DATA/INDEXADJUST MUST BE NO FOR VARIABLE FILES'
.*
.* SET CLUSTER SPANNED
.*
.SET_CLR_DOSPAN ANOP
         AIF   ('&SPANNED' EQ 'NO').SET_CLR_KEY
         AIF   ('&SPANNED' EQ 'YES').SET_CLR_SPAN
         MNOTE 12,'CLUSTER SPANNED MUST BE YES/NO - &SPANNED'
.*
.SET_CLR_SPAN ANOP
&CLR_SPAN(&CLR_TOT) SETB 1
         AIF   ('&DATAADJUST' EQ 'NO').SET_CLR_KEY
         MNOTE 12,'CLUSTER SPANNED=YES CANNOT HAVE DATAADJUST=YES'
.*
.* SET CLUSTER KSDS KEY LENGTH AND OFFSET
.*
.SET_CLR_KEY ANOP
         AIF   ('&CLR_TYPE(&CLR_TOT)' NE 'KSDS').SET_CLR_DOREUSE
         AIF   (&KEYS(1) EQ 0).ERRCKEYS
         AIF   (N'&KEYS EQ 2).SET_CLR_KEY2
.ERRCKEYS ANOP
         MNOTE 12,'CLUSTER INVALID KEYS FOR KSDS - &KEYS'
.*
.SET_CLR_KEY2 ANOP
&CLR_KLEN(&CLR_TOT) SETA &KEYS(1)
&CLR_KOFF(&CLR_TOT) SETA &KEYS(2)
         AIF   (&CLR_KOFF(&CLR_TOT)+&CLR_KLEN(&CLR_TOT) LE &CLR_LMAX(&C-
               LR_TOT)).SET_CLR_KEY3
         MNOTE 12,'CLUSTER KEY EXTENDS BEYOND RECORDSIZE'
.*
.SET_CLR_KEY3 ANOP
.*
.* SET CLUSTER REUSE
.*
.SET_CLR_DOREUSE ANOP
         AIF   ('&REUSE' EQ 'NO').SET_CLR_DTADSN
         AIF   ('&REUSE' EQ 'YES').SET_CLR_REUSE
         MNOTE 12,'CLUSTER REUSE MUST BE YES/NO - &REUSE'
.*
.SET_CLR_REUSE ANOP
&CLR_REUSE(&CLR_TOT) SETB 1
.*
.* SET CLUSTER DTADSN
.*
.SET_CLR_DTADSN ANOP
         AIF   ('&DTADSN' EQ '').SET_CLR_IDXDSN
&CLR_DTA(&CLR_TOT) SETC '&DTADSN'
.*
.* SET CLUSTER IDXDSN
.*
.SET_CLR_IDXDSN ANOP
         AIF   ('&IDXDSN' EQ '').SET_CLR_MEXIT
         AIF   ('&DTADSN' EQ '&IDXDSN')
         MNOTE 12,'DTADSN AND IDXDSN ARE IDENTICAL'
         AEND
&CLR_IDX(&CLR_TOT) SETC '&IDXDSN'
.SET_CLR_MEXIT ANOP
         MEXIT
.*
.**************
.* DEFINE AIX *
.**************
.DEFINE_AIX ANOP
&AIX_TOT SETA  &AIX_TOT+1
.*
.* SET AIX NAME
.*
         AIF   ('&NAME' NE '' AND K'&NAME LE 8).SET_AIX_NAME2
         MNOTE 12,'INVALID AIX NAME - &NAME'
.SET_AIX_NAME2 ANOP
&AIX_NAME(&AIX_TOT) SETC '&NAME'
.*
.* SET AIX KEY LENGTH AND OFFSET
.*
         AIF   (&KEYS(1) EQ 0).ERRAKEYS
         AIF (N'&KEYS EQ 2).SET_AIX_KEY2
.ERRAKEYS ANOP
         MNOTE 12,'AIX INVALID KEYS - &KEYS'
.SET_AIX_KEY2 ANOP
&AIX_KLEN(&AIX_TOT) SETA &KEYS(1)
&AIX_KOFF(&AIX_TOT) SETA &KEYS(2)
.*
.* SET AIX RELATE
.*
         AIF   ('&RELATE' NE '').SET_AIX_RELATE2
         MNOTE 12,'AIX MISSING RELATE NAME OF CLUSTER'
.SET_AIX_RELATE2 ANOP
&AIX_RELATE(&AIX_TOT) SETC '&RELATE'
.*
.* SET AIX REUSE
.*
         AIF   ('&REUSE' EQ 'NO').SET_AIX_UNIQUEKEY
         AIF   ('&REUSE' EQ 'YES').SET_REUSE
         MNOTE 12,'AIX REUSE MUST BE YES/NO - &REUSE'
.*
.SET_REUSE ANOP
&AIX_REUSE(&AIX_TOT) SETB 1
.*
.* SET AIX UNIQUEKEY
.*
.SET_AIX_UNIQUEKEY ANOP
         AIF   ('&UNIQUEKEY' EQ 'NO').SET_AIX_MAXELEMENTS RPI 1130
         AIF   ('&UNIQUEKEY' EQ 'YES').SET_UNIQUEKEY
         MNOTE 12,'UNIQUEKEY MUST BE YES/NO - &UNIQUEKEY'
.SET_UNIQUEKEY ANOP
&AIX_UNIQUEKEY(&AIX_TOT) SETB 1
.SET_AIX_MAXELEMENTS ANOP
.*
.* SET AIX MAXELEMENTS
.*
&AIX_MAXELEMENTS(&AIX_TOT) SETA 0
&LEN     SETA  &MAXELEMENTS
         AIF   (&MAXELEMENTS NE 0 AND '&UNIQUEKEY' EQ 'YES')
         MNOTE 15,'MAXELEMENTS CAN ONLY BE SPECIFIED IF UNIQUEKEY=NO'
         AEND
         AIF   (&MAXELEMENTS EQ 0).SET_AIX_UPGRADE
         AIF   ('&MAXELEMENTS'(K'&MAXELEMENTS,1) NE 'K')
               :&AIX_MAXELEMENTS(&AIX_TOT) SETA &MAXELEMENTS
         AELSE
               :&LEN SETA &LEN*1024
               :&AIX_MAXELEMENTS(&AIX_TOT) SETA &LEN
         AEND
         AIF   (&AIX_MAXELEMENTS(&AIX_TOT) GT 2147483647)
         MNOTE 15,'MAXELEMENTS TOO LARGE - &AIX_MAXELEMENTS(&AIX_TOT)'
         AEND
.*
.* SET AIX UPGRADE
.*
.SET_AIX_UPGRADE ANOP
         AIF   ('&UPGRADE' EQ 'NO').SET_AIX_DTADSN
         AIF   ('&UPGRADE' EQ 'YES').SET_UPGRADE
         MNOTE 12,'AIX UPGRADE MUST BE YES/NO - &UPGRADE'
.*
.SET_UPGRADE ANOP
&AIX_UPGRADE(&AIX_TOT) SETB 1
.*
.* SET AIX DTADSN
.*
.SET_AIX_DTADSN ANOP
         AIF   ('&DTADSN' EQ '').SET_AIX_IDXDSN
&AIX_DTA(&AIX_TOT) SETC '&DTADSN'
.*
.* SET CLUSTER IDXDSN
.*
.SET_AIX_IDXDSN ANOP
         AIF   ('&IDXDSN' EQ '').SET_AIX_DBS
         AIF   ('&DTADSN' EQ '&IDXDSN')
         MNOTE 12,'DTADSN AND IDXDSN ARE IDENTICAL'
         AEND
&AIX_IDX(&AIX_TOT) SETC '&IDXDSN'
.SET_AIX_DBS ANOP
.*
.* SET AIX DATABLOCKSIZE
.*
&LEN     SETA  &DATABLOCKSIZE
         AIF   ('&DATABLOCKSIZE'(K'&DATABLOCKSIZE,1) NE 'K')
               :&AIX_DBS(&AIX_TOT) SETA &DATABLOCKSIZE
         AELSE
               :&LEN SETA &LEN*1024
               :&AIX_DBS(&AIX_TOT) SETA &LEN
         AEND
         AIF   ('&MAXELEMENTS' NE '').SET_AIX_IDXBLKSZ
         AIF   (&AIX_DBS(&AIX_TOT) LT 512)
         MNOTE 12,'AIX DATABLOCKSIZE LESS THAN 512 BYTES'
         AEND
.*
.SET_AIX_IDXBLKSZ ANOP
.*
.* SET AIX INDEXBLOCKSIZE
.*
&LEN     SETA  &INDEXBLOCKSIZE
         AIF   ('&INDEXBLOCKSIZE'(K'&INDEXBLOCKSIZE,1) NE 'K')
               :&AIX_IBS(&AIX_TOT) SETA &INDEXBLOCKSIZE
         AELSE
               :&LEN SETA &LEN*1024
               :&AIX_IBS(&AIX_TOT) SETA &LEN
         AEND
         AIF   (&AIX_IBS(&AIX_TOT) LT 512)
         MNOTE 12,'AIX INDEXBLOCKSIZE LESS THAN 512 BYTES'
         AEND
.*
.* SET AIX DATAADJUST
.*
         AIF   ('&DATAADJUST' EQ 'NO').SET_AIX_NODADJ
         AIF   ('&DATAADJUST' EQ 'YES').SET_AIX_DADJ
         MNOTE 12,'AIX DATAADJUST MUST BE YES/NO - &DATAADJUST'
.*
.SET_AIX_DADJ ANOP
         AIF   ('&UNIQUEKEY' EQ 'NO')
         MNOTE 12,'AIX DATAADJUST MUST BE NO FOR NON-UNIQUE KEYS'
         AEND
&AIX_DADJ(&AIX_TOT) SETB 1
.*
.SET_AIX_NODADJ ANOP
.*
.* SET AIX INDEXADJUST
.*
         AIF   ('&INDEXADJUST' EQ 'NO').SET_AIX_IADJ
         AIF   ('&INDEXADJUST' EQ 'YES').SET_AIX_IADJ
         MNOTE 12,'AIX INDEXADJUST MUST BE YES/NO - &INDEXADJUST'
.*
.SET_AIX_IADJ ANOP
&AIX_IADJ(&AIX_TOT) SETB 1
.*
.* SET AIX DATAFREESPACE
.*
         AIF   (&DATAFREESPACE GT 99)
         MNOTE 12,'INVALID AIX DATAFREESPACE - &DATAFREESPACE'
         AELSE
               :&AIX_DFS(&AIX_TOT) SETA &DATAFREESPACE
         AEND
.*
.* SET AIX INDEXFREESPACE
.*
         AIF   (&INDEXFREESPACE GT 99)
         MNOTE 12,'INVALID AIX INDEXFREESPACE - &INDEXFREESPACE'
         AELSE
               :&AIX_IFS(&AIX_TOT) SETA &INDEXFREESPACE
         AEND
.*
.* SET AIX DATAFREEBLOCKS
.*
         AIF   (&DATAFREEBLOCKS(1)+&DATAFREEBLOCKS(2) EQ 0).ADFBOK
         AIF   (N'&DATAFREEBLOCKS NE 2).ADFBERR
         AIF   (&DATAFREEBLOCKS(1) GT 65535).ADFBERR
         AIF   (&DATAFREEBLOCKS(2) GT 65535).ADFBERR
         AIF   (&DATAFREEBLOCKS(1) EQ 0 AND &DATAFREEBLOCKS(2) NE 0).AD-
               FBERR
         AGO   .ADFBOK
.*
.ADFBERR ANOP
         MNOTE 12,'INVALID AIX DATAFREEBLOCKS - &DATAFREEBLOCKS'
         AGO   .DOAIFB
.*
.ADFBOK  ANOP
&AIX_DNB(&AIX_TOT) SETA &DATAFREEBLOCKS(1)
&AIX_DFB(&AIX_TOT) SETA &DATAFREEBLOCKS(2)
.*
.* SET AIX INDEXFREEBLOCKS
.*
.DOAIFB  ANOP
         AIF   (&INDEXFREEBLOCKS(1)+&INDEXFREEBLOCKS(2) EQ 0).AIFBOK
         AIF   (N'&INDEXFREEBLOCKS NE 2).AIFBERR
         AIF   (&INDEXFREEBLOCKS(1) GT 65535).AIFBERR
         AIF   (&INDEXFREEBLOCKS(2) GT 65535).AIFBERR
         AIF   (&INDEXFREEBLOCKS(1) EQ 0 AND &INDEXFREEBLOCKS(2) NE 0).-
               AIFBERR
         AGO   .AIFBOK
.*
.AIFBERR ANOP
         MNOTE 12,'INVALID AIX INDEXFREEBLOCKS - &INDEXFREEBLOCKS'
         MEXIT
.*
.AIFBOK  ANOP
&AIX_INB(&AIX_TOT) SETA &INDEXFREEBLOCKS(1)
&AIX_IFB(&AIX_TOT) SETA &INDEXFREEBLOCKS(2)
         MEXIT
.*
.***************
.* DEFINE PATH *
.***************
.DEFINE_PATH ANOP
&PTH_TOT SETA  &PTH_TOT+1
.*
.* SET PATH NAME
.*
         AIF   ('&NAME' NE '' AND K'&NAME LE 8).SET_PTH_NAME2
         MNOTE 12,'INVALID PATH NAME - &NAME'
.SET_PTH_NAME2 ANOP
&PTH_NAME(&PTH_TOT) SETC '&NAME'
.*
.* SET PATH ENTRY
.*
         AIF   ('&ENTRY' NE '').SET_PTH_ENTRY2
         MNOTE 12,'PATH MISSING ENTRY NAME OF AIX OR BASE'
.SET_PTH_ENTRY2 ANOP
&PTH_ENTRY(&PTH_TOT) SETC '&ENTRY'
.*
.* SET PATH UPDATE
.*
         AIF   ('&UPDATE' EQ 'NO').SET_PTH_UPDATE2
         AIF   ('&UPDATE' EQ 'YES').SET_UPDATE
         MNOTE 12,'PATH UPDATE MUST BE YES/NO - &UPDATE'
.SET_UPDATE ANOP
&PTH_UPDATE(&PTH_TOT) SETB 1
.SET_PTH_UPDATE2 ANOP
         MEXIT
.**************
.* DEFINE END *
.**************
.DEFINE_END ANOP
.*
.* VERIFY VAIX ENTRIES HAVE MATCHING VCLR RELATE
.*
&AIX_CUR SETA  0
.CHK_AIX ANOP
&AIX_CUR SETA  &AIX_CUR+1
         AIF   (&AIX_CUR GT &AIX_TOT).CHK_AIX_END
&CLR_CUR SETA  0
.FIND_CLR ANOP
&CLR_CUR SETA  &CLR_CUR+1
         AIF   (&CLR_CUR GT &CLR_TOT).AIX_ERR
         AIF   ('&AIX_RELATE(&AIX_CUR)' NE '&CLR_NAME(&CLR_CUR)').FIND_-
               CLR
         AIF   (&AIX_KOFF(&AIX_CUR)+&AIX_KLEN(&AIX_CUR) LE &CLR_LMAX(&C-
               LR_CUR)).CHK_AIX
         MNOTE 12,'DEFINE AIX &AIX_NAME(&AIX_CUR) KEY BEYOND CLUSTER &C-
               LR_NAME(&CLR_CUR) RECORD'
         AGO   .CHK_AIX
.*
.AIX_ERR ANOP
         MNOTE 12,'DEFINE AIX RELATE=&AIX_RELATE(&AIX_CUR) NOT FOUND'
         AGO   .CHK_AIX
.*
.CHK_AIX_END ANOP
.* VERIFY VPTH ENTRIES HAVE MATCHING VCLR OR VAIX ENTRY
.* AND SET VPTH_AIXP ACCORDINGLY
.*
&PTH_CUR SETA  0
.CHK_PTH ANOP
&PTH_CUR SETA  &PTH_CUR+1
         AIF   (&PTH_CUR GT &PTH_TOT).CHK_PTH_END
&AIX_CUR SETA  0
.FIND_AIX ANOP
&AIX_CUR SETA  &AIX_CUR+1
         AIF   (&AIX_CUR GT &AIX_TOT).CHK_CLR
         AIF   ('&PTH_ENTRY(&PTH_CUR)' EQ '&AIX_NAME(&AIX_CUR)').SET_AI-
               XP
         AGO   .FIND_AIX
.*
.SET_AIXP ANOP
&PTH_AIXP(&PTH_CUR) SETB 1
         AGO   .CHK_PTH
.*
.CHK_CLR ANOP
&CLR_CUR SETA  0
.FIND_CLR2 ANOP
&CLR_CUR SETA  &CLR_CUR+1
         AIF   (&CLR_CUR GT &CLR_TOT).PTH_ERR
         AIF   ('&PTH_ENTRY(&PTH_CUR)' EQ '&CLR_NAME(&CLR_CUR)').CHK_PT-
               H
         AGO   .FIND_CLR2
.*
.PTH_ERR ANOP
         MNOTE 12,'DEFINE PATH ENTRY=&PTH_ENTRY(&PTH_CUR) NOT FOUND'
         AGO   .CHK_PTH
.*
.CHK_PTH_END ANOP
         ZDEFINE2 , GENERATE VCDT CATALOG LOADABLE TABLE
         VCDTD2   , GENERATE VCDT DSECTS
         MEXIT
         MEND
