         MACRO
.*********************************************************************
.* z390 - Mainframe assembler emulator and run-time engine
.* Copyright (C) 2021 z390 Assembler LLC
.*
.* This file is part of z390.
.*
.* z390 is free software; you can redistribute it and/or modify
.* it under the terms of the GNU General Public License as published by
.* the Free Software Foundation; either version 2 of the License, or
.* (at your option) any later version.
.* z390 is distributed in the hope that it will be useful,
.* but WITHOUT ANY WARRANTY; without even the implied warranty of
.* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.* GNU General Public License for more details.
.*
.* You should have received a copy of the GNU General Public License
.* along with this program; if not, see https://www.gnu.org/licenses.
.*********************************************************************
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 11/17/08 stub for pending support
.* 2025/12 ZH: Implement COBOL SORT statement using existing ZSORT
.*         Implementation follows FIPS PUB 21-2 (ANSI X3.23-1985)
.*         COBOL 85 standard, Section XI (Sort-Merge).
.*         - Multi-key support with ASCENDING/DESCENDING per key
.*         - INPUT PROCEDURE / OUTPUT PROCEDURE support
.*********************************************************************
.* SORT file-name ON ASCENDING/DESCENDING KEY key-name
.*      USING input-file GIVING output-file
.*  or  INPUT PROCEDURE IS section-name
.*      OUTPUT PROCEDURE IS section-name
.*********************************************************************
         SORT  &SORTFILE
         COPY  ZC_WS
         COPY  ZC_SD
.*
.* LOCAL VARIABLES
.*
         LCLA  &KEY_CNT
         LCLA  &KEY_OFF(100)
         LCLA  &KEY_LEN(100)
         LCLC  &KEY_TYP(100)
         LCLC  &KEY_ORD(100)
         LCLC  &CUR_ORD
         LCLC  &USING_FILE
         LCLC  &GIVING_FILE
         LCLA  &LRECL
         LCLA  &USING_IX
         LCLA  &GIVING_IX
         LCLC  &USING_REC
         LCLC  &GIVING_REC
         LCLA  &KEY_LOC
         LCLA  &PAR_IX
         LCLA  &I
         LCLA  &JUMP_LEN
         LCLC  &INPUT_PROC
         LCLC  &OUTPUT_PROC
         LCLC  &SD_REC
.*
.* FIND SORT FILE
.*
         ZC_SD_FIND &SORTFILE
         AIF   (&SD_IX EQ 0)
               MNOTE 8,'SORT FILE NOT FOUND IN SD - &SORTFILE'
               MEXIT
         AEND
         :&LRECL SETA &SD_LRECL(&SD_IX)
         :&SD_REC SETC '&SD_RECORD(&SD_IX)'
.*
.* PARSE CLAUSES
.*
         :&PARM_IX SETA 2
         :&CUR_ORD SETC 'A'
         AWHILE ('&SYSLIST(&PARM_IX)' NE '')
               AIF ('&SYSLIST(&PARM_IX)' EQ 'ON')
                   :&PARM_IX SETA &PARM_IX+1
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'ASCENDING')
                   :&CUR_ORD SETC 'A'
                   :&PARM_IX SETA &PARM_IX+1
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'DESCENDING')
                   :&CUR_ORD SETC 'D'
                   :&PARM_IX SETA &PARM_IX+1
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'KEY')
                   :&PARM_IX SETA &PARM_IX+1
.*                 LOOP: Get all key names until next keyword
                   AWHILE ('&SYSLIST(&PARM_IX)' NE '')
                       AIF ('&SYSLIST(&PARM_IX)' EQ 'ON')
                           AEXIT AWHILE
                       AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'ASCENDING')
                           AEXIT AWHILE
                       AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'DESCENDING')
                           AEXIT AWHILE
                       AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'USING')
                           AEXIT AWHILE
                       AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'GIVING')
                           AEXIT AWHILE
                       AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'INPUT')
                           AEXIT AWHILE
                       AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'OUTPUT')
                           AEXIT AWHILE
                       AEND
                       ZC_SYM_FIND &SYSLIST(&PARM_IX)
                       AIF (&SYM_IX GT 0)
                           :&KEY_CNT SETA &KEY_CNT+1
                           :&KEY_LEN(&KEY_CNT) SETA &SYM_LEN(&SYM_IX)
                           :&KEY_ORD(&KEY_CNT) SETC '&CUR_ORD'
                           ACALL CALC_KEY_OFF
                           :&KEY_OFF(&KEY_CNT) SETA &KEY_LOC
                           :&KEY_TYP(&KEY_CNT) SETC 'CH'
                       AEND
                       :&PARM_IX SETA &PARM_IX+1
                   AEND
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'USING')
                   :&PARM_IX SETA &PARM_IX+1
                   :&USING_FILE SETC '&SYSLIST(&PARM_IX)'
                   :&PARM_IX SETA &PARM_IX+1
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'GIVING')
                   :&PARM_IX SETA &PARM_IX+1
                   :&GIVING_FILE SETC '&SYSLIST(&PARM_IX)'
                   :&PARM_IX SETA &PARM_IX+1
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'INPUT')
                   :&PARM_IX SETA &PARM_IX+1
                   AIF ('&SYSLIST(&PARM_IX)' EQ 'PROCEDURE')
                       :&PARM_IX SETA &PARM_IX+1
                       AIF ('&SYSLIST(&PARM_IX)' EQ 'IS')
                           :&PARM_IX SETA &PARM_IX+1
                       AEND
                       :&INPUT_PROC SETC '&SYSLIST(&PARM_IX)'
                       :&PARM_IX SETA &PARM_IX+1
                   AEND
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'OUTPUT')
                   :&PARM_IX SETA &PARM_IX+1
                   AIF ('&SYSLIST(&PARM_IX)' EQ 'PROCEDURE')
                       :&PARM_IX SETA &PARM_IX+1
                       AIF ('&SYSLIST(&PARM_IX)' EQ 'IS')
                           :&PARM_IX SETA &PARM_IX+1
                       AEND
                       :&OUTPUT_PROC SETC '&SYSLIST(&PARM_IX)'
                       :&PARM_IX SETA &PARM_IX+1
                   AEND
               AELSE
                   :&PARM_IX SETA &PARM_IX+1
               AEND
         AEND
.*
.* VALIDATE
.*
         AIF   (&KEY_CNT EQ 0)
               MNOTE 8,'SORT KEY NOT FOUND'
               MEXIT
         AEND
         AIF   ('&USING_FILE' EQ '' AND '&INPUT_PROC' EQ '')
               MNOTE 8,'SORT REQUIRES USING OR INPUT PROCEDURE'
               MEXIT
         AEND
         AIF   ('&GIVING_FILE' EQ '' AND '&OUTPUT_PROC' EQ '')
               MNOTE 8,'SORT REQUIRES GIVING OR OUTPUT PROCEDURE'
               MEXIT
         AEND
.*
.* GET RECORD LENGTH FROM SD OR USING FILE
.*
         AIF   ('&USING_FILE' NE '')
               ZC_FILE_FIND &USING_FILE
               AIF   (&FILE_IX EQ 0)
                     MNOTE 8,'SORT USING FILE NOT FOUND - &USING_FILE'
                     MEXIT
               AEND
               :&USING_IX SETA &FILE_IX
               :&USING_REC SETC '&FILE_RECORD(&FILE_IX)'
               AIF (&LRECL EQ 0)
                   ZC_SYM_FIND &USING_REC
                   AIF (&SYM_IX GT 0)
                       :&LRECL SETA &SYM_LEN(&SYM_IX)
                   AEND
               AEND
         AEND
.*
         AIF   ('&GIVING_FILE' NE '')
               ZC_FILE_FIND &GIVING_FILE
               AIF   (&FILE_IX EQ 0)
                     MNOTE 8,'SORT GIVING FILE NOT FOUND - &GIVING_FILE'
                     MEXIT
               AEND
               :&GIVING_IX SETA &FILE_IX
               :&GIVING_REC SETC '&FILE_RECORD(&FILE_IX)'
         AEND
.*
.* FOR INPUT/OUTPUT PROCEDURE, USE SD RECORD FOR LRECL
.*
         AIF   ('&INPUT_PROC' NE '' AND &LRECL EQ 0)
               AIF ('&SD_REC' NE '')
                   ZC_SYM_FIND &SD_REC
                   AIF (&SYM_IX GT 0)
                       :&LRECL SETA &SYM_LEN(&SYM_IX)
                   AEND
               AEND
         AEND
.*
         AIF   (&LRECL EQ 0)
               MNOTE 8,'SORT CANNOT DETERMINE RECORD LENGTH'
               MEXIT
         AEND
.*
.* GET UNIQUE LABEL
.*
         :&SORT_LAB SETA &SORT_LAB+1
.*
.* GENERATE SORT CODE - ZSORT ISORT (SVC X'A1')
.* Multi-key: LRECL(4),MEM(4),per key:OFF(4),LEN(4),TYP(2),ORD(2)
.*
         CNOP  0,4
         LA    0,1                    ISORT FUNCTION CODE
         :&JUMP_LEN SETA 8+(&KEY_CNT*12)
         BAS   1,*+4+&JUMP_LEN        SKIP OVER PARM LIST
         DC    A(&LRECL)              RECORD LENGTH
         DC    A(0)                   MEMORY (0=USE ALL AVAILABLE)
         :&I SETA 1
         AWHILE (&I LE &KEY_CNT)
         DC    A(&KEY_OFF(&I))        KEY &I OFFSET
         DC    A(&KEY_LEN(&I))        KEY &I LENGTH
               AIF (&I LT &KEY_CNT)
                   AIF ('&KEY_ORD(&I)' EQ 'A')
         DC    X'0003',AL2(1)         TYPE=CH(3), ASCENDING
                   AELSE
         DC    X'0003',AL2(0)         TYPE=CH(3), DESCENDING
                   AEND
               AELSE
                   AIF ('&KEY_ORD(&I)' EQ 'A')
         DC    X'8003',AL2(1)         VL+TYPE=CH(3), ASCENDING
                   AELSE
         DC    X'8003',AL2(0)         VL+TYPE=CH(3), DESCENDING
                   AEND
               AEND
               :&I SETA &I+1
         AEND
         SVC   X'A1'                  ZSORT
.*
.*********************************************************************
.* INPUT PHASE - USING file or INPUT PROCEDURE
.*********************************************************************
         AIF   ('&INPUT_PROC' NE '')
.*
.* INPUT PROCEDURE - Call user section (uses RELEASE to put records)
.*
         PERFORM &INPUT_PROC
.*
         AELSE
.*
.* USING FILE - Read and put records to sort
.*
         LARL  ZC_R0,ZC_SORT_EOF&SORT_LAB
         ST    ZC_R0,&USING_FILE+DCBEODAD-IHADCB
         :&FILE_IX SETA &USING_IX
         GEN_OPEN INPUT
.*
ZC_SORT_RD&SORT_LAB DS 0H
         LAY   ZC_R2,&USING_FILE
         LAY   ZC_R3,&USING_REC
         GET   (ZC_R2),(ZC_R3)
         LAY   ZC_R1,&USING_REC
         LA    0,2                    PUT FUNCTION CODE
         SVC   X'A1'                  ZSORT PUT
         J     ZC_SORT_RD&SORT_LAB
.*
ZC_SORT_EOF&SORT_LAB DS 0H
         :&FILE_IX SETA &USING_IX
         GEN_CLOSE
.*
         AEND
.*
.*********************************************************************
.* OUTPUT PHASE - GIVING file or OUTPUT PROCEDURE
.*********************************************************************
         AIF   ('&OUTPUT_PROC' NE '')
.*
.* OUTPUT PROCEDURE - Call user section (uses RETURN to get records)
.*
         PERFORM &OUTPUT_PROC
.*
         AELSE
.*
.* GIVING FILE - Get sorted records and write
.*
         :&FILE_IX SETA &GIVING_IX
         GEN_OPEN OUTPUT
.*
ZC_SORT_GT&SORT_LAB DS 0H
         LAY   ZC_R1,&GIVING_REC
         LA    0,3                    GET FUNCTION CODE
         SVC   X'A1'                  ZSORT GET
         CHI   ZC_R15,4
         JE    ZC_SORT_DN&SORT_LAB
         LAY   ZC_R2,&GIVING_FILE
         LAY   ZC_R3,&GIVING_REC
         PUT   (ZC_R2),(ZC_R3)
         J     ZC_SORT_GT&SORT_LAB
.*
ZC_SORT_DN&SORT_LAB DS 0H
         :&FILE_IX SETA &GIVING_IX
         GEN_CLOSE
.*
         AEND
.*
         MEXIT
.*
.* CALC_KEY_OFF - Calculate key offset within record
.*
         AENTRY CALC_KEY_OFF
         :&KEY_LOC SETA &SYM_LOC(&SYM_IX)
         :&PAR_IX SETA &SYM_QIX(&SYM_IX)
         AWHILE (&PAR_IX GT 0)
               AIF (&SYM_LVL(&PAR_IX) EQ 1)
                   :&KEY_LOC SETA &KEY_LOC-&SYM_LOC(&PAR_IX)
                   :&PAR_IX SETA 0
               AEND
               AIF (&PAR_IX GT 0)
                   :&PAR_IX SETA &SYM_QIX(&PAR_IX)
               AEND
         AEND
         AEND
         MEND