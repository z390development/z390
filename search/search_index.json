{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"z390 - Mainframe Assembler and Emulator toolkit Develop, test, and deploy mainframe assembler and COBOL programs on your PC IBM\u00ae HLASM compatible macro assembler Common z/OS\u00ae and z/VSE\u00ae compatible macros Structured programming macros compatible with IBM HLASM Toolkit IBM Enterprise COBOL compatible compiler QSAM/VSAM compatible file processing TN3270 compatible data streams CICS\u00ae compatible transaction processor GPLv2 licensed Ideal for a number of use cases: Learning IBM mainframe assembler programming without access to a mainframe. Develop your mainframe application using modern tooling. Get started IBM, CICS, z/OS and z/VSE are trademarks of IBM Corp., registered in the U.S. and other countries. The use of IBM Trademarks complies with the Fair use guidelines for use and reference of IBM trademarks.","title":"Home"},{"location":"#z390-mainframe-assembler-and-emulator-toolkit","text":"Develop, test, and deploy mainframe assembler and COBOL programs on your PC IBM\u00ae HLASM compatible macro assembler Common z/OS\u00ae and z/VSE\u00ae compatible macros Structured programming macros compatible with IBM HLASM Toolkit IBM Enterprise COBOL compatible compiler QSAM/VSAM compatible file processing TN3270 compatible data streams CICS\u00ae compatible transaction processor GPLv2 licensed Ideal for a number of use cases: Learning IBM mainframe assembler programming without access to a mainframe. Develop your mainframe application using modern tooling. Get started IBM, CICS, z/OS and z/VSE are trademarks of IBM Corp., registered in the U.S. and other countries. The use of IBM Trademarks complies with the Fair use guidelines for use and reference of IBM trademarks.","title":"z390 - Mainframe Assembler and Emulator toolkit"},{"location":"contributing/contribute_code/","text":"Contributing to z390 The following document will provide details on how to contribute to the z390 project. For how to contribute to the documentation, see contributing to documentation Setup and build Install Java SDK Make sure you have a Java SDK available to compile the application. The project has moved to the Apache Adoptium Java SDK (previously AdoptOpenJDK) for distribution builds. z390 requires Java 1.8 or greater. You can check if this is available by running the following command: shell> javac -version javac 1.8.0_312` # you should receive a message like this Install git The z390 source code is maintained in a git repository. To install git on your system, go to https://git-scm.com/downloads to download the appropriate version for your system. You can find a quick reference for some frequently used git commands the bottom of this document. Clone the code Start with a clone of the main repository. shell> git clone https://github.com/z390development/z390.git shell> cd z390 Once you are ready to submit changes, you will need a fork of the z390 repository. See https://docs.github.com/en/get-started/quickstart/fork-a-repo for more details. Build the code Windows bat> BUILD.BAT MacOS/Unix bash> ./build.sh If the job successfully runs, it means you are ready to start development. This build procedure invokes the full regression testing script. Build and regression testing both can take quite some time. Luckily, you do not need to do this very often. Rebuild the JAR You can just recompile the JAR without running the full build job by running the bldjar script. Windows bat> bat\\BLDJAR.BAT MacOS/Unix bash> bash/bldjar Test the jar gradle info: https://docs.gradle.org/current/userguide/userguide.html in z390, to access and use the gradle commands, you first have to make the z390test subdirectory your current or working directory. The test scripts are in subdirectory z390test\\src\\test\\groovy\\org\\z390\\test Quick reference with some gradle commands Action Command get a list of gradlew command options gradlew --help force a test run gradlew test --rerun run a specific test/testset gradlew test --tests 'pattern' run all zCobol tests gradlew test --tests '*cbl*' Proposing new functionality Enhancements are welcome, but be aware that you are stepping into an existing and well established project. Before you spend time on an enhancement, we strongly suggest that you first discuss your proposal with the core team and get their buy-in before progressing. The best place to have these discussions is on the z390 developer Google group . Once you get approval from the group, you can work on your change via the standard GitHub pull request model. Submitting changes Changes can be submitted to the project by creating a pull request on the z390 project repository . Useful technical details The following section is to provide some technical background for new developers. Project structure The following directories are the core directories for the z390 project Directory Description src Java source for z390 JAR bat Windows bat scripts for running z390 tools bash *nix bash shell scripts for running z390 tools demo Demo assembler programs tests Tests for z/Arch instructions zopcheck Comprehensive instruction check mac Primary maclib folder for z390 doc+doc_overrides z390 Markdown documentation .github Scripts and config for GitHub build actions The following directories provide additional features using the z390 toolkit. Directory Description zcobol zCOBOL support cics zCICS source, tests and demos structuredmacros Alternative Structured Programming Macros from Daniel H. Snyder sort Sort utility zpar Generate program execution traces The following directories provide tests and demos for various features available in z390. Directory Description assist ASSIST instruction support barcode bsam BSAM sequential file support guam Graphic User Access method support linklib ??? mfacc Mainframe assembler coding contest mvs IBM MVS 3.8j sys1.maclib macros perl (Deprecated) Scipts to run Win BAT files on *nix. Use bash qsam QSAM sequential file support rt Various regression tests for z390 soa Service Orientated Architecture (SOA) and TCP/IP support vsam1 VSAM file support (version 1) vsam2 VSAM file support (version 2) vse VSE OS support Compatibility macros z390 includes a number of macros that are interface compatible with those provided by mainframe operating systems. The internal operation of the macros is different from a real mainframe. For example, the SVC instructions used by z390 are not the same as SVC calls used by z/OS. This means, if you want to write programs that will work on a real mainframe then you need to use the supplied macros to perform the OS based actions. You cannot write programs that use SVC commands as they are not the same. Structured macro extensions z390 extends the standard HLASM syntax with additional keywords that allow you to write structured macro code. See Structured Macro Extensions for more details. This makes writing macros easier but structured macros are NOT compatible with HLASM. Structured macro extensions are used extensively in the codebase which means moving between the mainframe and z390 has some challenges. The project is looking at how to make this transition easier as it understands z390 users come here because they want to write and run HLASM programs and macros. License By contributing to the z390 project, you agree to assign all copyright to z390 Assembler LLC. This allows the project to operate and change without the consultation of all copyright holders. This has not presented itself as an issue to date but could be an issue in the future. If you don't agree to this condition, you are free to fork the project and create your own version under the GNU 2 license conditions. The following preamble should be applied to all programs z390 - Mainframe assembler emulator and run-time engine Copyright (C) 2021 z390 Assembler LLC This file is part of z390. z390 is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. z390 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, see <https://www.gnu.org/licenses/>. ASM macro template MACRO .********************************************************************** .* z390 - Mainframe assembler emulator and run-time engine .* Copyright (C) 2021 z390 Assembler LLC .* .* This file is part of z390. .* .* z390 is free software; you can redistribute it and/or modify .* it under the terms of the GNU General Public License as published by .* the Free Software Foundation; either version 2 of the License, or .* (at your option) any later version. .* z390 is distributed in the hope that it will be useful, .* but WITHOUT ANY WARRANTY; without even the implied warranty of .* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the .* GNU General Public License for more details. .* .* You should have received a copy of the GNU General Public License .* along with this program; if not, see https://www.gnu.org/licenses. .********************************************************************** .* dd/mm/yy change details .* that go over a line .* 04/19/08 RPI 833 add SETC quotes for HLASM compatibility .********************************************************************** .* Macro documentation goes here .********************************************************************** Quick reference with some git commands git info: https://git-scm.com git documentation:https://git-scm.com/doc Action Command get list of available commands git help get syntax details for a git command git help <command> create local clone of git repo git clone <url\\> <subdir> review status of current branch git status get list of all defined branches git branch -v --all prepare commit git add . commit a set of changes git commit -m\"descriptive comments\" push changes to your own fork git push graphical display of branches git log --graph --oneline --decorate --all -- > when viewing the bracnches displayed <Enter> to scroll 1 line, <PgDn> to scroll a page, q to quit go 'back in time' to a specific commit git branch -f <new_branch> [<start-point>] git switch <new_branch>","title":"Contributing to z390"},{"location":"contributing/contribute_code/#contributing-to-z390","text":"The following document will provide details on how to contribute to the z390 project. For how to contribute to the documentation, see contributing to documentation","title":"Contributing to z390"},{"location":"contributing/contribute_code/#setup-and-build","text":"","title":"Setup and build"},{"location":"contributing/contribute_code/#install-java-sdk","text":"Make sure you have a Java SDK available to compile the application. The project has moved to the Apache Adoptium Java SDK (previously AdoptOpenJDK) for distribution builds. z390 requires Java 1.8 or greater. You can check if this is available by running the following command: shell> javac -version javac 1.8.0_312` # you should receive a message like this","title":"Install Java SDK"},{"location":"contributing/contribute_code/#install-git","text":"The z390 source code is maintained in a git repository. To install git on your system, go to https://git-scm.com/downloads to download the appropriate version for your system. You can find a quick reference for some frequently used git commands the bottom of this document.","title":"Install git"},{"location":"contributing/contribute_code/#clone-the-code","text":"Start with a clone of the main repository. shell> git clone https://github.com/z390development/z390.git shell> cd z390 Once you are ready to submit changes, you will need a fork of the z390 repository. See https://docs.github.com/en/get-started/quickstart/fork-a-repo for more details.","title":"Clone the code"},{"location":"contributing/contribute_code/#build-the-code","text":"Windows bat> BUILD.BAT MacOS/Unix bash> ./build.sh If the job successfully runs, it means you are ready to start development. This build procedure invokes the full regression testing script. Build and regression testing both can take quite some time. Luckily, you do not need to do this very often.","title":"Build the code"},{"location":"contributing/contribute_code/#rebuild-the-jar","text":"You can just recompile the JAR without running the full build job by running the bldjar script. Windows bat> bat\\BLDJAR.BAT MacOS/Unix bash> bash/bldjar","title":"Rebuild the JAR"},{"location":"contributing/contribute_code/#test-the-jar","text":"gradle info: https://docs.gradle.org/current/userguide/userguide.html in z390, to access and use the gradle commands, you first have to make the z390test subdirectory your current or working directory. The test scripts are in subdirectory z390test\\src\\test\\groovy\\org\\z390\\test","title":"Test the jar"},{"location":"contributing/contribute_code/#quick-reference-with-some-gradle-commands","text":"Action Command get a list of gradlew command options gradlew --help force a test run gradlew test --rerun run a specific test/testset gradlew test --tests 'pattern' run all zCobol tests gradlew test --tests '*cbl*'","title":"Quick reference with some gradle commands"},{"location":"contributing/contribute_code/#proposing-new-functionality","text":"Enhancements are welcome, but be aware that you are stepping into an existing and well established project. Before you spend time on an enhancement, we strongly suggest that you first discuss your proposal with the core team and get their buy-in before progressing. The best place to have these discussions is on the z390 developer Google group . Once you get approval from the group, you can work on your change via the standard GitHub pull request model.","title":"Proposing new functionality"},{"location":"contributing/contribute_code/#submitting-changes","text":"Changes can be submitted to the project by creating a pull request on the z390 project repository .","title":"Submitting changes"},{"location":"contributing/contribute_code/#useful-technical-details","text":"The following section is to provide some technical background for new developers.","title":"Useful technical details"},{"location":"contributing/contribute_code/#project-structure","text":"The following directories are the core directories for the z390 project Directory Description src Java source for z390 JAR bat Windows bat scripts for running z390 tools bash *nix bash shell scripts for running z390 tools demo Demo assembler programs tests Tests for z/Arch instructions zopcheck Comprehensive instruction check mac Primary maclib folder for z390 doc+doc_overrides z390 Markdown documentation .github Scripts and config for GitHub build actions The following directories provide additional features using the z390 toolkit. Directory Description zcobol zCOBOL support cics zCICS source, tests and demos structuredmacros Alternative Structured Programming Macros from Daniel H. Snyder sort Sort utility zpar Generate program execution traces The following directories provide tests and demos for various features available in z390. Directory Description assist ASSIST instruction support barcode bsam BSAM sequential file support guam Graphic User Access method support linklib ??? mfacc Mainframe assembler coding contest mvs IBM MVS 3.8j sys1.maclib macros perl (Deprecated) Scipts to run Win BAT files on *nix. Use bash qsam QSAM sequential file support rt Various regression tests for z390 soa Service Orientated Architecture (SOA) and TCP/IP support vsam1 VSAM file support (version 1) vsam2 VSAM file support (version 2) vse VSE OS support","title":"Project structure"},{"location":"contributing/contribute_code/#compatibility-macros","text":"z390 includes a number of macros that are interface compatible with those provided by mainframe operating systems. The internal operation of the macros is different from a real mainframe. For example, the SVC instructions used by z390 are not the same as SVC calls used by z/OS. This means, if you want to write programs that will work on a real mainframe then you need to use the supplied macros to perform the OS based actions. You cannot write programs that use SVC commands as they are not the same.","title":"Compatibility macros"},{"location":"contributing/contribute_code/#structured-macro-extensions","text":"z390 extends the standard HLASM syntax with additional keywords that allow you to write structured macro code. See Structured Macro Extensions for more details. This makes writing macros easier but structured macros are NOT compatible with HLASM. Structured macro extensions are used extensively in the codebase which means moving between the mainframe and z390 has some challenges. The project is looking at how to make this transition easier as it understands z390 users come here because they want to write and run HLASM programs and macros.","title":"Structured macro extensions"},{"location":"contributing/contribute_code/#license","text":"By contributing to the z390 project, you agree to assign all copyright to z390 Assembler LLC. This allows the project to operate and change without the consultation of all copyright holders. This has not presented itself as an issue to date but could be an issue in the future. If you don't agree to this condition, you are free to fork the project and create your own version under the GNU 2 license conditions. The following preamble should be applied to all programs z390 - Mainframe assembler emulator and run-time engine Copyright (C) 2021 z390 Assembler LLC This file is part of z390. z390 is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. z390 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, see <https://www.gnu.org/licenses/>.","title":"License"},{"location":"contributing/contribute_docs/","text":"Contributing to z390 Documentation The following document will provide details on how to contribute to the z390 documentation. Submitting changes Changes to documentation can be made by submitting a pull request to the z390 project repository. Content All documentation will be held in the doc folder and be in markdown format. Markdown files have a .md extension. Markdown uses simple text files with specific syntax for formatting. See the markdown guide for syntax. You can also use functions provided by the admonition extension in mkdocs. See the doco for admonition Structure All the documentation is contained in the doc folder. The following is the sections of the documentation and their purpose and content: Section name Folder name Purpose and content Home index.md Landing page for the documentation and project. Designed for people unfamiliar with the project. Getting started getting_started.md Provides details for a new user of z390 to install and start using z390. User guide user_guide Provides details about how to use the z390 toolset Reference reference Provides details relating to the z390 supplied macros. Contributing contributing Provides details of the z390 project from a project contributor/developer perspective. Conventions Product names Product names should always use a small z: z390 zCOBOL - Always capitalize COBOL zVSAM - Always capitalize VSAM zCICS - Always capitalize CICS zSORT - Always capitalize SORT Program names and scripts When specifying tool and script names, always use lower case to be compatible with case sensitive environments like linux. mz390 az390 asmlg Units of measurement For bytes: When specifying a quantity of 1024 bytes, use {quantity}K. Bytes is assumed. Capital K is deliberate. the word bytes can be added if the context does not make it clear that bytes are implied. {quantity}K bytes. For seconds: ms = millisecond \u00b5s = microseconds (in markdown \u00b5 = &micro; ) ns = nanoseconds Code HLASM code should be enclosed in a code block as follows: ``` hlasm LABEL MVC X(10),Y ``` Terminology The following provides guidelines on the use of specific terminology. If not here, you should use the general principle of following conventions set in IBM mainframe manuals. term usage word OK. Alternate is fullword with no space. halfword OK. No space should be used. save area In any text, ensure space is included. The only exception is in code savearea without space is preferred ASCII Always in capitals EBCDIC Always in capitals PSW Program status word - Always capitals Generate the web site The z390 docs use the Python utility mkdocs to convert the markdown to web pages that are published to GitHub pages. The following instructions will allow you to preview the published version on GitHub prior to committing your changes. Installation You will need Python version 3.4 or above installed. MacOS/Unix python -m venv docenv source docenv/bin/activate pip install -r doc/requirements.txt Windows Note You will require the GTK runtime installed on your system. See https://github.com/tschoonj/GTK-for-Windows-Runtime-Environment-Installer/releases python -m venv docenv docenv\\Scripts\\activate pip install -r doc\\requirements.txt Run the live web server When updating the markdown content, you can run a live web server which checks for changes in the markdown files and updates the web content as you edit. You can view the web site preview using a web browser pointed at the following address: http://localhost:8000 MacOS/Unix source docenv/bin/activate mkdocs serve Windows docenv\\Scripts\\activate mkdocs serve Generate the PDF The distribution will include a PDF with the documentation. You can use the following commands to generate the PDF. Ubuntu Linux apt update && apt install -y libsdl-pango-dev source docenv/bin/activate ENABLE_PDF_EXPORT = 1 mkdocs build MacOS brew install pango source docenv/bin/activate ENABLE_PDF_EXPORT = 1 mkdocs build Windows docenv\\Scripts\\activate set ENABLE_PDF_EXPORT=1 mkdocs build The generated PDF document will be placed in the file /site/pdf/z390.pdf","title":"Contributing to z390 Documentation"},{"location":"contributing/contribute_docs/#contributing-to-z390-documentation","text":"The following document will provide details on how to contribute to the z390 documentation.","title":"Contributing to z390 Documentation"},{"location":"contributing/contribute_docs/#submitting-changes","text":"Changes to documentation can be made by submitting a pull request to the z390 project repository.","title":"Submitting changes"},{"location":"contributing/contribute_docs/#content","text":"All documentation will be held in the doc folder and be in markdown format. Markdown files have a .md extension. Markdown uses simple text files with specific syntax for formatting. See the markdown guide for syntax. You can also use functions provided by the admonition extension in mkdocs. See the doco for admonition","title":"Content"},{"location":"contributing/contribute_docs/#structure","text":"All the documentation is contained in the doc folder. The following is the sections of the documentation and their purpose and content: Section name Folder name Purpose and content Home index.md Landing page for the documentation and project. Designed for people unfamiliar with the project. Getting started getting_started.md Provides details for a new user of z390 to install and start using z390. User guide user_guide Provides details about how to use the z390 toolset Reference reference Provides details relating to the z390 supplied macros. Contributing contributing Provides details of the z390 project from a project contributor/developer perspective.","title":"Structure"},{"location":"contributing/contribute_docs/#conventions","text":"","title":"Conventions"},{"location":"contributing/contribute_docs/#product-names","text":"Product names should always use a small z: z390 zCOBOL - Always capitalize COBOL zVSAM - Always capitalize VSAM zCICS - Always capitalize CICS zSORT - Always capitalize SORT","title":"Product names"},{"location":"contributing/contribute_docs/#program-names-and-scripts","text":"When specifying tool and script names, always use lower case to be compatible with case sensitive environments like linux. mz390 az390 asmlg","title":"Program names and scripts"},{"location":"contributing/contribute_docs/#units-of-measurement","text":"For bytes: When specifying a quantity of 1024 bytes, use {quantity}K. Bytes is assumed. Capital K is deliberate. the word bytes can be added if the context does not make it clear that bytes are implied. {quantity}K bytes. For seconds: ms = millisecond \u00b5s = microseconds (in markdown \u00b5 = &micro; ) ns = nanoseconds","title":"Units of measurement"},{"location":"contributing/contribute_docs/#code","text":"HLASM code should be enclosed in a code block as follows: ``` hlasm LABEL MVC X(10),Y ```","title":"Code"},{"location":"contributing/contribute_docs/#terminology","text":"The following provides guidelines on the use of specific terminology. If not here, you should use the general principle of following conventions set in IBM mainframe manuals. term usage word OK. Alternate is fullword with no space. halfword OK. No space should be used. save area In any text, ensure space is included. The only exception is in code savearea without space is preferred ASCII Always in capitals EBCDIC Always in capitals PSW Program status word - Always capitals","title":"Terminology"},{"location":"contributing/contribute_docs/#generate-the-web-site","text":"The z390 docs use the Python utility mkdocs to convert the markdown to web pages that are published to GitHub pages. The following instructions will allow you to preview the published version on GitHub prior to committing your changes.","title":"Generate the web site"},{"location":"contributing/contribute_docs/#installation","text":"You will need Python version 3.4 or above installed. MacOS/Unix python -m venv docenv source docenv/bin/activate pip install -r doc/requirements.txt Windows Note You will require the GTK runtime installed on your system. See https://github.com/tschoonj/GTK-for-Windows-Runtime-Environment-Installer/releases python -m venv docenv docenv\\Scripts\\activate pip install -r doc\\requirements.txt","title":"Installation"},{"location":"contributing/contribute_docs/#run-the-live-web-server","text":"When updating the markdown content, you can run a live web server which checks for changes in the markdown files and updates the web content as you edit. You can view the web site preview using a web browser pointed at the following address: http://localhost:8000 MacOS/Unix source docenv/bin/activate mkdocs serve Windows docenv\\Scripts\\activate mkdocs serve","title":"Run the live web server"},{"location":"contributing/contribute_docs/#generate-the-pdf","text":"The distribution will include a PDF with the documentation. You can use the following commands to generate the PDF. Ubuntu Linux apt update && apt install -y libsdl-pango-dev source docenv/bin/activate ENABLE_PDF_EXPORT = 1 mkdocs build MacOS brew install pango source docenv/bin/activate ENABLE_PDF_EXPORT = 1 mkdocs build Windows docenv\\Scripts\\activate set ENABLE_PDF_EXPORT=1 mkdocs build The generated PDF document will be placed in the file /site/pdf/z390.pdf","title":"Generate the PDF"},{"location":"contributing/contributing_zcobol/","text":"Contributing to zCOBOL Have you been bored lately? If you know COBOL and assembler or Java, or C there is a job on the zCOBOL project waiting for you. The pay is poor ($0) but the self actualization rewards can be very satisfying. And there is always the possibility of future paying jobs helping companies use zCOBOL. If you are an assembler or COBOL developer who would like to contribute to the zCOBOL open source project, join the zCOBOL group and indicate your specific interests. All users are welcome and are encouraged to submit bug reports and requests for priority on future open source zCOBOL and z390 development. With the recent addition of z390 structured conditional macro assembler extensions, the development of zCOBOL became feasible and has evolved rapidly. As the article in the z/System Journal titled, \"Easy COBOL Modernization for SOA\" by L. H. Couch and Charles F. Townsend, November 2008 indicates there is a growing demand for tools such as zCOBOL to help seamlessly bridge legacy and modern IT solutions. Current jobs available include writing COBOL verb macros for currently unsupported verbs including SORT, MERGE. Optimizing the code generation macros to produce more efficient code and optional code based on zCOBOL options such as TRUNC, R64, etc. In addition major effort is still required to covert the HLASM code generation macros to generated java, C, or MASM. For COBOL programmers there is the constant need to extend the zCOBOL regression tests (zCOBOL_Demos_and_Regression_Tests.htm) written in zCOBOL which verify that zCOBOL statements produce the expected results. And finally there is a need to develop documentation on the zCOBOL project as it evolves. NIST ANSI 1985 Test Suite Results v1.5.00a came from RPI 1001 for conditional 88 support, RPI 1002 SET and index support, and RPI 1012 miscellaneous syntax error corrections. Once some of the remaining critical support items such as COMPUTE are completed, these numbers should continue to significantly improve. The plan is to achieve 100% within the next few releases of zCOBOL and then provide optional regression test download for the NIST test suite for zCOBOL. These statistics were extracted from: Description V1.5.00 V1.5.00a Notes NIST programs with parsing errors 140 43 RPI 1012 corrections to zc390 parser NIST Programs Compiled 319 416 RPI 1012 corrections to zc390 parser Total minutes 26 44 33% increase in number of programs compiled RC=0 No errors 11 12 most programs are still missing one or more items RC=8 MNOTE support warning 19 151 Warning for unsupported items pending implementation RC=16 At least 1 error message 249 160 Error messages from mz390 or az390 macro assembler","title":"Contributing to zCOBOL"},{"location":"contributing/contributing_zcobol/#contributing-to-zcobol","text":"Have you been bored lately? If you know COBOL and assembler or Java, or C there is a job on the zCOBOL project waiting for you. The pay is poor ($0) but the self actualization rewards can be very satisfying. And there is always the possibility of future paying jobs helping companies use zCOBOL. If you are an assembler or COBOL developer who would like to contribute to the zCOBOL open source project, join the zCOBOL group and indicate your specific interests. All users are welcome and are encouraged to submit bug reports and requests for priority on future open source zCOBOL and z390 development. With the recent addition of z390 structured conditional macro assembler extensions, the development of zCOBOL became feasible and has evolved rapidly. As the article in the z/System Journal titled, \"Easy COBOL Modernization for SOA\" by L. H. Couch and Charles F. Townsend, November 2008 indicates there is a growing demand for tools such as zCOBOL to help seamlessly bridge legacy and modern IT solutions. Current jobs available include writing COBOL verb macros for currently unsupported verbs including SORT, MERGE. Optimizing the code generation macros to produce more efficient code and optional code based on zCOBOL options such as TRUNC, R64, etc. In addition major effort is still required to covert the HLASM code generation macros to generated java, C, or MASM. For COBOL programmers there is the constant need to extend the zCOBOL regression tests (zCOBOL_Demos_and_Regression_Tests.htm) written in zCOBOL which verify that zCOBOL statements produce the expected results. And finally there is a need to develop documentation on the zCOBOL project as it evolves.","title":"Contributing to zCOBOL"},{"location":"contributing/contributing_zcobol/#nist-ansi-1985-test-suite-results","text":"v1.5.00a came from RPI 1001 for conditional 88 support, RPI 1002 SET and index support, and RPI 1012 miscellaneous syntax error corrections. Once some of the remaining critical support items such as COMPUTE are completed, these numbers should continue to significantly improve. The plan is to achieve 100% within the next few releases of zCOBOL and then provide optional regression test download for the NIST test suite for zCOBOL. These statistics were extracted from: Description V1.5.00 V1.5.00a Notes NIST programs with parsing errors 140 43 RPI 1012 corrections to zc390 parser NIST Programs Compiled 319 416 RPI 1012 corrections to zc390 parser Total minutes 26 44 33% increase in number of programs compiled RC=0 No errors 11 12 most programs are still missing one or more items RC=8 MNOTE support warning 19 151 Warning for unsupported items pending implementation RC=16 At least 1 error message 249 160 Error messages from mz390 or az390 macro assembler","title":"NIST ANSI 1985 Test Suite Results"},{"location":"getting_started/install/","text":"Installation Follow this guide to setup z390 on your system. Install the prerequisites You will need a Java\u2122 runtime environment version 8 or above installed on your system. Get Eclipse Adoptium Java Get the latest z390 distribution Download the latest version of the z390 distribution. Download z390 Install z390 Installation is as simple as unzipping the z390 distribution file to your local file system. You can add the distribution script folder to your system path so that you can use the z390 tools directly on the command line. Windows If z390 is installed in c:\\z390 , then add c:\\z390\\bat to your system path. MacOS/Unix If z390 is installed in /usr/local/z390 , then add /usr/local/z390/bash to your system path. Continue with Quick Starts","title":"Installation"},{"location":"getting_started/install/#installation","text":"Follow this guide to setup z390 on your system.","title":"Installation"},{"location":"getting_started/install/#install-the-prerequisites","text":"You will need a Java\u2122 runtime environment version 8 or above installed on your system. Get Eclipse Adoptium Java","title":"Install the prerequisites"},{"location":"getting_started/install/#get-the-latest-z390-distribution","text":"Download the latest version of the z390 distribution. Download z390","title":"Get the latest z390 distribution"},{"location":"getting_started/install/#install-z390","text":"Installation is as simple as unzipping the z390 distribution file to your local file system. You can add the distribution script folder to your system path so that you can use the z390 tools directly on the command line. Windows If z390 is installed in c:\\z390 , then add c:\\z390\\bat to your system path. MacOS/Unix If z390 is installed in /usr/local/z390 , then add /usr/local/z390/bash to your system path. Continue with Quick Starts","title":"Install z390"},{"location":"getting_started/learning/","text":"Learning resources https://bixoft.nl/english/selftest.htm https://idcp.marist.edu/assembler-resources https://www.ibm.com/docs/en/zos-basic-skills?topic=zos-assembler-language https://www.ibm.com/support/pages/high-level-assembler-hlasm-and-toolkit-feature-share-presentations http://www.billqualls.com/assembler/index.html https://punctiliousprogrammer.com/ https://www.ibmmainframeforum.com/assembler/topic12399.html https://ibmmainframes.com/about2744.html http://planetmvs.com/hlasm/s390faq.html https://share.confex.com/share/115/webprogram/Handout/Session7445/hla2mtf.pdf","title":"Learning resources"},{"location":"getting_started/learning/#learning-resources","text":"https://bixoft.nl/english/selftest.htm https://idcp.marist.edu/assembler-resources https://www.ibm.com/docs/en/zos-basic-skills?topic=zos-assembler-language https://www.ibm.com/support/pages/high-level-assembler-hlasm-and-toolkit-feature-share-presentations http://www.billqualls.com/assembler/index.html https://punctiliousprogrammer.com/ https://www.ibmmainframeforum.com/assembler/topic12399.html https://ibmmainframes.com/about2744.html http://planetmvs.com/hlasm/s390faq.html https://share.confex.com/share/115/webprogram/Handout/Session7445/hla2mtf.pdf","title":"Learning resources"},{"location":"getting_started/macro_index/","text":"Mainframe OS compatible macros z390 provides some mainframe OS compatible macros (MVS, Z/OS, VSE) for use in your programs. SVC calls are not compatible. Z390 implements its own OS services which are different to the mainframe. If your program needs to access OS services, then your programs should use the provided OS based macros. macro description ABEND abort program with specified code ACB VSAM access control block ACBD 1 VSAM ACB DSECT BLDL Search for one or more 390 load modules in memory or in SYS390 load library directories. CALL Call subroutine using standard linkage CHECK Check completion of READ/WRITE CLOSE Close DCB or ACB file CMDPROC Control command processing tasks CVTD DSECT of limited CVT fields supported DCB Data control block for file (supports 31 bit DCBLRECLF field as extension to DCBLRECL. See SUPERZAP utility for example of how to read or write up to 2 GB file with 1 I/O operation.) DCBD DSECT of limited DCB fields DCBE Define EODAD and SYNAD for DCB DECBD 1 DSECT of limited DECB fields DEFINE 1 Define VSAM Cluster Definition Table DEQ 1 Release a resource lock set by ENQ DELETE Freemain 390 load module if use count 0 ENQ 1 request lock on a resource ERASE VSAM delete record ESPIE set program interruption handler ESTAE set program abend handler FREEMAIN release memory area GENCB generate VSAM ACB or RPL GET read record from QSAM or VSAM file GETENV get value of environment variable GETMAIN allocate memory area IHAEPIE 1 DSECT for ESPIE exits IHASDWA 1 DSECT for SDWA ESTAE exits m LINK load and execute 390 load module LOAD load 390 load module MODCB modify ACB or RPL control block field OPEN open DCB or ACB file POINT position to relative record or RBA in file POST post ECB as completed PUT write record to QSAM or VSAM file READ read block from file at current position RETURN restore saved registers and return RPL VSAM request parameter list RPLD 1 VSAM RPL DSECT SAVE save specified registers SETRP 1 set register options for ESTAE exits SHOWCB move ACB or RPL field to user area SNAP dump selected area of memory and/or dump file information from TIOT/DCB\u2019s, general and floating point registers, program information from CDE, and memory allocation totals STIMER wait specified interval of time STORAGE obtain or release main storage TESTCB test current value of ACB or RPL field TGET read from GUI TN3270 interface TIME get time and date in requested format TTIMER test and/or cancel STIMER event TPUT write to GUI TN3270 display VCDTD 1 VSAM Catalog Definition Table DSECT WAIT wait for 1 or more ECB\u2019s to be posted WRITE write block to file at current position WTO write text message to operator console WTOR write to operator with reply XCTL transfer control and delete prior pgm XLATE translate area to/from EBCDIC/ASCII Requires documentation. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Mainframe OS compatible macros"},{"location":"getting_started/macro_index/#mainframe-os-compatible-macros","text":"z390 provides some mainframe OS compatible macros (MVS, Z/OS, VSE) for use in your programs. SVC calls are not compatible. Z390 implements its own OS services which are different to the mainframe. If your program needs to access OS services, then your programs should use the provided OS based macros. macro description ABEND abort program with specified code ACB VSAM access control block ACBD 1 VSAM ACB DSECT BLDL Search for one or more 390 load modules in memory or in SYS390 load library directories. CALL Call subroutine using standard linkage CHECK Check completion of READ/WRITE CLOSE Close DCB or ACB file CMDPROC Control command processing tasks CVTD DSECT of limited CVT fields supported DCB Data control block for file (supports 31 bit DCBLRECLF field as extension to DCBLRECL. See SUPERZAP utility for example of how to read or write up to 2 GB file with 1 I/O operation.) DCBD DSECT of limited DCB fields DCBE Define EODAD and SYNAD for DCB DECBD 1 DSECT of limited DECB fields DEFINE 1 Define VSAM Cluster Definition Table DEQ 1 Release a resource lock set by ENQ DELETE Freemain 390 load module if use count 0 ENQ 1 request lock on a resource ERASE VSAM delete record ESPIE set program interruption handler ESTAE set program abend handler FREEMAIN release memory area GENCB generate VSAM ACB or RPL GET read record from QSAM or VSAM file GETENV get value of environment variable GETMAIN allocate memory area IHAEPIE 1 DSECT for ESPIE exits IHASDWA 1 DSECT for SDWA ESTAE exits m LINK load and execute 390 load module LOAD load 390 load module MODCB modify ACB or RPL control block field OPEN open DCB or ACB file POINT position to relative record or RBA in file POST post ECB as completed PUT write record to QSAM or VSAM file READ read block from file at current position RETURN restore saved registers and return RPL VSAM request parameter list RPLD 1 VSAM RPL DSECT SAVE save specified registers SETRP 1 set register options for ESTAE exits SHOWCB move ACB or RPL field to user area SNAP dump selected area of memory and/or dump file information from TIOT/DCB\u2019s, general and floating point registers, program information from CDE, and memory allocation totals STIMER wait specified interval of time STORAGE obtain or release main storage TESTCB test current value of ACB or RPL field TGET read from GUI TN3270 interface TIME get time and date in requested format TTIMER test and/or cancel STIMER event TPUT write to GUI TN3270 display VCDTD 1 VSAM Catalog Definition Table DSECT WAIT wait for 1 or more ECB\u2019s to be posted WRITE write block to file at current position WTO write text message to operator console WTOR write to operator with reply XCTL transfer control and delete prior pgm XLATE translate area to/from EBCDIC/ASCII Requires documentation. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Mainframe OS compatible macros"},{"location":"getting_started/quickstart/","text":"Quick starts Hello z390 The following is a simple Hello world application written in mainframe assembler language. HELLO CSECT BASR 15,0 USING *,15 WTO 'Hello z390!' BR 14 END Add the contents of this to a file named 'HELLO.MLC'. Now run the following z390 command to assemble, link and run the program. Windows Assumes z390 has been installed in c:\\z390 . Substitute for your local install location. c:\\z390\\bat\\asmlg HELLO.MLC SYSMAC(c:\\z390\\mac+) MacOS/Unix Assumes z390 has been installed in /usr/local/z390 . Substitute for your local install location. /usr/local/z390/bash/asmlg HELLO.MLC \"SYSMAC(/usr/local/z390/mac+)\" If you have successfully run the sample program, the output to the console will be similar to the following: 09:37:54 HELLO MZ390 START USING z390 V1.7.03 ON J2SE 14.0.2 06/05/21 09:37:54 HELLO MZ390 ENDED RC= 0 SEC= 0 MEM(MB)= 47 IO=200 09:37:55 HELLO LZ390 START USING z390 V1.7.03 ON J2SE 14.0.2 06/05/21 09:37:55 HELLO LZ390 ENDED RC= 0 SEC= 0 MEM(MB)= 8 IO=30 09:37:55 HELLO EZ390 START USING z390 V1.7.03 ON J2SE 14.0.2 06/05/21 Hello z390! 09:37:55 HELLO EZ390 ENDED RC= 0 SEC= 0 MEM(MB)= 16 IO=21 INS=5 Hello zCOBOL The following is a simple Hello world application written in COBOL. IDENTIFICATION DIVISION . PROGRAM-ID . HELLO . PROCEDURE DIVISION . DISPLAY \"HELLO ZCOBOL\" . STOP RUN . Add the contents of this to a file named 'HELLO.CBL'. Now run the following z390 command to assemble, link and run the COBOL program. Windows Assumes z390 has been installed in c:\\z390 . Substitute for your local install location. c:\\z390\\bat\\cblclg HELLO MacOS/Unix Assumes z390 has been installed in /usr/local/z390 . Substitute for your local install location. /usr/local/z390/bash/cblclg HELLO If you have successfully run the sample COBOL program, the output to the console will be similar to the following: 21:13:17 hello ZC390 START USING z390 V1.7.07 ON J2SE 16.0.1 06/27/21 21:13:17 hello ZC390 ENDED RC= 0 SEC= 0 MEM(MB)= 10 IO=2 21:13:18 hello MZ390 START USING z390 V1.7.07 ON J2SE 16.0.1 06/27/21 21:13:19 hello MZ390 ENDED RC= 0 SEC= 1 MEM(MB)=109 IO=19951 21:13:19 hello LZ390 START USING z390 V1.7.07 ON J2SE 16.0.1 06/27/21 21:13:19 hello LZ390 ENDED RC= 0 SEC= 0 MEM(MB)= 11 IO=72 21:13:19 hello EZ390 START USING z390 V1.7.07 ON J2SE 16.0.1 06/27/21 HELLO ZCOBOL 21:13:19 hello EZ390 ENDED RC= 0 SEC= 0 MEM(MB)= 17 IO=185 INS=41 Learn more in the zCOBOL user guide Hello zCICS TODO","title":"Quick starts"},{"location":"getting_started/quickstart/#quick-starts","text":"","title":"Quick starts"},{"location":"getting_started/quickstart/#hello-z390","text":"The following is a simple Hello world application written in mainframe assembler language. HELLO CSECT BASR 15,0 USING *,15 WTO 'Hello z390!' BR 14 END Add the contents of this to a file named 'HELLO.MLC'. Now run the following z390 command to assemble, link and run the program. Windows Assumes z390 has been installed in c:\\z390 . Substitute for your local install location. c:\\z390\\bat\\asmlg HELLO.MLC SYSMAC(c:\\z390\\mac+) MacOS/Unix Assumes z390 has been installed in /usr/local/z390 . Substitute for your local install location. /usr/local/z390/bash/asmlg HELLO.MLC \"SYSMAC(/usr/local/z390/mac+)\" If you have successfully run the sample program, the output to the console will be similar to the following: 09:37:54 HELLO MZ390 START USING z390 V1.7.03 ON J2SE 14.0.2 06/05/21 09:37:54 HELLO MZ390 ENDED RC= 0 SEC= 0 MEM(MB)= 47 IO=200 09:37:55 HELLO LZ390 START USING z390 V1.7.03 ON J2SE 14.0.2 06/05/21 09:37:55 HELLO LZ390 ENDED RC= 0 SEC= 0 MEM(MB)= 8 IO=30 09:37:55 HELLO EZ390 START USING z390 V1.7.03 ON J2SE 14.0.2 06/05/21 Hello z390! 09:37:55 HELLO EZ390 ENDED RC= 0 SEC= 0 MEM(MB)= 16 IO=21 INS=5","title":"Hello z390"},{"location":"getting_started/quickstart/#hello-zcobol","text":"The following is a simple Hello world application written in COBOL. IDENTIFICATION DIVISION . PROGRAM-ID . HELLO . PROCEDURE DIVISION . DISPLAY \"HELLO ZCOBOL\" . STOP RUN . Add the contents of this to a file named 'HELLO.CBL'. Now run the following z390 command to assemble, link and run the COBOL program. Windows Assumes z390 has been installed in c:\\z390 . Substitute for your local install location. c:\\z390\\bat\\cblclg HELLO MacOS/Unix Assumes z390 has been installed in /usr/local/z390 . Substitute for your local install location. /usr/local/z390/bash/cblclg HELLO If you have successfully run the sample COBOL program, the output to the console will be similar to the following: 21:13:17 hello ZC390 START USING z390 V1.7.07 ON J2SE 16.0.1 06/27/21 21:13:17 hello ZC390 ENDED RC= 0 SEC= 0 MEM(MB)= 10 IO=2 21:13:18 hello MZ390 START USING z390 V1.7.07 ON J2SE 16.0.1 06/27/21 21:13:19 hello MZ390 ENDED RC= 0 SEC= 1 MEM(MB)=109 IO=19951 21:13:19 hello LZ390 START USING z390 V1.7.07 ON J2SE 16.0.1 06/27/21 21:13:19 hello LZ390 ENDED RC= 0 SEC= 0 MEM(MB)= 11 IO=72 21:13:19 hello EZ390 START USING z390 V1.7.07 ON J2SE 16.0.1 06/27/21 HELLO ZCOBOL 21:13:19 hello EZ390 ENDED RC= 0 SEC= 0 MEM(MB)= 17 IO=185 INS=41 Learn more in the zCOBOL user guide","title":"Hello zCOBOL"},{"location":"getting_started/quickstart/#hello-zcics","text":"TODO","title":"Hello zCICS"},{"location":"getting_started/zCOBOL_Overview/","text":"Macro Syntax Error File : getting_started/zCOBOL_Overview.md Line 92 in Markdown file: Missing end of comment tag ## zCOBOL Compiler Commands {#Commands}","title":"Macro Syntax Error"},{"location":"getting_started/zCOBOL_Overview/#macro-syntax-error","text":"File : getting_started/zCOBOL_Overview.md Line 92 in Markdown file: Missing end of comment tag ## zCOBOL Compiler Commands {#Commands}","title":"Macro Syntax Error"},{"location":"reference/assist/","text":"ASSIST support ASSIST stands for Assembler System for Student Instruction and Systems Teaching. It is an IBM System/370-compatible assembler and interpreter developed in the early 1970s at Penn State University by Graham Campbell and John Mashey. 1 The ASSIST support in z390 allows you to use the I/O and debugging instructions as described in the ASSIST User Manual. See ASSIST User Manual PART II. INPUT/OUTPUT AND DEBUGGING INSTRUCTIONS for more details. Using ASSIST instructions with z390 ASSIST option The ASSIST option must be provided to use the ASSIST instructions. See z390 Options for details. assist command script z390 assist command script can be used to assemble, link, and execute ASSIST programs. assist {programname} The assist command script enables ASSIST option and defines the following files for input and output: XREAD={programname}.XRD XPRNT={programname}.XPR XPNCH={programname}.XPH XGET={programname}.XGT XPUT={programname}.XPT File processing Files are optional and will be opened on first access and closed at end of execution or end of file. All files are ASCII with automatic conversion from or to EBCDIC. ASCII file records have trailing spaces removed and end with carriage return x'0d' and line feed x'0a'. Input fields are padded with EBCDIC spaces x'40'. Non ASCII output bytes are converted to periods. Default ASSIST option behavior Using the ASSIST option enables z390 options NOLOADHIGH and NOINIT for compatibility with the original ASSIST assembler and simplifies relative address calculations. This has the following impacts: Programs are loaded at X'8000' instead of high end of memory. Registers are initialized to X'F4'. Memory above the PSA is initialized to X'F5'. Uninitialized areas of 390 load modules are initialized to X'F6'. You can use the options LOADHIGH and INIT to override this behavior. See z390 Options for more information. Error handling A trace table is used to display the last 10 instructions prior to abnormal termination of a program when the TRACE option is off. The PSW displayed at abnormal termination includes ILC, CC, MASK, and AMODE. ASSIST instructions XDECI - Convert decimal to binary Format: RX X'53rxbddd' r1.s2 Start scan for next decimal number at s2 skipping leading blanks. Convert decimal number to binary in r1 until non decimal character found or more than nine digits. When ten (or more) digits are found, the instruction does not do the conversion and condition code 3 is set. Set register 1 to address of the last non decimal character found. Set condition code 0 if number converted successfully else set condition code 3. XDECO - Convert binary to decimal Format: RX X'52rxbddd' r1,s2 Convert binary 32 bit r1 value to right justified 12 character decimal field at s2. XDUMP - dump registers and/or storage Format: RXSS X'E06xbdddbddd' s1(x1),s2 If no operands are specified, dump registers and the default storage area. If no XLIMD instruction has reset default storage dump area, dump all storage. if s1(x1) address of storage area and s2 length of area are specified just dump that area. XGET - read record from ASCII file Format: RXSS X'E0Axbdddbddd' s1(x1),s2 Read record from ASCII file DDNAME=XGET into area s1(x1) with length of s2. Requires that the environment variable XGET be set and point to desired input file. If a file operation is successful the condition code is set to 0. At end of file, condition code 1 is set. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. If any other error occurs such as missing length, condition code 2 is set. XHEXI - convert hex to binary Format: RX X'61' r1,s2 Convert hex to binary (cc3 if no hex, update field addr). XHEXO - convert binary to hex Format: RX X'62' r1,s2 Convert value in r1 to printable hex (8 bytes), storing value at s2. XLIMD - Set default dump storage area Format: RXSS X'E08xrbdddbddd' s1(x1),s2 Set default XDUMP storage area address and length. XPNCH - Write to punch Format: RXSS X'E04xbdddbddd' s1(x1),s2 Write to DDNAME=XPNCH with length s2. Requires that the environment variable XPNCH be set and point to desired output file. Does not set condition code. If a file error occurs the program aborts with abend code S013. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. XPRNT - Write to print Format: RXSS X'E02xbdddbddd' s1(x1),s2 Write to DDNAME=XPRNT with length s2. Requires that the environment variable XPRNT be set and point to desired output file. Does not set condition code. If a file error occurs, the program aborts with abend code S013. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. XPUT - Write to XPUT Format: RXSS X'E0Cxbdddbddd' s1(x1),s2 Write to DDNAME=XPUT for length s2. Requires that the environment variable XPUT be set and point to desired output file. If a file operation is successful the condition code is set to 0. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. If any other error occurs such as missing length, condition code 2 is set. XREAD - Read from XREAD Format: RXSS X'E00xbdddbddd' s1(x1),s2 Read record from DDNAME=XREAD for length s2. Requires that the environment variable XREAD be set and point to desired input file. If a file operation is successful the condition code is set to 0. At end of file, condition code 1 is set. If a file error occurs, the program aborts with abend code S013. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. See ASSIST (computing) at Wikipedia for more details. \u21a9","title":"ASSIST support"},{"location":"reference/assist/#assist-support","text":"ASSIST stands for Assembler System for Student Instruction and Systems Teaching. It is an IBM System/370-compatible assembler and interpreter developed in the early 1970s at Penn State University by Graham Campbell and John Mashey. 1 The ASSIST support in z390 allows you to use the I/O and debugging instructions as described in the ASSIST User Manual. See ASSIST User Manual PART II. INPUT/OUTPUT AND DEBUGGING INSTRUCTIONS for more details.","title":"ASSIST support"},{"location":"reference/assist/#using-assist-instructions-with-z390","text":"","title":"Using ASSIST instructions with z390"},{"location":"reference/assist/#assist-option","text":"The ASSIST option must be provided to use the ASSIST instructions. See z390 Options for details.","title":"ASSIST option"},{"location":"reference/assist/#assist-command-script","text":"z390 assist command script can be used to assemble, link, and execute ASSIST programs. assist {programname} The assist command script enables ASSIST option and defines the following files for input and output: XREAD={programname}.XRD XPRNT={programname}.XPR XPNCH={programname}.XPH XGET={programname}.XGT XPUT={programname}.XPT","title":"assist command script"},{"location":"reference/assist/#file-processing","text":"Files are optional and will be opened on first access and closed at end of execution or end of file. All files are ASCII with automatic conversion from or to EBCDIC. ASCII file records have trailing spaces removed and end with carriage return x'0d' and line feed x'0a'. Input fields are padded with EBCDIC spaces x'40'. Non ASCII output bytes are converted to periods.","title":"File processing"},{"location":"reference/assist/#default-assist-option-behavior","text":"Using the ASSIST option enables z390 options NOLOADHIGH and NOINIT for compatibility with the original ASSIST assembler and simplifies relative address calculations. This has the following impacts: Programs are loaded at X'8000' instead of high end of memory. Registers are initialized to X'F4'. Memory above the PSA is initialized to X'F5'. Uninitialized areas of 390 load modules are initialized to X'F6'. You can use the options LOADHIGH and INIT to override this behavior. See z390 Options for more information.","title":"Default ASSIST option behavior"},{"location":"reference/assist/#error-handling","text":"A trace table is used to display the last 10 instructions prior to abnormal termination of a program when the TRACE option is off. The PSW displayed at abnormal termination includes ILC, CC, MASK, and AMODE.","title":"Error handling"},{"location":"reference/assist/#assist-instructions","text":"","title":"ASSIST instructions"},{"location":"reference/assist/#xdeci-convert-decimal-to-binary","text":"Format: RX X'53rxbddd' r1.s2 Start scan for next decimal number at s2 skipping leading blanks. Convert decimal number to binary in r1 until non decimal character found or more than nine digits. When ten (or more) digits are found, the instruction does not do the conversion and condition code 3 is set. Set register 1 to address of the last non decimal character found. Set condition code 0 if number converted successfully else set condition code 3.","title":"XDECI - Convert decimal to binary"},{"location":"reference/assist/#xdeco-convert-binary-to-decimal","text":"Format: RX X'52rxbddd' r1,s2 Convert binary 32 bit r1 value to right justified 12 character decimal field at s2.","title":"XDECO - Convert binary to decimal"},{"location":"reference/assist/#xdump-dump-registers-andor-storage","text":"Format: RXSS X'E06xbdddbddd' s1(x1),s2 If no operands are specified, dump registers and the default storage area. If no XLIMD instruction has reset default storage dump area, dump all storage. if s1(x1) address of storage area and s2 length of area are specified just dump that area.","title":"XDUMP - dump registers and/or storage"},{"location":"reference/assist/#xget-read-record-from-ascii-file","text":"Format: RXSS X'E0Axbdddbddd' s1(x1),s2 Read record from ASCII file DDNAME=XGET into area s1(x1) with length of s2. Requires that the environment variable XGET be set and point to desired input file. If a file operation is successful the condition code is set to 0. At end of file, condition code 1 is set. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. If any other error occurs such as missing length, condition code 2 is set.","title":"XGET - read record from ASCII file"},{"location":"reference/assist/#xhexi-convert-hex-to-binary","text":"Format: RX X'61' r1,s2 Convert hex to binary (cc3 if no hex, update field addr).","title":"XHEXI - convert hex to binary"},{"location":"reference/assist/#xhexo-convert-binary-to-hex","text":"Format: RX X'62' r1,s2 Convert value in r1 to printable hex (8 bytes), storing value at s2.","title":"XHEXO - convert binary to hex"},{"location":"reference/assist/#xlimd-set-default-dump-storage-area","text":"Format: RXSS X'E08xrbdddbddd' s1(x1),s2 Set default XDUMP storage area address and length.","title":"XLIMD - Set default dump storage area"},{"location":"reference/assist/#xpnch-write-to-punch","text":"Format: RXSS X'E04xbdddbddd' s1(x1),s2 Write to DDNAME=XPNCH with length s2. Requires that the environment variable XPNCH be set and point to desired output file. Does not set condition code. If a file error occurs the program aborts with abend code S013. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed.","title":"XPNCH - Write to punch"},{"location":"reference/assist/#xprnt-write-to-print","text":"Format: RXSS X'E02xbdddbddd' s1(x1),s2 Write to DDNAME=XPRNT with length s2. Requires that the environment variable XPRNT be set and point to desired output file. Does not set condition code. If a file error occurs, the program aborts with abend code S013. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed.","title":"XPRNT - Write to print"},{"location":"reference/assist/#xput-write-to-xput","text":"Format: RXSS X'E0Cxbdddbddd' s1(x1),s2 Write to DDNAME=XPUT for length s2. Requires that the environment variable XPUT be set and point to desired output file. If a file operation is successful the condition code is set to 0. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. If any other error occurs such as missing length, condition code 2 is set.","title":"XPUT - Write to XPUT"},{"location":"reference/assist/#xread-read-from-xread","text":"Format: RXSS X'E00xbdddbddd' s1(x1),s2 Read record from DDNAME=XREAD for length s2. Requires that the environment variable XREAD be set and point to desired input file. If a file operation is successful the condition code is set to 0. At end of file, condition code 1 is set. If a file error occurs, the program aborts with abend code S013. If a file open error occurs, program terminates with S013 abend with error message showing the file specification which failed. See ASSIST (computing) at Wikipedia for more details. \u21a9","title":"XREAD - Read from XREAD"},{"location":"reference/file_services/","text":"Non-VSAM File Services z390 supports sequential and random access to files through the provision of SVC functions and assembler macros. The macros described here seek to emulate those provided by IBM\u00ae as part of their operating system macro services where it makes sense in the context of z390 runtime environments. z/OS: DFSMS Macro Instructions for Data Sets - Part 2 Non-VSAM macro instructions. VSAM support The macros GET, PUT and POINT can be used for VSAM access with the parameter RPL=rpladdress. VSAM usage is not documented here. Please refer to VSAM file services . Quick starts To access a file, a data control block (DCB) must be defined. Programs that use the File I/O macros must include a DSECT for the DCB. The DSECT is generated by the DCBD macro, so a typical program structure would be: DCBD EQUREGS END Include the DSECT for the DECB, which is generated by the DECBD macro, if you are using READ or WRITE. Read a file The following code demonstrates the read of a file TEACHERS with a layout as described as IREC . The environment variable TEACHER should be set to point to the input file. OPEN (TEACHERS,INPUT) Opens the file GET TEACHERS Reads record CLOSE TEACHERS Closes the file ...... TEACHERS DCB LRECL=27,RECFM=FT,MACRF=R,EODAD=ATEND, X DDNAME=TEACHER,RECORD=IREC IREC DS 0CL27 Teacher record ...... Write to a file The following code demonstrates the write to a file REPORT with a layout as described as OREC . The environment variable REPORT should be set to point to the output file. OPEN (REPORT,OUTPUT) Opens the file PUT REPORT,OREC Write OREC to record CLOSE REPORT Closes the file ...... REPORT DCB LRECL=60,RECFM=FT,MACRF=W, X DDNAME=REPORT OREC DS 0CL60 Report output structure ...... Macro reference SVC functions The following is a list of the z390 SVC services that support the above macros. DEC HEX Service 19 13 OPEN 19 13 OPEN (VSE) 20 14 CLOSE 20 14 CLOSE (VSE) 151 97 GET 152 98 PUT 153 99 READ 154 9A WRITE 155 9B CHECK 156 9C POINT DCB - Data Control Block Used to create the Data Control Block Some of the parameters may be set before and/or after OPEN. The individual descriptions indicate this. label DCB DSORG=PS, X EODAD=0, X RECFM=FB, X DDNAME=, X MACRF=GM, X SYNAD=0, X BLKSIZE=0, X LRECL=0, X DCBE=, X RECORD=0, X DSNAME=0 EXLST is currently unsupported. 'label' is the file identifier, the DCB name, which is used in all the file I/O macros. Term Meaning Description BDW Block Descriptor Word Only used for RECFM=VB files. A 4-byte field of the form 'blocklength',H'0' The blocklength includes the length of the BDW. RDW Record Descriptor Word Used for all variable files. A 4-byte field of the form H'recordlength',H'0' The recordlength includes the length of the RDW. The program must set this field correctly for output, and expect it on input. CRLF Carriage Return, Line Feed A term for the hex string X'0D0A' (ASCII) or X'0D25' (EBCDIC). Now commonly used to terminate a text record. DDNAME and DSNAME - DD statement/Dataset name DDNAME DSECT=DCBDDNAM Type=CL8 Default=CL8'label' DSNAME DSECT=DCBDSNAM Type=A No default Can these be set in the DCB prior to OPEN: Yes Can these be set in the DCB after OPEN : No Only one of these parameters may be set in the DCB. If both parameters are set in the program prior to open, the DSNAME will take precedence. When DDNAME is specified, an environment variable will point to the path and file that is to be opened. Within a program the GETENV macro can be used to extract the environment variable. See GETENV macro for full details. MYDCB DCB DDNAME=MYDATA, ... Run using the following commands: Windows SET MYDATA=c:\\path\\file CALL c:\\path_to_z390\\bat\\ez390 c:\\path\\program parms MacOS/Unix export MYDATA = /path/file /path_to_z390/bash/ez390 /path/program parms Info For both Windows and *nix, the invocation of ez390 should be preceded by a path to the z390 script folder. bat for Windows bash for *nix DSNAME is a label defined in the program which has the file spec. The file spec must terminate with X'00' or be defined as a double-quoted string within a standard C-type constant. MYDCB DCB DSNAME=MYDATA, ... ...... MYDATA DC C'drive:\\path\\file',X'00' MYDATA DC C'\"drive:\\path\\file\"' MACRF - Macro type DSECT=DCBMACRF, Coded Default=GM Can this be set in the DCB prior to OPEN: Yes, but not recommended Can this be set in the DCB after OPEN : No Option Effect MACRF=GM Get Move, use the GET macro to read a record Use for standard (QSAM) file read MACRF=PM Put Move, use the PUT macro to write a record Use for standard (QSAM) file write MACRF=R Read Mode. Use READ/CHECK to read a record. Use POINT for positioning. MACRF=W Write Mode. Use WRITE/CHECK to write or update a record. Use POINT for positioning. MACRF=RW Update Mode. Use READ/WRITE/CHECK to read, write or update a record. Use POINT for positioning. DSORG - Dataset organization DSORG DSECT=DCBDSORG Coded Default=PS Can this be set in the DCB prior to OPEN: Yes, but not recommended Can this be set in the DCB after OPEN : No DSORG=PS Physical Sequential The only option at present, can be omitted. RECFM - Record format RECFM DSECT=DCBRECFM Coded Default=FB Can this be set in the DCB prior to OPEN: Yes, but not recommended Can this be set in the DCB after OPEN : No RECFM=F Fixed Translation: None Input: Records are read LRECL at a time. Output: Records are written LRECL at a time. RECFM=FB Fixed Blocked Translation: None Input: MACRF=GM Records are read LRECL at a time out of BLKSIZE. MACRF=R or RW The whole block is read. Output: MACRF=PM Records are written LRECL at a time into a block of size BLKSIZE. CLOSE may write a short block. MACRF=W or RW The whole block is written. RECFM=V Variable Translation: None Input: Each record is prefixed by the RDW. The receiving area must be big enough for the largest RDW+record. If the RDW indicates a record size larger than LRECL, abend S013 will occur. Output: Each record must be prefixed by the RDW. RECFM=VB Variable Blocked Translation: None Input: MACRF=GM Each record is prefixed by the RDW. The receiving area must be big enough for the largest RDW+record. If the RDW indicates a record size larger than LRECL, abend S013 will occur. MACRF=R or RW The whole block is read, prefixed by the BDW. The receiving area must be big enough for the largest BDW+block. If the BDW indicates a block size larger than BLKSIZE, abend S013 will occur. Output: MACRF=PM Each record must be prefixed by the RDW. CLOSE will write the last block. Each block written will have the BDW automatically inserted at the start. MACRF=W or RW Each block must be prefixed by the BDW. RECFM=FT Fixed ASCII text Translation: ASCII mode: None Non-ASCII mode input ASCII chars are translated to EBCDIC after being read. Non-ASCII mode output EBCDIC chars are translated to ASCII before being written, this is an internal function and does not affect the record in storage. Non-EBCDIC chars may be translated to X'00'. Input: The file is assumed to be in conventional ASCII format, with each record ending in the operating system specific end-of-line (EOL) character(s). EOL is never read as part of the record. If the record is shorter than LRECL, then trailing blanks are inserted. EODAD is invoked when all bytes have been read. Output: EOL is inserted at the end of each record after trailing blanks are stripped. RECFM=VT Variable ASCII text Translation: ASCII mode None Non-ASCII mode input ASCII chars are translated to EBCDIC after being read. Non-ASCII mode output EBCDIC chars are translated to ASCII before being written. This is an internal function and does not affect the record in storage. Non-EBCDIC chars may be translated to X'00'. Input: The file is assumed to be in conventional ASCII format, with each record ending in the operating system specific end-of-line (EOL) character(s). EOL is never read as part of the record. Each record is prefixed with the RDW. EODAD is invoked when all bytes have been read. The receiving area must be big enough for the largest RDW+record. If the RDW indicates a record size larger than LRECL, abend S013 will occur. Output: Each record must be prefixed with the RDW. EOL is inserted at the end of each record after trailing blanks are stripped. Warning The RDW is not written. RECORD - Record address RECORD DSECT=DCBREC Type=A Default=0 (undefined) Default I/O area which can be overridden on the GET/PUT/READ/WRITE macros. Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes If omitted, then the I/O area must be specified on the GET/PUT/READ/WRITE macros. LRECL - Record length LRECL DSECT=DCBLRECLF Type=F Default=0 Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes Maximum value is 2G-1. For RECFM=F or FB, sets the record size. For all other RECFM, sets the maximum record size. For RECFM=F, LRECL=0 is valid, provided that BLKSIZE is set. For RECFM=FB, LRECL must be a multiple of BLKSIZE. For variable records, include 4 for the RDW. The field DCBLRECL (Type=H) is retained for compatibility. BLKSIZE - Block size BLKSIZE DSECT=DCBBLKSIF Type=F Default=0 Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes Maximum value is 2G-1. LRECL and BLKSIZE cannot both be zero. For RECFM=F sets the record size if LRECL=0. For RECFM=FB, sets the block size and LRECL must be a multiple of BLKSIZE. For RECFM=VB, BLKSIZE must be at least 4 greater than LRECL. For all other RECFM, sets the maximum block size. The field DCBBLKSI (Type=H) is retained for compatibility. DCBE - Data control block extension DCBE DSECT=DCBDCBE Type=A Default=0 (undefined) The DCBE is a control block defined by the DCBE macro. Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes When defined, the addresses of the end-of-file (EODAD) and the I/O error routine (SYNAD) may be defined. When set, these addresses override the DCB EODAD and SYNAD parameters. The DSECT IHADCBE maps the DCBE control block. EODAD - End of file routine EODAD DSECT=DCBEODAD Type=Address Default=0 (no routine defined) The address of the end-of-file routine. Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes This may be overridden if DCBE is coded. If a further GET is done after end-of-file, then the program is terminated. SYNAD - Error analysis routine SYNAD DSECT=DCBSYNAD Type=Address Default=0 (no routine defined) The address of the uncorrectable I/O error routine. Can this be set in the DCB prior to OPEN: Yes Can this be set in the DCB after OPEN : Yes This may be overridden if DCBE is coded. DCBE - Data Control Block Extended label DCBE EODAD=0,SYNAD=0,BLKSIZE=0 EODAD - End of data routine address Address of End of data routine. Default=0 = no routine When set, will override address provided in the DCB EODAD parameter. SYNAD - IO error routine address Address of IO Error routine. Default=0 - no routine When set, will override address provided in the DCB SYNAD parameter. BLKSIZE - Large block interface Default is zero meaning Large Block support is not enabled. When set, the large block interface (LBI) is enabled. This causes BDW and RDW fields in variable length files to use an alternative format: LLLL where high bit is on and the remaining 31 bits are length. DTFSD (VSE) - Data control block VSE only DTFSD maps to the standard DCB as follows: label DTFSD BLKSIZE=n, X EOFADDR= label DCB DSORG=PS, X EODAD=, maps from EOFADDR X RECFM=F, X DDNAME=, label if it exists, otherwise blank X MACRF=RW, X SYNAD=0, X BLKSIZE=, maps from BLKSIZE X LRECL=, maps from BLKSIZE X DCBE=0, X RECORD=0, X DSNAME=0 DTFPR (VSE) - Data control block VSE only DTFPR maps to the standard DCB as follows: label DTFPR BLKSIZE=n label DCB DSORG=PS, X EODAD=, maps from EOFADDR X RECFM=F, X DDNAME=, label if it exists, otherwise blank X MACRF=RW, X SYNAD=0, X BLKSIZE=, maps from BLKSIZE X LRECL=, maps from BLKSIZE X DCBE=0, X RECORD=0, X DSNAME=0 OPEN - Open file Open one or more files. Usage Open one file for INPUT OPEN dcbname Open one file for non-INPUT OPEN (dcbname,type) Open multiple files OPEN (dcbname1,type,dcbname2,type) The same, using register notation OPEN ((reg),type) OPEN ((reg1),type,(reg2),type) Registers R0 = Flags R1 = DCB addresses Abends S013 OPEN failed and no SYNAD exit provided OPEN (VSE) - Open file Open one or more files for UPDATE. Usage OPEN dtfname OPEN (dtfname1,dtfname2,...) Registers R0 = Flags R1 = DTF addresses Abends S013 OPEN failed and no SYNAD exit provided CLOSE - Close file Close one or more files. Usage Close one file CLOSE dcbname Close multiple files CLOSE (dcbname1,,dcbname2) The same, using register notation CLOSE ((reg1),,(reg2)) Registers R1 = DCB addresses Abends S013 CLOSE failed and no SYNAD exit provided CLOSE (VSE) - Close file Close one or more files. Usage CLOSE (dtfname1,dtfname2,...) Registers R1 = DTF addresses Abends S013 CLOSE failed and no SYNAD exit provided GET - Read sequential record Read a sequential record Usage Read a record into an I/O area supplied on DCB RECORD=ioarea GET dcbname Read a record into an I/O area GET dcbname,ioarea The same, using register notation GET (reg) GET (reg1),(reg2) Registers R0 = ioarea R1 = DCB address PUT - Write a sequential record Write a sequential record Usage Write a record from an I/O area supplied on the DCB RECORD=ioarea PUT dcbname Write a record from an I/O area PUT dcbname,ioarea The same, using register notation PUT (reg) PUT (reg1),(reg2) Registers R0 = ioarea R1 = DCB address READ - Read block from file Read a block from a file. If EODAD or SYNAD result from the READ, they will only be processed by the CHECK macro. If the decbname parameter is specified in register notation, no internal DECB is generated. It is the programmer's responsibility to create and address the 16-byte DECB. Usage Read a block using an internal DECB, into an I/O area supplied on the DCB RECORD=ioarea READ decbname,,dcbname Read a block using an internal DECB into an I/O area. The I/O area must be at least as large as DCB BLKSIZE READ decbname,,dcbname,ioarea The same, using register notation READ (reg1),,(reg2) READ (reg1),,(reg2),(reg3) Registers R0 = work register R1 = DECB address R15= DCB address WRITE - Write block to file Write a block to a file. If SYNAD results from the WRITE, it will only be processed by the CHECK macro. If the decbname parameter is specified in register notation, no internal DECB is generated. It is the programmer's responsibility to create and address the 16-byte DECB. Usage Write a block using an internal DECB, from an I/O area supplied on the DCB RECORD=ioarea WRITE decbname,,dcbname Write a block using an internal DECB from an I/O area WRITE decbname,,dcbname,ioarea The same, using register notation WRITE (reg1),,(reg2) WRITE (reg1),,(reg2),(reg3) Registers R0 = work register R1 = DECB address R15= DCB address CHECK - Process EODAD/SYNAD Process EODAD or SYNAD on READ. Process SYNAD on WRITE. Usage CHECK decbname The same, using register notation CHECK (reg) Registers R1 = DECB address Abends S013 READ/WRITE failed and no SYNAD exit provided POINT - Position file pointer Position pointer for next READ or WRITE When register notation is used for rba or rel, the register points to a field containing the value. rel is a fullword, maximum value 2,147,483,647 (2G - 1). rel is multiplied by BLKSIZE to get the rba. rba is signed 64-bit value. Usage Point to a record using relative record number POINT dcbname,rel Point to a record using relative byte address POINT dcbname,,RBA=rba The same, using register notation POINT (reg1),(reg2) POINT (reg1),,RBA=(reg2) Registers R0 = rel or RBA R1 = DCB address R15= Blocksize Terminology Term Definition dcbname the label on the DCB macro. reg general register, avoid 0, 1, 14 or 15. type INPUT, OUTPUT or UPDATE (default is INPUT). ioarea label of the I/O area for the record to be read/written. decbname internal or external DECB for controlling READ/WRITE. rel relative record number. rba relative byte address.","title":"Non-VSAM File Services"},{"location":"reference/file_services/#non-vsam-file-services","text":"z390 supports sequential and random access to files through the provision of SVC functions and assembler macros. The macros described here seek to emulate those provided by IBM\u00ae as part of their operating system macro services where it makes sense in the context of z390 runtime environments. z/OS: DFSMS Macro Instructions for Data Sets - Part 2 Non-VSAM macro instructions. VSAM support The macros GET, PUT and POINT can be used for VSAM access with the parameter RPL=rpladdress. VSAM usage is not documented here. Please refer to VSAM file services .","title":"Non-VSAM File Services"},{"location":"reference/file_services/#quick-starts","text":"To access a file, a data control block (DCB) must be defined. Programs that use the File I/O macros must include a DSECT for the DCB. The DSECT is generated by the DCBD macro, so a typical program structure would be: DCBD EQUREGS END Include the DSECT for the DECB, which is generated by the DECBD macro, if you are using READ or WRITE.","title":"Quick starts"},{"location":"reference/file_services/#read-a-file","text":"The following code demonstrates the read of a file TEACHERS with a layout as described as IREC . The environment variable TEACHER should be set to point to the input file. OPEN (TEACHERS,INPUT) Opens the file GET TEACHERS Reads record CLOSE TEACHERS Closes the file ...... TEACHERS DCB LRECL=27,RECFM=FT,MACRF=R,EODAD=ATEND, X DDNAME=TEACHER,RECORD=IREC IREC DS 0CL27 Teacher record ......","title":"Read a file"},{"location":"reference/file_services/#write-to-a-file","text":"The following code demonstrates the write to a file REPORT with a layout as described as OREC . The environment variable REPORT should be set to point to the output file. OPEN (REPORT,OUTPUT) Opens the file PUT REPORT,OREC Write OREC to record CLOSE REPORT Closes the file ...... REPORT DCB LRECL=60,RECFM=FT,MACRF=W, X DDNAME=REPORT OREC DS 0CL60 Report output structure ......","title":"Write to a file"},{"location":"reference/file_services/#macro-reference","text":"","title":"Macro reference"},{"location":"reference/file_services/#svc-functions","text":"The following is a list of the z390 SVC services that support the above macros. DEC HEX Service 19 13 OPEN 19 13 OPEN (VSE) 20 14 CLOSE 20 14 CLOSE (VSE) 151 97 GET 152 98 PUT 153 99 READ 154 9A WRITE 155 9B CHECK 156 9C POINT","title":"SVC functions"},{"location":"reference/file_services/#dcb","text":"Used to create the Data Control Block Some of the parameters may be set before and/or after OPEN. The individual descriptions indicate this. label DCB DSORG=PS, X EODAD=0, X RECFM=FB, X DDNAME=, X MACRF=GM, X SYNAD=0, X BLKSIZE=0, X LRECL=0, X DCBE=, X RECORD=0, X DSNAME=0 EXLST is currently unsupported. 'label' is the file identifier, the DCB name, which is used in all the file I/O macros. Term Meaning Description BDW Block Descriptor Word Only used for RECFM=VB files. A 4-byte field of the form 'blocklength',H'0' The blocklength includes the length of the BDW. RDW Record Descriptor Word Used for all variable files. A 4-byte field of the form H'recordlength',H'0' The recordlength includes the length of the RDW. The program must set this field correctly for output, and expect it on input. CRLF Carriage Return, Line Feed A term for the hex string X'0D0A' (ASCII) or X'0D25' (EBCDIC). Now commonly used to terminate a text record.","title":"DCB - Data Control Block"},{"location":"reference/file_services/#dcbe-data-control-block-extended","text":"label DCBE EODAD=0,SYNAD=0,BLKSIZE=0","title":"DCBE - Data Control Block Extended"},{"location":"reference/file_services/#dtfsd","text":"VSE only DTFSD maps to the standard DCB as follows: label DTFSD BLKSIZE=n, X EOFADDR= label DCB DSORG=PS, X EODAD=, maps from EOFADDR X RECFM=F, X DDNAME=, label if it exists, otherwise blank X MACRF=RW, X SYNAD=0, X BLKSIZE=, maps from BLKSIZE X LRECL=, maps from BLKSIZE X DCBE=0, X RECORD=0, X DSNAME=0","title":"DTFSD (VSE) - Data control block"},{"location":"reference/file_services/#dtfpr","text":"VSE only DTFPR maps to the standard DCB as follows: label DTFPR BLKSIZE=n label DCB DSORG=PS, X EODAD=, maps from EOFADDR X RECFM=F, X DDNAME=, label if it exists, otherwise blank X MACRF=RW, X SYNAD=0, X BLKSIZE=, maps from BLKSIZE X LRECL=, maps from BLKSIZE X DCBE=0, X RECORD=0, X DSNAME=0","title":"DTFPR (VSE) - Data control block"},{"location":"reference/file_services/#open","text":"Open one or more files.","title":"OPEN - Open file"},{"location":"reference/file_services/#open-vse","text":"Open one or more files for UPDATE.","title":"OPEN (VSE) - Open file"},{"location":"reference/file_services/#close","text":"Close one or more files.","title":"CLOSE - Close file"},{"location":"reference/file_services/#close-vse","text":"Close one or more files.","title":"CLOSE (VSE) - Close file"},{"location":"reference/file_services/#get","text":"Read a sequential record","title":"GET - Read sequential record"},{"location":"reference/file_services/#put","text":"Write a sequential record","title":"PUT - Write a sequential record"},{"location":"reference/file_services/#read","text":"Read a block from a file. If EODAD or SYNAD result from the READ, they will only be processed by the CHECK macro. If the decbname parameter is specified in register notation, no internal DECB is generated. It is the programmer's responsibility to create and address the 16-byte DECB.","title":"READ - Read block from file"},{"location":"reference/file_services/#write","text":"Write a block to a file. If SYNAD results from the WRITE, it will only be processed by the CHECK macro. If the decbname parameter is specified in register notation, no internal DECB is generated. It is the programmer's responsibility to create and address the 16-byte DECB.","title":"WRITE - Write block to file"},{"location":"reference/file_services/#check","text":"Process EODAD or SYNAD on READ. Process SYNAD on WRITE.","title":"CHECK - Process EODAD/SYNAD"},{"location":"reference/file_services/#point","text":"Position pointer for next READ or WRITE When register notation is used for rba or rel, the register points to a field containing the value. rel is a fullword, maximum value 2,147,483,647 (2G - 1). rel is multiplied by BLKSIZE to get the rba. rba is signed 64-bit value.","title":"POINT - Position file pointer"},{"location":"reference/file_services/#terminology","text":"Term Definition dcbname the label on the DCB macro. reg general register, avoid 0, 1, 14 or 15. type INPUT, OUTPUT or UPDATE (default is INPUT). ioarea label of the I/O area for the record to be read/written. decbname internal or external DECB for controlling READ/WRITE. rel relative record number. rba relative byte address.","title":"Terminology"},{"location":"reference/guam_services/","text":"GUAM services http://www.z390.org/z390_GUAM_GUI_Access_Method_Guide.pdf The z390 GUAM Graphical User Access Method provides support for any assembler program to interface with a user via a GUI window when the GUAM option is specified as an ez390 execution option. Info z390 has the following GUAM GUI interface support and limits: Full support for the MCS console view for WTO and WTOR commands Full support for the TN3270 edit mode form of TGET and TPUT Full support for basic TN3270 data streams including WCC, SBA, SF, IC, RA, EUA, and PT commands. A cursor is supported using blinking underline character at the current cursor position. The arrow, backspace, delete, and tab keys are supported to control the cursor. Entering data into protected field or alpha into numeric field causes beep and status line error message. The 3270 screen display can be resized and the font is automatically adjusted to maximum size that will still allow display of full screen if possible. Limited support for TN3270 extended data streams with SFE and SA commands are supported. Color attributes are supported but highlighting and underlining are not yet supported. Limited support for the GUAM macro graphics commands. (The GUI WINDOW, VIEW, GRAPH command can be used to display the graph view but the graphic commands are targeted for future release. Macro reference WTO Write to operator via GUAM GUI MCS console scrolling log view. label WTO \u2018msg\u2019 See WTO in SVC services WTOR Write to operator with reply via GUAM GUI MCS console scrolling log view. label WTOR \u2018msg\u2019,reply,reply_length,ecb See WTOR in SVC services WAIT Wait for WTOR reply from GUI interface and post ecb. label WAIT ECB=ecb See WAIT in SVC services TGET Read next line of text from TN3270 interface. The default is EDIT mode and WAIT for input from keyboard. label TGET buffer,buffer_length,EDIT,WAIT read TN3270 data stream from TN3270 screen interface. The TN3270 input stream consists of action code, cursor buffer address, and any modified input fields. label TGET buffer,buffer_len,ASIS,WAIT TPUT Write next line of text to TN3270 24x80 screen view (the default is EDIT mode) label TPUT buffer,buffer_length write TN3270 data stream to TN3270 screen interface. The write buffer must contain escape followed by valid TN3270 extended data stream which may contain EBCDIC encoded data and the following commands: WCC SF SFE SA SBA IC PT label TPUT buffer,buffer_len,FULLSCR TN3270 Macro to generate native TN3270 data streams including SBA addresses using symbolic references for control codes. The following keyboard input keystrokes can be used to generate TN3270 compatible input data codes: key hex alternate keys ENTER 7D PF1 to PF9 F1-F9 PF10 to PF12 7A-7C PF13 to PF21 C1-C9 Ctrl + Alt + F1 to Ctrl + Alt + F9 PF22 to PF24 4A-4C Ctrl + Alt + F10 to Ctrl + Alt + F12 PA1 6C Ctrl + F1 PA2 6E Ctrl + F2 PA3 6B Ctrl + F3 CLEAR 6D Ctrl + C GUAM Macro to perform graphics display functions similar to GDDM. GUAM WINDOW,TITLE,\u2019text\u2019 set window title GUAM WINDOW,LOC,x,y set window location from upper left in pixels GUAM WINDOW,SIZE,width,height set window size in pixels GUAM WINDOW,FONT,size set window character font size (8-30) GUAM WINDOW,VIEW,MCS set scrolling MCS console log view (default) GUAM WINDOW,VIEW,SCREEN,row,col,color set text screen view GUAM WINDOW,VIEW,GRAPH,x,y,color set graphic display view GUAM WINDOW,GETVIEW,view get current view GUAM SCREEN,READ,buffer,buffer_len,WAIT/NOWAIT read text GUAM SCREEN,WRITE,row,col,buffer,buffer_len,color write text GUAM SCREEN,FIELD,row,col,length define field GUAM SCREEN,CURSOR, type set cursor type GUAM SCREEN,CURSOR,row,col set cursor position GUAM GRAPH,POINT,x,y,color draw point GUAM GRAPH,LINE,x1,y1,x2,y2,color draw line GUAM GRAPH,FILL,x1,y1,x2,y2,color fill area GUAM GRAPH,TEXT,x,y,\u2019text\u2019,color draw text GUAM KEYBOARD,mode,char,WAIT/NOWAIT read keyboard GUAM MOUSE,x,y,left,right read mouse position on graph and buttons GUAM SOUND,START,wav_file play wav sound file GUAM SOUND,STOP When the ez390 GUAM option is specified for execution of a z390 assembler program, a GUAM GUI window is opened in default MCS console view displaying all WTO and WTOR messages issued by program in a scrolling window. Whenever TPUT, or TGET macros are executed the GUI window switches to TN3290 screen view display mode. Whenever GUAM macro graphic commands are executed, the GUI window switches to GRAPH display mode. When in SCREEN or GRAPH view, WTO and WTOR commands can continue to be executed and displayed one at a time via the status line with command line replies as required. The user can switch between any of the 3 GUAM GUI views manually via view menu selection. Assembler application programs can set window title, location, size, font, and view mode at any time using the GUAM macros regardless of display view. Multiple user controlled GUAM GUI windows can be opened by executing different assembler programs as separate tasks under control of master program using the z390 CMDPROC macro to launch separate program tasks each of which can invoke a GUAM GUI interface. Demonstrations The following GUI demonstration programs are included in the distribution in the guam/demo folder. DEMOGUI1.MLC \u2013 Issue WTOR, wait for reply via WAIT, display reply via WTO and repeat loop until END is entered. This program can be run in any of the following modes: Windows command line mode \u2013 ASMLG DEMO\\DEMOGUI1 Windows GUI interface \u2013 ASMLG DEMO\\DEMOGUI1 GUI DEMOGUI2.MLC \u2013 Issue WTOR, execute 3 instruction loop until ECB is posted, display reply via WTO along with date, time, instruction loop count and calculated MIP rate for the 3 instruction loop. It is very interesting to note that on a 3 GHZ Pentium 4 system, this demo runs at about 1.1 MIPS using command line mode, and about 2.6 MIPS using the GUI mode. This program can be run in any of the following modes: Windows command line mode \u2013 ASMLG DEMO\\DEMOGUI1 Windows GUI interface \u2013 ASMLG DEMO\\DEMOGUI1 GUI DEMOGUI3.MLC \u2013 issue TPUT and TGET with WAIT option in loop until END is entered. This demo uses default EDIT mode of TPUT and TGET to scroll the 24 lines of TN3270 screen view with wrap around after status line prompt for input each time last line is written. DEMOGUI4.MLC \u2013 issue TN3270 data stream TPUT and TGET with WAIT option in loop until END is entered. This demo writes text to fields at specified screen buffer addresses, reads a field at specified address, displays the input field at another address, and repeats the process waiting for screen input until PF3 or END is entered. DEMOGUI5.MLC \u2013 This demo used GUI graphic commands to draw text and graphics and read keyboard and mouse. (Note this program brings up graphic display view but the graphics commands are not implemented yet. See RPI 137 DEMOGUI6.MLC \u2013 TN3270 application program to support entering name, address, and numeric zip fields, displaying the current values, PF1 help screen, display hex value of any unused AID keys entered, and PF3 for exit. Info There is an EXEC CICS version of this same demo that runs via local or remote GUAM client TN3270 terminal connected to z390 CICS transaction manager. The demo supports PF1 for help and PF3 for exit. It sounds alarm and displays errors on status line. It also displays the hex AID code for any other PF keys entered. DEMOAPL1.MLC \u2013 show use of APL graphics via X\u201908\u2019 insert APL character command and also demo GUAM support of TN3270 color. Reference For technical reference manual see IBM 3270 Data Stream Programmers Reference GA23-0059-07 For tutorial on TN3270 extended data stream programming with examples see http://www.tommysprinkle.com/mvs/P3270/start.htm .","title":"GUAM services"},{"location":"reference/guam_services/#guam-services","text":"http://www.z390.org/z390_GUAM_GUI_Access_Method_Guide.pdf The z390 GUAM Graphical User Access Method provides support for any assembler program to interface with a user via a GUI window when the GUAM option is specified as an ez390 execution option. Info z390 has the following GUAM GUI interface support and limits: Full support for the MCS console view for WTO and WTOR commands Full support for the TN3270 edit mode form of TGET and TPUT Full support for basic TN3270 data streams including WCC, SBA, SF, IC, RA, EUA, and PT commands. A cursor is supported using blinking underline character at the current cursor position. The arrow, backspace, delete, and tab keys are supported to control the cursor. Entering data into protected field or alpha into numeric field causes beep and status line error message. The 3270 screen display can be resized and the font is automatically adjusted to maximum size that will still allow display of full screen if possible. Limited support for TN3270 extended data streams with SFE and SA commands are supported. Color attributes are supported but highlighting and underlining are not yet supported. Limited support for the GUAM macro graphics commands. (The GUI WINDOW, VIEW, GRAPH command can be used to display the graph view but the graphic commands are targeted for future release.","title":"GUAM services"},{"location":"reference/guam_services/#macro-reference","text":"","title":"Macro reference"},{"location":"reference/guam_services/#wto","text":"Write to operator via GUAM GUI MCS console scrolling log view. label WTO \u2018msg\u2019 See WTO in SVC services","title":"WTO"},{"location":"reference/guam_services/#wtor","text":"Write to operator with reply via GUAM GUI MCS console scrolling log view. label WTOR \u2018msg\u2019,reply,reply_length,ecb See WTOR in SVC services","title":"WTOR"},{"location":"reference/guam_services/#wait","text":"Wait for WTOR reply from GUI interface and post ecb. label WAIT ECB=ecb See WAIT in SVC services","title":"WAIT"},{"location":"reference/guam_services/#tget","text":"Read next line of text from TN3270 interface. The default is EDIT mode and WAIT for input from keyboard. label TGET buffer,buffer_length,EDIT,WAIT read TN3270 data stream from TN3270 screen interface. The TN3270 input stream consists of action code, cursor buffer address, and any modified input fields. label TGET buffer,buffer_len,ASIS,WAIT","title":"TGET"},{"location":"reference/guam_services/#tput","text":"Write next line of text to TN3270 24x80 screen view (the default is EDIT mode) label TPUT buffer,buffer_length write TN3270 data stream to TN3270 screen interface. The write buffer must contain escape followed by valid TN3270 extended data stream which may contain EBCDIC encoded data and the following commands: WCC SF SFE SA SBA IC PT label TPUT buffer,buffer_len,FULLSCR","title":"TPUT"},{"location":"reference/guam_services/#tn3270","text":"Macro to generate native TN3270 data streams including SBA addresses using symbolic references for control codes. The following keyboard input keystrokes can be used to generate TN3270 compatible input data codes: key hex alternate keys ENTER 7D PF1 to PF9 F1-F9 PF10 to PF12 7A-7C PF13 to PF21 C1-C9 Ctrl + Alt + F1 to Ctrl + Alt + F9 PF22 to PF24 4A-4C Ctrl + Alt + F10 to Ctrl + Alt + F12 PA1 6C Ctrl + F1 PA2 6E Ctrl + F2 PA3 6B Ctrl + F3 CLEAR 6D Ctrl + C","title":"TN3270"},{"location":"reference/guam_services/#guam","text":"Macro to perform graphics display functions similar to GDDM. GUAM WINDOW,TITLE,\u2019text\u2019 set window title GUAM WINDOW,LOC,x,y set window location from upper left in pixels GUAM WINDOW,SIZE,width,height set window size in pixels GUAM WINDOW,FONT,size set window character font size (8-30) GUAM WINDOW,VIEW,MCS set scrolling MCS console log view (default) GUAM WINDOW,VIEW,SCREEN,row,col,color set text screen view GUAM WINDOW,VIEW,GRAPH,x,y,color set graphic display view GUAM WINDOW,GETVIEW,view get current view GUAM SCREEN,READ,buffer,buffer_len,WAIT/NOWAIT read text GUAM SCREEN,WRITE,row,col,buffer,buffer_len,color write text GUAM SCREEN,FIELD,row,col,length define field GUAM SCREEN,CURSOR, type set cursor type GUAM SCREEN,CURSOR,row,col set cursor position GUAM GRAPH,POINT,x,y,color draw point GUAM GRAPH,LINE,x1,y1,x2,y2,color draw line GUAM GRAPH,FILL,x1,y1,x2,y2,color fill area GUAM GRAPH,TEXT,x,y,\u2019text\u2019,color draw text GUAM KEYBOARD,mode,char,WAIT/NOWAIT read keyboard GUAM MOUSE,x,y,left,right read mouse position on graph and buttons GUAM SOUND,START,wav_file play wav sound file GUAM SOUND,STOP When the ez390 GUAM option is specified for execution of a z390 assembler program, a GUAM GUI window is opened in default MCS console view displaying all WTO and WTOR messages issued by program in a scrolling window. Whenever TPUT, or TGET macros are executed the GUI window switches to TN3290 screen view display mode. Whenever GUAM macro graphic commands are executed, the GUI window switches to GRAPH display mode. When in SCREEN or GRAPH view, WTO and WTOR commands can continue to be executed and displayed one at a time via the status line with command line replies as required. The user can switch between any of the 3 GUAM GUI views manually via view menu selection. Assembler application programs can set window title, location, size, font, and view mode at any time using the GUAM macros regardless of display view. Multiple user controlled GUAM GUI windows can be opened by executing different assembler programs as separate tasks under control of master program using the z390 CMDPROC macro to launch separate program tasks each of which can invoke a GUAM GUI interface.","title":"GUAM"},{"location":"reference/guam_services/#demonstrations","text":"The following GUI demonstration programs are included in the distribution in the guam/demo folder. DEMOGUI1.MLC \u2013 Issue WTOR, wait for reply via WAIT, display reply via WTO and repeat loop until END is entered. This program can be run in any of the following modes: Windows command line mode \u2013 ASMLG DEMO\\DEMOGUI1 Windows GUI interface \u2013 ASMLG DEMO\\DEMOGUI1 GUI DEMOGUI2.MLC \u2013 Issue WTOR, execute 3 instruction loop until ECB is posted, display reply via WTO along with date, time, instruction loop count and calculated MIP rate for the 3 instruction loop. It is very interesting to note that on a 3 GHZ Pentium 4 system, this demo runs at about 1.1 MIPS using command line mode, and about 2.6 MIPS using the GUI mode. This program can be run in any of the following modes: Windows command line mode \u2013 ASMLG DEMO\\DEMOGUI1 Windows GUI interface \u2013 ASMLG DEMO\\DEMOGUI1 GUI DEMOGUI3.MLC \u2013 issue TPUT and TGET with WAIT option in loop until END is entered. This demo uses default EDIT mode of TPUT and TGET to scroll the 24 lines of TN3270 screen view with wrap around after status line prompt for input each time last line is written. DEMOGUI4.MLC \u2013 issue TN3270 data stream TPUT and TGET with WAIT option in loop until END is entered. This demo writes text to fields at specified screen buffer addresses, reads a field at specified address, displays the input field at another address, and repeats the process waiting for screen input until PF3 or END is entered. DEMOGUI5.MLC \u2013 This demo used GUI graphic commands to draw text and graphics and read keyboard and mouse. (Note this program brings up graphic display view but the graphics commands are not implemented yet. See RPI 137 DEMOGUI6.MLC \u2013 TN3270 application program to support entering name, address, and numeric zip fields, displaying the current values, PF1 help screen, display hex value of any unused AID keys entered, and PF3 for exit. Info There is an EXEC CICS version of this same demo that runs via local or remote GUAM client TN3270 terminal connected to z390 CICS transaction manager. The demo supports PF1 for help and PF3 for exit. It sounds alarm and displays errors on status line. It also displays the hex AID code for any other PF keys entered. DEMOAPL1.MLC \u2013 show use of APL graphics via X\u201908\u2019 insert APL character command and also demo GUAM support of TN3270 color.","title":"Demonstrations"},{"location":"reference/guam_services/#reference","text":"For technical reference manual see IBM 3270 Data Stream Programmers Reference GA23-0059-07 For tutorial on TN3270 extended data stream programming with examples see http://www.tommysprinkle.com/mvs/P3270/start.htm .","title":"Reference"},{"location":"reference/program_services/","text":"Program Services Save area and linkage conventions Standard save area is defined as follows: DS 0CL72 DS F +0 reserved DS F +4 address of calling savearea DS F +8 address of called savearea DS 15F +12 callers GR14 through GR12 There are normally two save areas involved when a program is called by another program: The save area for the calling program -- the caller The save area for the called program -- the callee Upon entry to the called program, GR13 contains the address of the caller's save area. The callee: Saves GR14 to GR12 (registers at entry to the called program) at +12 of the caller's save area Obtains its own save area (the called program's save area) Stores the address of its save area at +8 of the caller's save area (caller's forward chain) Stores the address of the caller's save area (GR13 at entry) at +4 of its (the called program's) save area (called program's back chain) Loads GR13 with the address of its (the called program's) save area At this point the called program begins its processing. If it calls another program steps 1--5 are repeated; this time the \"caller\" is the current program and there is a new called program. When the called program finishes processing, it returns to the caller as follows: The called program uses its back chain (+4 in its save area) to restore GR13 to caller's save area The called program restores GR14 to GR12 from that save area (restores registers at entry); there are cases when GR15, GR0, and/or GR1 are not restored -- depends on the program. The called program returns to the caller by doing an unconditional branch to the address in GR14. This calling convention is explained in detail in the IBM z/OS Version 2 Release 4 MVS Programming: Assembler Services Guide (SA23-1368-40) . Refer to Chapter 2 - Linkage conventions. GR15 by convention may contain a return code upon exit. Program parameters There are two methods of passing parameters to a program. At assembly time using SYSPARM At run time using PARM In either case enclose the entire parm to be passed in double quotes. The double quotes are required to handle commas and spaces that otherwise cause command processors to split the parm. The double quotes are not required if there are no commas or spaces in the text. Assembly time - SYSPARM If single quotes are included in text, they are passed on to &SYSPARM. There is a limit of 32767 bytes for the text. SYSPARM will be transferred to the macro variable &SYSPARM. mz390 ... \"SYSPARM(HELLO WORLD)\" Access the text by coding: label DC C'&SYSPARM' ...... will translate to label DC C'HELLO WORLD' Run time - PARM PARM can be accessed via GR1 at program entry. GR1 will contain an address that points to a fullword in storage which points to a storage location with the parm length in a halfword followed by the parm value. ez390 ... \"PARM(HELLO WORLD)\" The fullword pointed to by GR1 points to: DC H'11',C'HELLO WORLD'` If single quotes are included around text in PARM they are removed. ez390 ... \"PARM('HELLO WORLD')\" Will also result in the fullword pointed to by GR1 pointing to: DC H'11',C'HELLO WORLD'` Usage The program is run with the parameter passed ez390 myprog \"PARM('HELLO WORLD')\" The program code: L R2,0(,R1) R2=address of parm length(HW)+value LH R3,0(,R2) R3=length of parm value BCTR R3,0 Subtract 1 from R3 - length for use in machine code EX R3,MOVE Execute MOVE instruction using length code from R3 ...... MOVE MVC PARM(0),2(R2) Move instruction used by EX PARM DC CL80' ' Work area for parm value GR1 is populated by ez390 with the parm address pointer. GR2 is loaded with the address of the parm length and address - fullword pointed to by GR1. GR3 is loaded with the parm length - halfword value pointed to by GR2. GR3 would contain decimal 11 which is the length of the parm \"HELLO WORLD\". GR3 is decremented by 1, making it a length code. The actual parm value of \"HELLO WORLD\" begins 2 bytes past the address in GR2. The EX instruction executes the instruction at label MOVE which will move the parm to the storage at label PARM using the length code in R3. Macro reference SVC functions The following is a list of the z390 SVC services that support the macros. DEC HEX Service 3 03 EXIT 3 03 EXIT (VSE) 6 06 LINK 7 07 XCTL 8 08 LOAD 8 08 CDLOAD (VSE) 9 09 DELETE 9 09 CDDELETE (VSE) 13 0D ABEND BLDL - Build a directory list name BLDL 0,list Build a directory list for use with LOAD, DELETE, LINK and XCTL. After a BLDL, an individual table entry may be used in these macros via the DE= parameter. Parameters list May be a label or (reg) and points to a storage area in the following format: format description H'count' The number of entries in the table. The following data structure represents an entry. Data Storage description H'entry length' The length of the following entry CL8'name' The name of the program XL2'00' TT (unused) X'00' R (1=found) X'00' K (unused) X'00' Z (1=program found in storage) X'00' C (unused) Entry length must be a minimum of 12, which would omit the Z and C fields. Names must be in alphameric order, a suffix of .390 is assumed. Register Usage R1 = BLDL list R15= Return code Return Return code is passed in GR15: 0 - All programs found 4 - Some programs not found 8 - Invalid count or invalid entry length Usage BLDL 0,LIST1 LOAD DE=BLDL2 ...... LIST1 DC H'2' BLDL1 DC H'14',CL8'MYPROG1',XL6'00' BLDL2 DC H'14',CL8'MYPROG2',XL6'00' Note In z390, there is no performance benefit in issuing a BLDL before a LOAD, DELETE, LINK or XCTL. LOAD - Load a program or module name LOAD EP=,EPLOC=,DDNAME=,DSNAME=,DE=,LOADPT= Load a program or module. Parameters See Common Program load parameters . Register usage R0 = Pointer to program name or BLDL entry, returned address R1 = Returned length R15= Path pointer and return code Return GR0 returns the address of the loaded module. If LOADPT is used, then GR0 may be stored at a label, or the address contained in a general register. GR1 returns the length as follows: For a program, the number of doublewords (8-byte units). For other modules, the length rounded up to the next doubleword boundary. GR15 has a return code: 0 - Load ok 4 - Module not found Abends S80A - Out of memory CDLOAD - Load a program or module (VSE) name CDLOAD phasename Maps to LOAD EP=phasename name CDLOAD (reg) Maps to LOAD EPLOC=(reg) Load a program or module (VSE only). Parameters See Common Program load parameters . Register Usage R0 = Pointer to program name, returned address R1 = Returned address R15= Return code Return GR0 and GR1 return the address of the loaded module. Length is not returned. GR15 has a return code: 0 - Load ok 4 - Module not found Abends S80A - Out of memory DELETE - Delete a program or module name DELETE EP=,EPLOC=,DDNAME=,DSNAME=,DE= Delete a program or module. Parameters See Common Program load parameters . Register Usage R0 = Pointer to program name or BLDL entry R15= Path pointer Return GR15 has a return code: 0 - Load ok 4 - Module not found CDDELETE - Delete a program or module (VSE) name CDDELETE phasename Maps to DELETE EP=phasename name CDDELETE (reg) Maps to DELETE EPLOC=(reg) Delete a program or module. (VSE only) Parameters See Common Program load parameters . Register Usage R0 = Pointer to program name Return GR15 has a return code: 0 - Load ok 4 - Module not found LINK - Load and pass control name LINK EP=,EPLOC=,DDNAME=,DSNAME=,DE=,PARAM=,VL= Load and pass control to another program. Return to 'linker'. Parameters See Common Program load parameters . Register Usage R0 = Pointer to program name or BLDL entry R1 = Parameter list R15= Path pointer Abends S806 - Module not found S80A - Out of memory XCTL - Load and pass control name XCTL (fromreg,toreg),EP=,EPLOC=,DDNAME=,DSNAME=,DE=,PARAM=,VL= Load and pass control to another program. Return to last 'linker' or terminate. Parameters See Common Program load parameters . (fromreg,toreg) Optional - Restores the specified register range from the savearea pointed to by GR13. The registers are restored from their conventional positions. The range must not specify or include the following general registers: 0, 1, 13, 15 Register Usage R0 = Pointer to program name or BLDL entry R1 = Parameter list R15= Path pointer All registers in the range fromreg-toreg Abends S806 - Module not found S80A - Out of memory RESTORE - Restores registers name RESTORE (fromreg,toreg) Restores the specified register range from the save area pointed to by GR13. The registers are restored from their conventional positions. Register Usage All registers in the range fromreg-toreg SNAP - Produces a component dump name SNAP STORAGE=(from,to),PDATA=(options, ... ),ID=,TEXT= Produces a component dump on the z390 console without terminating the program. Parameters STORAGE=(from,to) or STORAGE=((reg1),(reg2)) Optional parameter to dump some storage. Either 'from' or 'to' can be labels or register pointers. The first byte displayed is 'from' and the last is 'to'-1. PDATA=(options ... ) Optional parameter to display registers and/or control blocks. Default is PDATA=ALL . option description ALL Display all registers, control blocks and storage. When the STORAGE parameter is present only that area of storage is displayed. REGS Display all general and floating point registers. GPR Display general registers. FPR Display floating point registers. CDE Display information related to loaded programs or modules. DCB Display information related to opened and closed files. ID=nnnnn or ID=(reg) Numeric identifier, either numeric value or general register containing the identifier. Specify values 0-32767, higher values are negative. TEXT=string or TEXT='a string' or TEXT=(reg) Character identifier. Specify either a string without blanks, a string constant enclosed by single quotes or a general register pointing to a string terminated by X'00'. The string in all cases is limited to 60 bytes. Register Usage R0 = ID and flags R1 = TEXT pointer R14= STORAGE from R15= STORAGE to ABEND - Terminate program name ABEND id,DUMP Terminate the program. Parameters id Optional numeric identifier. Values from 0 to 4095. Displayed as abend Unnnn . DUMP A dump is always produced, overrides the NODUMP parm on ez390. All storage areas are dumped. Register Usage R1 = id and flags ESTAE, ESTAEX - Define Abend exit processing Info ESTAEX is provided for compatibility, only ESTAE is described here. name ESTAE label,type,PARAM= name ESTAE (reg),type,PARAM= name ESTAE 0 When a program abends, control is given to the label or address specified. Parameters 0 ESTAE 0 is used to cancel any previously established ESTAE routine. type Type is optional with default value of CT CT - adds a new exit OV - replaces an existing exit PARAM PARAM=label is optional PARAM=(reg) is optional When specified, the address of the label or the contents of the register are made available in the ESTAE control block at ESTAPARM. Exit invocation GR15 will contain the entry point, it is recommended that GR15 not be used as the base for the ESTAE routine. GR1 contains the address of the SDWA control block. The DSECT for the SDWA is generated by macro IHASDWA. This area may also be addressed by using the ZCVT. After processing the abend, several options are available: Cancel the exit and retry the failing instruction. Issue an ESTAE 0. Load GR0 with the address of the failing instruction, which is in the rightmost four bytes of the SDWA field SDWAEC1 and ensure that GR15=4, then return via BR R14. This will cancel the ESTAE and re-execute the instruction that caused the abend. If the instruction abends again, it will terminate the program. Sample code snippet: USING SDWA,R1 L R0,SDWAEC1+4 LA R15,4 BR R14 Enter a retry or cleanup routine. Place the retry address in GR0 and ensure GR15=4. If ESTAE 0 has not been issued, then the ESTAE routine remains active. Percolate through other recovery (ESTAE) routines. The current ESTAE routine is automatically cancelled. Set GR15=0 and return via BR R14. This will invoke previous recovery routines or abend the program. When percolate happens all LINK stack entries at a lower level than the latest ESTAE will be purged. Note In the z390 environment the abend code 0C5 may be caused by an internal error as well as a genuine addressing exception. If an abend occurs after the ESTAE exit is invoked and before ESTAE 0 or BR R14 are issued, then the program will be terminated. Register Usage R0 = exit address and flags R1 = parameter list R15= return code Return GR15 has a return code: 0 - ESTAE ok Abends SFFF - ESTAE stack exceeded ESPIE - Interrupt exit processing name ESPIE SET,addr,list,PARAM= name ESPIE SET,(reg),list,PARAM= name ESPIE RESET When a program interruption occurs eg. fixed point overflow, control is given to the label or address specified. Parameters RESET Will reset any previous ESPIE settings. list Set interupts that should be processed. If any of the codes 8, 10, 13 or 14 are specified, then the appropriate bit is set on in the PSW using the SPM instruction. The following interruption codes can appear in the list. 1 - operation 2 - privilege 3 - execute 4 - protection 5 - addressing 6 - specification 7 - data exception 8 - fixed point overflow (SPM mask bit X'8') 9 - fixed point divide 10 - decimal overflow (SPM mask bit X'4') 11 - decimal divide 12 - HFP exponent overflow 13 - HFP exponent underflow (SPM mask bit X'2') 14 - HFP significance (SPM mask bit X'1') 15 - HFP divide ESPIE SET,label,8 Single code ESPIE SET,label,(1,4,6) Multiple codes ESPIE SET,label,((2,6)) Range of codes: 2 through 6 ESPIE SET,label,(3,5,(7,9),14) Mixed codes: 3,5,7,8,9,14 PARAM (optional) PARAM=label PARAM=(reg) When specified the address of the label or the contents of the register are made available in the ESPIE control block. When the exit is invoked, GR1 contains the address of the EPIE control block. The macro IHAEPIE generates the DSECT for the EPIE. The EPIE control block is located in the ZCVT and may also be addressed by the ZCVT and EPIED macros. Note In the z390 environment, interruption code 5 may be caused by an internal error as well as a genuine addressing exception. Register Usage R0 = program mask R1 = exit address R15= parameter list SUBENTRY - Program entry name SUBENTRY CSECT=,BASES=,RENT=,RWA=,RWALNG=,STACK=,PSTACK=,PCHECK= Provides a standard entry for programs. Parameters name (optional) Although name is optional, care needs to be taken if it is omitted. A CSECT or sub-program should be named. CSECT= This is useful for setting up sub-programs within the main program that are invoked by the CALL macro. CSECT=YES (default) - Generates: name CSECT Standard entry. CSECT=NO - Generates: name DS 0D BASES= Override and extend the base registers for this program. Default BASES=(13) RENT Defines a re-entrant program. RENT=NO (default) A standard savearea is built, and GR13 is set as the default base register. This also serves as the pointer to the program's savearea to facilitate further linkage. The default base register GR13 may be overridden by the BASES= parameter (qv). It is recommended that the first register specified is GR13, if it isn't then a program is generated with non-standard linkage and may cause problems. RENT=YES The GETMAINed area described below is defined in the SUBENTRY macro. BASES= must be specified and the first register must not be GR13. Storage is GETMAINed and GR13 is set to the savearea within this storage. The STACK= parameter can generate multiple saveareas. The first register specified must NOT be 13. Each additional register generates the code and USING at the standard 4K intervals. eg. BASES=(13,7,8) will cover 12K of code. STACK=n Requires RENT=YES, default 0. Generates an addition to the GETMAINed area acquired allowing for multiple saveareas, each of these may have an additional read-only work area defined by RWALNG. RWA=dsectname (requires RENT=YES) RWA= defines the DSECT associated with this work area. RWALNG=n (requires RENT=YES, default 0) RWALNG defines the length of an additional work area to each savearea defined by STACK=. PSAVE Causes extra instructions to save and restore GR14 and GR15 registers. PSAVE=YES (default) - Save and restore GR14 and GR15 PSAVE=No - No save performed PSTACK=reg (requires RENT=YES, default=0) If PSTACK=0, then the user area address of each stack entry is stored at offset +80. Otherwise the user area address is not stored at offset +80, but loaded into the register specified. PCHECK (requires RENT=YES, default=YES) PCHECK=YES clears the stack area and sets the senior bit of the front and end pointers to 1. Register Usage R0,1,2,13,14,15 have multiple uses SUBEXIT - Program exit name SUBEXIT RC=returncode name SUBEXIT RC=(reg) Provides a standard exit for programs. If SUBENTRY used the parameter RENT=YES then the whole stack area will be FREEMAINed before GR15 is set. Parameters name (optional) RC will return the value in GR15, zero is the default. Register Usage All registers may be affected PERFORM or PM - Branch to local procedure name PERFORM procedure name PM procedure Generate a branch to a local procedure with base addressability. PERFORM and PM are identical macros. Uses MVC and B if SUBENTRY RENT=NO or push/pop stack if RENT=YES. Register Usage R14=Return address R15=Linkage register PENTRY - Define local procedure name PENTRY Define local procedure using name. Generates an entry-point for a local procedure preceded with a branch instruction if SUBENTRY RENT=NO. PEXIT - Exit local procedure name PEXIT Branch to last caller of local procedure. Generate branch to last PENTRY name address - 4. If SUBENTRY RENT=NO or generate decrement stack pointer, load, and branch if RENT=YES. Register Usage R14=Stack address R15=Saved linkage register EXIT - Return to last caller name EXIT Returns immediately to the last caller. No registers are restored. Use of SUBEXIT is preferred. Register Usage No registers affected EOJ (VSE only) name EOJ RC=returncode name EOJ RC=(reg) Returns immediately to the last caller. Parameters name is optional. RC will return the value in GR15, zero is the default. Register Usage R15= Return code CALL (list form) - Internal/external subroutine call name CALL ,(parm1,parm2,...),VL,MF=L Generates a parameter list for use with the execute form of CALL. name DC A(parm1,parm2...) Parameters (parm1,parm2,...) The parameters can be anything that is permitted in an A-type constant. Note that register forms like (R5) are not interpreted as general registers, but as constants. VL (optional) If the called program can accept a variable parameter list, then VL will turn on the senior bit (bit 0) of the last parameter. CALL (execute form) - Internal/external subroutine call name CALL routine,(parm1,parm2,...),VL,LINKINST=,MF=(E,parms) name CALL (reg),(parm1,parm2,...),VL,MF=(E,parms) Provides a standard internal or external subroutine call. Parameters Parameters are addressed by GR1 and linkage by GR14 routine. If a label, it can be internal (resolved at assembly time) or external (loaded and resolved by the linkage editor). If the routine is in register notation, it can be internal or separately loaded. (parm1,parm2,...) Modify a fixed or variable parameter list to be accessed by the called program. The parameter list must have initially been defined using the list form of the CALL. The parameters specified here will overlay that parameter list. It is important that the number of parameters specified here does not exceed those specified in the list form of the CALL. The parameters can be anything that is permitted in an A-type constant. Any parameters bounded by parentheses, eg. (R5) are assumed to be registers or register equates. The content of each register (fullword only) is stored at the parameter location. VL (optional) If the called program can accept a variable parameter list, then VL will turn on the senior bit (bit 0) of the last parameter. Note This is the last parameter in the modified parameter list. LINKINST= (optional) Determines the calling instruction. Choose BALR (default) or BASR. MF=(E,label) or MF=(E,(reg)) The label or register points to a parameter list previously defined with the list form of the CALL. Usage Call subroutine MYSUBR, replace the two parameters and mark the last parameter. MYCALL CALL MYSUBR,(8,MYDATA),VL,MF=(E,PARMS) ...... PARMS CALL ,(7,OLDDATA),VL,MF=L CALL (standard form) - Internal/external subroutine call name CALL routine,(parm1,parm2,...),VL,LINKINST=,MF=I name CALL (reg),(parm1,parm2,...),VL,LINKINST=,MF=I Provides a standard internal or external subroutine call. Parameters Parameters are addressed by GR1 and linkage by GR14 routine. If a label, it can be internal (resolved at assembly time) or external (loaded and resolved by the linkage editor). If the routine is in register notation, it can be internal or separately loaded. (parm1,parm2,...) (optional) Pass a fixed or variable parameter list to the called program. The parameters can be anything that is permitted in an A-type constant. Any parameters bounded by parentheses, eg. (R5) are assumed to be registers or register equates. The content of each register (fullword only) is stored at the parameter location. VL (optional) If the called program can accept a variable parameter list, then VL will turn on the senior bit (bit 0) of the last parameter. LINKINST= (optional) Determines the calling instruction. Choose BALR (default) or BASR. Usage Call subroutine MYSUBR, pass two parameters and mark the last parameter. MYCALL CALL MYSUBR,(8,MYDATA),VL Register Usage R0 = indirect parameter list R1 = parameter list R14= linkage R15= program location SAVE - Save registers name SAVE (fromreg,toreg) Saves the specified register range in the save area pointed to by GR13. The registers are saved in their conventional positions. RETURN - Restore registers name RETURN (fromreg,toreg),flag,RC= Restores the specified register range from the save area pointed to by GR13. The registers are restored from their conventional positions. Return is by the restored GR14. Parameters flag (optional) T specifies that the byte at savearea+15 has the junior bit (bit 7) turned on to indicate a return to a called program. This bit (rightmost bit of saved GR14) is set after GR14 has been loaded with the return address. RC=nn or RC=(reg) If RC is omitted, GR15 is assumed to contain the return code. GR15 is loaded with this return code before returning via GR14. RC may have a numeric value or the value may be in GRreg. Register Usage R15= Return code All registers in the range fromreg-toreg Usage MYRET RETURN (14,12),T,RC=12 Restore registers 14 through 12. After the register restore, flag the savearea to indicate return to caller and set return code to 12. PSAD - PSA structure Provides a DSECT for the limited fields available in the first 8K of memory (PSA). The CVT may be addressed from here. ZCVTD - ZCVT structure Provides a DSECT for the limited fields available in the ZCVT. This follows the PSA and may be addressed as follows: L reg,ZCVT USING IHAZCVT,reg ...... ZCVTD CVTD - CVT structure Provides a DSECT for the limited fields available in the Communications Vector Table. This may be addressed as follows: L reg,X'10' USING IHACVT,reg ...... CVTD EQUREGS - Register equates EQUREGS REGS=option,TYPE=option Generates standard equates for the general or floating point registers. No parameters passed: EQUREGS (defaults to REGS=GPR,TYPE=DEC) R0 EQU 0 ...... R15 EQU 15 TYPE=HEX: EQUREGS TYPE=HEX R0 EQU 0 ...... RF EQU 15 REGS=FPR: EQUREGS REGS=FPR F0 EQU 0 ...... F15 EQU 15 REGS=FPR,TYPE=HEX EQUREGS REGS=FPR,TYPE=HEX F0 EQU 0 ...... FF EQU 15 YREGS - General register equates YREGS is identical to EQUREGS with default parameters which will generate general register equates. Additional information Use counts and parameter passing On the first invocation and after a LOAD , LINK or XCTL , the program receiving control has its use count incremented. When a program is DELETEd, it terminates or loses control via an XCTL, then the use count is decremented. When the use count is zero, the storage for that program is freed. When passing parameters it is important to consider whether those parameters are in a program whose storage may be reused. If in doubt, place parameters for passing on, in a separate GETMAINed area. Common program load parameters The following parameter descriptions apply to the LOAD , CDLOAD , DELETE , CDDELETE , LINK , XCTL and RESTORE macros. When a program is loaded (with suffix .390) then relocation takes place. EP, EPLOC, DDNAME and DSNAME are used to locate the program or module. EP, EPLOC and DE are mutually exclusive. DDNAME and DSNAME cannot both be present. EP=program Specify the program name, maximum 8 bytes. EPLOC=label or EPLOC=(reg) The label or the register must point to an 8-byte field containing the program name. DE=label or DE=(reg) The label or the register must point to a BLDL entry. In all the above cases as neither DDNAME nor DSNAME are specified, then the z390 search path is used. This may be overridden by the ez390 parameter SYS390. EP/EPLOC/DE and DDNAME=name or EP/EPLOC/DE and DDNAME=(reg) DDNAME has or points to the name of an environment variable. This variable may contain: The complete path and filename. In this case EP, EPLOC or DE are ignored. A single path. Only this path will be searched. Multiple paths separated by plus signs. All paths will be searched in the order specified. LINK EP=MYLINK,DDNAME=MYPATH ... For execution, define a script file setting the environment variable MYPATH Program specified with EP ignored SET MYPATH=c:\\path\\to\\390\\file.390 Single search path SET MYPATH=c:\\path\\to\\folder Multiple search paths SET MYPATH=c:\\path\\to\\dir1+c:\\path2 EP/EPLOC/DE and DSNAME=name or EP/EPLOC/DE and DSNAME=(reg) DSNAME is or points to a label defined in the program which has the file spec. The file spec must terminate with X'00' or be defined as a double-quoted string within the standard C-type constant. Either constant may contain: The complete path and filename. In this case EP, EPLOC or DE are ignored. A single path. Only this path will be searched. Multiple paths separated by semicolons or plus signs. All paths will be searched in the order specified. LINK EP=MYLINK,DSNAME=MYPATH ... ...... MYPATH DC C'c:\\path\\to\\file',X'00' MYPATH DC C'\"c:\\path1;c:\\path2\"' Note In the above cases where the filename is specified in the environment variable or the DC constant, then the .390 suffix should be omitted. The exceptions to this are LOAD and DELETE , which may be used to load or delete a non-program module and may have any suffix appended. PARAM= and VL= Only available on LINK and XCTL . Used for passing a fixed or variable parameter list to a program. PARAM=(parm1,parm2,...) The parameters can be anything that is permitted in an A-type constant. When the program is invoked GR1 points to the parameter list. See Use counts and parameter passing below for special considerations. VL=0 or VL=1 Default - VL=1 If the called program can accept a variable parameter list, then VL=1 will turn on the senior bit (bit 0) of the last parameter.","title":"Program Services"},{"location":"reference/program_services/#program-services","text":"","title":"Program Services"},{"location":"reference/program_services/#save-area-and-linkage-conventions","text":"Standard save area is defined as follows: DS 0CL72 DS F +0 reserved DS F +4 address of calling savearea DS F +8 address of called savearea DS 15F +12 callers GR14 through GR12 There are normally two save areas involved when a program is called by another program: The save area for the calling program -- the caller The save area for the called program -- the callee Upon entry to the called program, GR13 contains the address of the caller's save area. The callee: Saves GR14 to GR12 (registers at entry to the called program) at +12 of the caller's save area Obtains its own save area (the called program's save area) Stores the address of its save area at +8 of the caller's save area (caller's forward chain) Stores the address of the caller's save area (GR13 at entry) at +4 of its (the called program's) save area (called program's back chain) Loads GR13 with the address of its (the called program's) save area At this point the called program begins its processing. If it calls another program steps 1--5 are repeated; this time the \"caller\" is the current program and there is a new called program. When the called program finishes processing, it returns to the caller as follows: The called program uses its back chain (+4 in its save area) to restore GR13 to caller's save area The called program restores GR14 to GR12 from that save area (restores registers at entry); there are cases when GR15, GR0, and/or GR1 are not restored -- depends on the program. The called program returns to the caller by doing an unconditional branch to the address in GR14. This calling convention is explained in detail in the IBM z/OS Version 2 Release 4 MVS Programming: Assembler Services Guide (SA23-1368-40) . Refer to Chapter 2 - Linkage conventions. GR15 by convention may contain a return code upon exit.","title":"Save area and linkage conventions"},{"location":"reference/program_services/#program-parameters","text":"There are two methods of passing parameters to a program. At assembly time using SYSPARM At run time using PARM In either case enclose the entire parm to be passed in double quotes. The double quotes are required to handle commas and spaces that otherwise cause command processors to split the parm. The double quotes are not required if there are no commas or spaces in the text.","title":"Program parameters"},{"location":"reference/program_services/#assembly-time-sysparm","text":"If single quotes are included in text, they are passed on to &SYSPARM. There is a limit of 32767 bytes for the text. SYSPARM will be transferred to the macro variable &SYSPARM. mz390 ... \"SYSPARM(HELLO WORLD)\" Access the text by coding: label DC C'&SYSPARM' ...... will translate to label DC C'HELLO WORLD'","title":"Assembly time - SYSPARM"},{"location":"reference/program_services/#run-time-parm","text":"PARM can be accessed via GR1 at program entry. GR1 will contain an address that points to a fullword in storage which points to a storage location with the parm length in a halfword followed by the parm value. ez390 ... \"PARM(HELLO WORLD)\" The fullword pointed to by GR1 points to: DC H'11',C'HELLO WORLD'` If single quotes are included around text in PARM they are removed. ez390 ... \"PARM('HELLO WORLD')\" Will also result in the fullword pointed to by GR1 pointing to: DC H'11',C'HELLO WORLD'`","title":"Run time - PARM"},{"location":"reference/program_services/#macro-reference","text":"","title":"Macro reference"},{"location":"reference/program_services/#svc-functions","text":"The following is a list of the z390 SVC services that support the macros. DEC HEX Service 3 03 EXIT 3 03 EXIT (VSE) 6 06 LINK 7 07 XCTL 8 08 LOAD 8 08 CDLOAD (VSE) 9 09 DELETE 9 09 CDDELETE (VSE) 13 0D ABEND","title":"SVC functions"},{"location":"reference/program_services/#bldl","text":"name BLDL 0,list Build a directory list for use with LOAD, DELETE, LINK and XCTL. After a BLDL, an individual table entry may be used in these macros via the DE= parameter.","title":"BLDL - Build a directory list"},{"location":"reference/program_services/#load","text":"name LOAD EP=,EPLOC=,DDNAME=,DSNAME=,DE=,LOADPT= Load a program or module.","title":"LOAD - Load a program or module"},{"location":"reference/program_services/#cdload","text":"name CDLOAD phasename Maps to LOAD EP=phasename name CDLOAD (reg) Maps to LOAD EPLOC=(reg) Load a program or module (VSE only).","title":"CDLOAD - Load a program or module (VSE)"},{"location":"reference/program_services/#delete","text":"name DELETE EP=,EPLOC=,DDNAME=,DSNAME=,DE= Delete a program or module.","title":"DELETE - Delete a program or module"},{"location":"reference/program_services/#cddelete","text":"name CDDELETE phasename Maps to DELETE EP=phasename name CDDELETE (reg) Maps to DELETE EPLOC=(reg) Delete a program or module. (VSE only)","title":"CDDELETE - Delete a program or module (VSE)"},{"location":"reference/program_services/#link","text":"name LINK EP=,EPLOC=,DDNAME=,DSNAME=,DE=,PARAM=,VL= Load and pass control to another program. Return to 'linker'.","title":"LINK - Load and pass control"},{"location":"reference/program_services/#xctl","text":"name XCTL (fromreg,toreg),EP=,EPLOC=,DDNAME=,DSNAME=,DE=,PARAM=,VL= Load and pass control to another program. Return to last 'linker' or terminate.","title":"XCTL - Load and pass control"},{"location":"reference/program_services/#restore","text":"name RESTORE (fromreg,toreg) Restores the specified register range from the save area pointed to by GR13. The registers are restored from their conventional positions.","title":"RESTORE - Restores registers"},{"location":"reference/program_services/#snap","text":"name SNAP STORAGE=(from,to),PDATA=(options, ... ),ID=,TEXT= Produces a component dump on the z390 console without terminating the program.","title":"SNAP - Produces a component dump"},{"location":"reference/program_services/#abend","text":"name ABEND id,DUMP Terminate the program.","title":"ABEND - Terminate program"},{"location":"reference/program_services/#estae","text":"Info ESTAEX is provided for compatibility, only ESTAE is described here. name ESTAE label,type,PARAM= name ESTAE (reg),type,PARAM= name ESTAE 0 When a program abends, control is given to the label or address specified.","title":"ESTAE, ESTAEX - Define Abend exit processing"},{"location":"reference/program_services/#espie","text":"name ESPIE SET,addr,list,PARAM= name ESPIE SET,(reg),list,PARAM= name ESPIE RESET When a program interruption occurs eg. fixed point overflow, control is given to the label or address specified.","title":"ESPIE - Interrupt exit processing"},{"location":"reference/program_services/#subentry","text":"name SUBENTRY CSECT=,BASES=,RENT=,RWA=,RWALNG=,STACK=,PSTACK=,PCHECK= Provides a standard entry for programs.","title":"SUBENTRY - Program entry"},{"location":"reference/program_services/#subexit","text":"name SUBEXIT RC=returncode name SUBEXIT RC=(reg) Provides a standard exit for programs. If SUBENTRY used the parameter RENT=YES then the whole stack area will be FREEMAINed before GR15 is set.","title":"SUBEXIT - Program exit"},{"location":"reference/program_services/#perform","text":"name PERFORM procedure name PM procedure Generate a branch to a local procedure with base addressability. PERFORM and PM are identical macros. Uses MVC and B if SUBENTRY RENT=NO or push/pop stack if RENT=YES.","title":"PERFORM or PM - Branch to local procedure"},{"location":"reference/program_services/#pentry","text":"name PENTRY Define local procedure using name. Generates an entry-point for a local procedure preceded with a branch instruction if SUBENTRY RENT=NO.","title":"PENTRY - Define local procedure"},{"location":"reference/program_services/#pexit","text":"name PEXIT Branch to last caller of local procedure. Generate branch to last PENTRY name address - 4. If SUBENTRY RENT=NO or generate decrement stack pointer, load, and branch if RENT=YES.","title":"PEXIT - Exit local procedure"},{"location":"reference/program_services/#exit","text":"name EXIT Returns immediately to the last caller. No registers are restored. Use of SUBEXIT is preferred.","title":"EXIT - Return to last caller"},{"location":"reference/program_services/#eoj","text":"name EOJ RC=returncode name EOJ RC=(reg) Returns immediately to the last caller.","title":"EOJ (VSE only)"},{"location":"reference/program_services/#call-list","text":"name CALL ,(parm1,parm2,...),VL,MF=L Generates a parameter list for use with the execute form of CALL. name DC A(parm1,parm2...)","title":"CALL (list form) - Internal/external subroutine call"},{"location":"reference/program_services/#call-exec","text":"name CALL routine,(parm1,parm2,...),VL,LINKINST=,MF=(E,parms) name CALL (reg),(parm1,parm2,...),VL,MF=(E,parms) Provides a standard internal or external subroutine call.","title":"CALL (execute form) - Internal/external subroutine call"},{"location":"reference/program_services/#call-std","text":"name CALL routine,(parm1,parm2,...),VL,LINKINST=,MF=I name CALL (reg),(parm1,parm2,...),VL,LINKINST=,MF=I Provides a standard internal or external subroutine call.","title":"CALL (standard form) - Internal/external subroutine call"},{"location":"reference/program_services/#save","text":"name SAVE (fromreg,toreg) Saves the specified register range in the save area pointed to by GR13. The registers are saved in their conventional positions.","title":"SAVE - Save registers"},{"location":"reference/program_services/#return","text":"name RETURN (fromreg,toreg),flag,RC= Restores the specified register range from the save area pointed to by GR13. The registers are restored from their conventional positions. Return is by the restored GR14.","title":"RETURN - Restore registers"},{"location":"reference/program_services/#psad","text":"Provides a DSECT for the limited fields available in the first 8K of memory (PSA). The CVT may be addressed from here.","title":"PSAD - PSA structure"},{"location":"reference/program_services/#zcvt","text":"Provides a DSECT for the limited fields available in the ZCVT. This follows the PSA and may be addressed as follows: L reg,ZCVT USING IHAZCVT,reg ...... ZCVTD","title":"ZCVTD - ZCVT structure"},{"location":"reference/program_services/#cvt","text":"Provides a DSECT for the limited fields available in the Communications Vector Table. This may be addressed as follows: L reg,X'10' USING IHACVT,reg ...... CVTD","title":"CVTD - CVT structure"},{"location":"reference/program_services/#equregs","text":"EQUREGS REGS=option,TYPE=option Generates standard equates for the general or floating point registers. No parameters passed: EQUREGS (defaults to REGS=GPR,TYPE=DEC) R0 EQU 0 ...... R15 EQU 15 TYPE=HEX: EQUREGS TYPE=HEX R0 EQU 0 ...... RF EQU 15 REGS=FPR: EQUREGS REGS=FPR F0 EQU 0 ...... F15 EQU 15 REGS=FPR,TYPE=HEX EQUREGS REGS=FPR,TYPE=HEX F0 EQU 0 ...... FF EQU 15","title":"EQUREGS - Register equates"},{"location":"reference/program_services/#yregs","text":"YREGS is identical to EQUREGS with default parameters which will generate general register equates.","title":"YREGS - General register equates"},{"location":"reference/program_services/#additional-information","text":"","title":"Additional information"},{"location":"reference/soa_services/","text":"SOA services The z390 project supports low level Service Oriented Architecture (SOA) type application generation and execution. The advantage of using the SOA architecture is that services are more easily shared across diverse applications and user networks and maintenance is simpler since server code does not need to be statically linked into client application code. Any z390 application program can open up to 10 different client TCP/IP ports and 10 different TCP/IP server ports. The server can support up to a total of 20 concurrent connections from client. z390 TCP/IP client and server programs can interact with clients or server applications written in any language supporting compatible messaging via TCP/IP sockets. Macro reference SVC functions The z390 macro TCPIO invoking svc x\u20197C\u2019 supports TCP/IP sockets messaging between client and server components. TCPIO - TCP/IP operations The TCPIO macro operations OPEN, CLOSE, SEND, and RECEIVE support messaging between client and server programs using TCP/IP sockets. Messages of any length can be exchanges between any client and server programs on a TCP/IP network. The server program must first open a socket port. Up to 20 concurrent clients can open connections to any server port. The same program can have up to 10 server ports and 10 client ports open. This command is similar to the functions provided by the IBM z/OS Communication Server macro EZASMI OPEN label TCPIO OPEN,PORT=port,HOST=host The port can be any standard port number less than 1024 or any private port number above 1024. The port number can be numeric constant, symbolic absolute value, or can be specified in (register). The only requirement is that port numbers not conflict with other port numbers being used on the same network with the same processor hosts. If the HOST= keyword parameter is coded specifying a specific host IP address such as 162.692.1.3 or * for the current processor, then a client port will be opened with a connection to the server port on the indicated processor. If a connection to the specified server port cannot be made, then a return code of 12 will be set. If the HOST= parameter is omitted, then a server port will be opened on the current processor which can handle up to 20 concurrent connections from client ports on the network. CLOSE label TCPIO CLOSE,PORT=port Close the specified port. Info You cannot open a client and sever port with the same number so there is no need to indicate which type it is. When a server port is closed, all associated port and connection threads are also terminated. All ports are automatically closed at program termination if not closed explicitly. SEND label TCPIO SEND,PORT=port,MSG=addr,LMSG=length Send the message with specified address and length to the specified port. The message starting address can be RX type label or can be specified as (register). The message length can be absolute value or (register). If the send fails, a return code of 12 will be set. RECEIVE label TCPIO RECEIVE[,NOWAIT],PORT=port,MSG=addr,LMSG=max-length[,CONN=id] Receive a message from the specified port starting at address with length up to max length. The message starting address can be RX type label or can be specified as (register). The message maximum length can be absolute value or (register). If the optional second positional parameter NOWAIT is specified, a return code of 4 will be returned if no message is ready otherwise the RECEIVE will wait until at least 1 byte of the message is available. If the port is a server port then the optional keyword parameter CONN=id may be specified indicating a specific connection that was previously returned by prior TCPIO RECEIVE in register 2. If a CONN value of -1 is specified or the parameter is omitted, the next message from any connection will be returned along with the connection id in register 2. At least 1 byte will be returned on a successful RECEIVE with return code 0 along with the number of bytes returned in register 1. Up to the max-length bytes may be returned. If more than one message arrives prior to RECEIVE, it is up to the user to determine where one message ends and next message starts. A 4 byte message length prefix can be used to determine each message length. If passing ASCII text, use ending line feed character (hex x\u20190A\u2019). Note More than one RECEIVE operation may be required to retrieve an entire logical message since the TCP/IP network may not transfer the entire message in one packet on the network and a portion of the logical message may be ready whereas the next RECEIVE may have to wait for the next part of the message. The TCPIO service is not sensitive to any special characters and all byte values are allowed anywhere in messages. If any TCPIO operation fails for any reason on the client or server, a non-zero return code is returned. The TCPIO server port support includes multiple threads to support concurrent connections. There is one thread for each open server port which waits for new connections on the server port, starts new connection thread, and then returns to wait for another connection. Each connection thread waits for any current available messages to be read from that connection input buffer by the main TPCIO user thread. When all messages have been retrieved, then the connection thread issues a connection client socket read for first byte of the next input message. The connection thread will wait for the next message to arrive in the input buffer or for a disconnect. If a disconnect occurs, the connection thread is cancelled. If a pending RECEIVE is waiting on the connection which disconnected, a return code of 12 is returned. If the read of first byte is successful the thread returns to wait for the main TCPIO user thread to retrieve the full or partial message available in the connection input buffer. Since partial messages can arrive from multiple connections in any sequence, the server must be sure to retrieve a complete message from a specific connection prior to returning to non-specific RECEIVE for the next message. SOAGEN - SOA app gen support The macro SOAGEN can be used to generate customized client and server message managers plus stubs for each service called by the client application. In addition the SOAGEN macro generates two batch commands to build the SOA application and to execute the client server SOA application. The SOAGEN macro uses the z390 PUNCH extension operands DSNAME= and FORMAT to generate 3 or more source MLC files plus the two BAT files in one macro expansion execution. Parameters Parameter Usage Comments MAIN= name of main client program If specified, an assembly and link of the main program with the generated service call stubs will be generated. CTYPE=MLC/CBL define language type for client COBOL clients generate IBM standard EZASOKET calls to TCP/IP to connect to services. CLIENT= name of the generated client message manager called from stubs. SERVER= name of the generated service message manager which loads and calls services based on service request messages. HOST= IP address of server host processor or * for local processor PORT= port # for this application (must be greater than 1023) SERVICES= one or more sublists defining the name of each called service and the length of each parameter being passed to service. If the length is negative, that indicates the parameter is read only and the updated parameter will not be returned in response message. MACDIR= directory containing the SOAGEN macros GENDIR= directory to contain the generated source files and command files GENBLD= name of the generated build command file GENRUN= name of the generated run command file Usage SOAGEN MAIN=DEMOMAIN, MAIN CLIENT APPLICATION PGM X CLIENT=DEMOCMGR, SOA CLIENT MSG MGR NAME X SERVER=DEMOSMGR, SOA SERVER MSG MGR NAME X HOST=*, (192.168.1.3) HOST SERVER NAME (*=LOCAL) X PORT=3900, HOST SERVER PORT X SERVICES=((DEMOSUB1,-45,-45,45), SERVICES WITH PARM LENX (DEMOSUB2,-4,-4,4)), (NOTE -LENGTH FOR READ ONLY) X MACDIR=<z390_path>\\SOA\\MACLIB, SOA GEN MACRO DIRECTORY X GENDIR=<z390_path>\\SOA\\DEMO, DIRECTORY FOR SOA APPL X GENBLD=DEMOBLD, GENERATED BUILD BAT FILE X GENRUN=DEMORUN GENERATED RUN BAT FILE END The above SOA application generation macro call generates server message manager DEMOSMGR to run on the same host as client using HOST=*. To generate the same application to run server on a specific host, change the HOST= parameter to specify the IP address of the desired server. The above SOAGEN macro call generates the following source files using z390 PUNCH extended operands DSNAME= and FORMAT to control PUNCH output files: DEMOCMGR.MLC \u2013 source macro call to SOACMGR to generate SOA client message manager for the demo application. DEMOSMGR.MLC \u2013 source macro call to SOASMGR to generate SOA server message manager for the demo application. SOA_STUB_DEMOSUB1.MLC - source macro call to SOASTUB to generate SOA stub for DEMOSUB1 service call. SOA_STUB_DEMOSUB2.MLC \u2013 source macro call to SOASTUB to generate SOA stub for DEMOSUB2 service call. DEMOBLD.BAT \u2013 generated command file to build the SOA demo application. DEMORUN.BAT \u2013 generated command file to start the DEMOSMGR server on the same processor and then run the DEMOMAIN client application. Technical Notes The client message manager is generated using a call to the SOACMGR macro with the required parameters from the SOAGEN macro call. The client message manager performs the following functions when called from a client source call stub: On first call, dynamically allocate the required message buffer based on the maximum service message required. On first call open a TCP/IP socket connection to the server message manager using the port and IP address specified. Build a send message with message length, time stamp, service name, and all the parameters required by the service. Note the service can only access the parameters passed with the length specified. If a service needs to access additional parameters such as control blocks in memory, they need to all be passed to the service. Send the message from client to server message manager using specified port Wait for response from the server with matching time stamp and service name plus updated parameters, and return code from service. Note the generated client message manager has logic to issue more than 1 RECEIVE to fetch the entire variable length response message if necessary. Move the returned updated parameters to the original calling list addresses. exit to calling stub which exits to the calling client main application program. The server message manager is generated using a call to the SOASMGR macro with the required parameters from the SOAGEN macro call. The server message manager performs the following functions: Opens server socket for specified port which starts thread which listens for new connections from clients and starts new connection threads as required. The server port and listens for incoming messages from clients. Issues receive on the server port to receive all or part of a message from a client on an open connection. The server logic fetches at least 4 bytes and uses the message length in the first 4 bytes to determine how many bytes must be read to complete the variable length message which may require additional receive commands. Look up the service name specified. If service not found, an error is generated on server log and server returns to get next message. Build call parameter address less pointing to the parameters in the received message. Note this implies that all updates by the service will be made to parameter areas in the message buffer. Load the service on the first call and save entry address. Call the service to update parameters in the message buffer. Store the service return code in the message buffer. Build return message truncated to just the updated parameters as indicated by positive lengths in the SOAGEN SERVICES parameter. Send response message back to client message manager using same connection as request message. Return to wait for next service request message from any client connection. If client disconnect occurs, the disconnect is logged and server returns to wait for next request message from any other client connections. Stubs for each service name called by the client application are generated using calls to the macro SOASTUB. The functions performed by the generated stubs are: On first call load the client message manager and save address. Call the client message manager passing the name of the service and the calling parameter list. Upon return, exit to caller with return code. If the GENBLD parameter specifies a name, then the SOAGEN macro will generate a batch command file which assembles each of the above source programs to create an executable SOA type client server application. If the GENRUN parameter specifies a name, then the SOAGEN macro will generate a batch command to start the named SOA server message manager on the same processor, and then run the client application. If the HOST parameter specifies a different processor, the generated server message manager will need to be copied to that processor and started prior to running the client application. Demonstration z390 distribution includes soa directory with SOA generation macro library and a demo application which can be generated and executed as either a classic statically linked application or an SOA generated client server application using TCP/IP sockets. Refer to README.TXT in SOA folder for more details. References Original z390 SOA documents http://www.z390.org/z390_SOA_User_Guide.pdf http://www.z390.org/z390_SOA_Support_for_COBOL_and_Assembler.htm http://www.z390.org/z390_SOA_Client_Server_Overview.pdf TCP/IP TCP/IP Transmission Control Protocol RFP J2SE ServerSocket Class J2SE Socket Class z/OS Communication server IP Sockets Application Programming Interface Guide and Reference Host IP Addressing J2SE InetAddress Class IP Addressing RFC Socket Ports Registered Ports Register a Port","title":"SOA services"},{"location":"reference/soa_services/#soa-services","text":"The z390 project supports low level Service Oriented Architecture (SOA) type application generation and execution. The advantage of using the SOA architecture is that services are more easily shared across diverse applications and user networks and maintenance is simpler since server code does not need to be statically linked into client application code. Any z390 application program can open up to 10 different client TCP/IP ports and 10 different TCP/IP server ports. The server can support up to a total of 20 concurrent connections from client. z390 TCP/IP client and server programs can interact with clients or server applications written in any language supporting compatible messaging via TCP/IP sockets.","title":"SOA services"},{"location":"reference/soa_services/#macro-reference","text":"","title":"Macro reference"},{"location":"reference/soa_services/#svc-functions","text":"The z390 macro TCPIO invoking svc x\u20197C\u2019 supports TCP/IP sockets messaging between client and server components.","title":"SVC functions"},{"location":"reference/soa_services/#TCPIO","text":"The TCPIO macro operations OPEN, CLOSE, SEND, and RECEIVE support messaging between client and server programs using TCP/IP sockets. Messages of any length can be exchanges between any client and server programs on a TCP/IP network. The server program must first open a socket port. Up to 20 concurrent clients can open connections to any server port. The same program can have up to 10 server ports and 10 client ports open. This command is similar to the functions provided by the IBM z/OS Communication Server macro EZASMI","title":"TCPIO - TCP/IP operations"},{"location":"reference/soa_services/#SOAGEN","text":"The macro SOAGEN can be used to generate customized client and server message managers plus stubs for each service called by the client application. In addition the SOAGEN macro generates two batch commands to build the SOA application and to execute the client server SOA application. The SOAGEN macro uses the z390 PUNCH extension operands DSNAME= and FORMAT to generate 3 or more source MLC files plus the two BAT files in one macro expansion execution.","title":"SOAGEN - SOA app gen support"},{"location":"reference/soa_services/#references","text":"","title":"References"},{"location":"reference/soa_services/#original-z390-soa-documents","text":"http://www.z390.org/z390_SOA_User_Guide.pdf http://www.z390.org/z390_SOA_Support_for_COBOL_and_Assembler.htm http://www.z390.org/z390_SOA_Client_Server_Overview.pdf","title":"Original z390 SOA documents"},{"location":"reference/soa_services/#tcpip","text":"TCP/IP Transmission Control Protocol RFP J2SE ServerSocket Class J2SE Socket Class z/OS Communication server IP Sockets Application Programming Interface Guide and Reference","title":"TCP/IP"},{"location":"reference/soa_services/#host-ip-addressing","text":"J2SE InetAddress Class IP Addressing RFC","title":"Host IP Addressing"},{"location":"reference/soa_services/#socket-ports","text":"Registered Ports Register a Port","title":"Socket Ports"},{"location":"reference/sort/","text":"zSORT The zSORT internal sort facility is a component of z390 which supports sorting of any number of fixed or variable length records of any size up to the limits of memory and 64 bit file system. zSORT is implemented with the intent of being compatible with IBM\u00ae DFSORT. SORT utility program SORT.MLC utility assembler program included in the sort and linklib folders performs a sort with the following input files: SORTIN \u2013 unsorted input file with DCB options SORTOUT \u2013 sorted output file with DCB options SYSIN \u2013 sort field definitions SORTWK01/SORTWK02 - sort work files Macro Reference The zSORT utility function can be called from z390 assembler programs using standard call interface with full work parameters in list pointed to by register 1. The first positional macro parameter contains the operation code and options. The macro operations available: ISORT - initialize for internal sort using PUT to insert unsorted records and GET to retrieve sorted records PUT - insert unsorted record following ISORT GET - return sorted record following last PUT, returns RC=4 at end of sorted records Example usage ZSORT ISORT,LRECL=80,MEMORY=10000000,FIELDS=(1,80,CH,A) ....... ZSORT PUT,REC=(R2) ....... ZSORT GET,REC=(R2) CHI R15,4 BE END_OF_FILE ISORT parameters Note The PUT and GET operations only require the keyword REC= defining address of record area. FIELDS Any number of key fields defined as FIELDS=(offset,length,type,order,{.repeat.}) Offset to start of key starts at 1 and cannot be greater than LRECL. For variable length records the offset does not include the 4 byte prefix. Length of key plus offset must not exceed LRECL Type of sort key field: AC - ASCII characters (same as CH) BI - unsigned binary (same as CH) CH - EBCDIC characters (same as CH) FI - signed binary such as half word, full word, or quad word integers FL - floating point HFP, BFP, or DFP short, long, or extended PD - packed decimal ZD - zoned decimal Order A - Ascending D - Descending LRECL Length of record (may be maximum length of variable length records). MEMORY Amount of memory available for sort table. If no value is specified, the maximum available contiguous memory block within the memory allocated to step by MEM option will be used. Execute format Alternatively the execute form MF=(E,addr) can be used. See linklib\\SORT.MLC for example. Technical details zSORT is implemented via SVC x'A1' which has 3 function calls: initialize internal sort request submit unsorted record retrieve sorted records. Unsorted records are loaded into a dynamically allocated table in memory and sorted. If the unsorted records exceed the size of the table, then multiple blocks of sorted records are written to a work file and then merged. If all the records fit in the table, then they are sorted and returned without requiring use of sort work files. When required, the merging is performed using two dynamically allocated sort work files with DDNAME's SORTWK01 and SORTWK02. The sorted strings are merged from one work file to another doubling the size of the sorted strings on each pass until all the records are sorted on last merge pass. All file I/O is blocked to minimize disk seeking on single disk systems. User can define the location of SORTWK01 and SORTWK02 if multiple physical disk drives are available. A million records can be sorted in 28 seconds. Statistics on each sort execution are recorded on the statistics file if option STATS is specified.","title":"zSORT"},{"location":"reference/sort/#zsort","text":"The zSORT internal sort facility is a component of z390 which supports sorting of any number of fixed or variable length records of any size up to the limits of memory and 64 bit file system. zSORT is implemented with the intent of being compatible with IBM\u00ae DFSORT.","title":"zSORT"},{"location":"reference/sort/#sort-utility-program","text":"SORT.MLC utility assembler program included in the sort and linklib folders performs a sort with the following input files: SORTIN \u2013 unsorted input file with DCB options SORTOUT \u2013 sorted output file with DCB options SYSIN \u2013 sort field definitions SORTWK01/SORTWK02 - sort work files","title":"SORT utility program"},{"location":"reference/sort/#macro-reference","text":"The zSORT utility function can be called from z390 assembler programs using standard call interface with full work parameters in list pointed to by register 1. The first positional macro parameter contains the operation code and options. The macro operations available: ISORT - initialize for internal sort using PUT to insert unsorted records and GET to retrieve sorted records PUT - insert unsorted record following ISORT GET - return sorted record following last PUT, returns RC=4 at end of sorted records","title":"Macro Reference"},{"location":"reference/sort/#example-usage","text":"ZSORT ISORT,LRECL=80,MEMORY=10000000,FIELDS=(1,80,CH,A) ....... ZSORT PUT,REC=(R2) ....... ZSORT GET,REC=(R2) CHI R15,4 BE END_OF_FILE","title":"Example usage"},{"location":"reference/sort/#isort-parameters","text":"Note The PUT and GET operations only require the keyword REC= defining address of record area.","title":"ISORT parameters"},{"location":"reference/sort/#execute-format","text":"Alternatively the execute form MF=(E,addr) can be used. See linklib\\SORT.MLC for example.","title":"Execute format"},{"location":"reference/sort/#technical-details","text":"zSORT is implemented via SVC x'A1' which has 3 function calls: initialize internal sort request submit unsorted record retrieve sorted records. Unsorted records are loaded into a dynamically allocated table in memory and sorted. If the unsorted records exceed the size of the table, then multiple blocks of sorted records are written to a work file and then merged. If all the records fit in the table, then they are sorted and returned without requiring use of sort work files. When required, the merging is performed using two dynamically allocated sort work files with DDNAME's SORTWK01 and SORTWK02. The sorted strings are merged from one work file to another doubling the size of the sorted strings on each pass until all the records are sorted on last merge pass. All file I/O is blocked to minimize disk seeking on single disk systems. User can define the location of SORTWK01 and SORTWK02 if multiple physical disk drives are available. A million records can be sorted in 28 seconds. Statistics on each sort execution are recorded on the statistics file if option STATS is specified.","title":"Technical details"},{"location":"reference/storage_services/","text":"Storage services Macro reference SVC functions The following is a list of the z390 SVC services that support the macros. DEC HEX Service 4 04 GETMAIN 4 04 GETVIS (VSE) 5 05 FREEMAIN 5 05 FREEVIS (VSE) Supporting macros STORAGE - Obtain/release storage CPOOL - Obtain a storage area STORAGE - Obtain/release storage name STORAGE OBTAIN,LENGTH=,LOC=,COND= Acquire storage name STORAGE RELEASE,ADDR=,LENGTH= Free storage An alternative to GETMAIN and FREEMAIN . LENGTH= becomes the GETMAIN/FREEMAIN parameter LV= LOC= is the same COND=NO (default) is the GETMAIN type R COND=YES is the GETMAIN type RC ADDR= becomes the GETMAIN/FREEMAIN parameter A GETMAIN - Acquire storage name GETMAIN type,LV=,LOC=,A= Parameters type Value Description R Obtain storage unconditionally. The default location is below 16M. RC Obtain storage conditionally. The default location is above 16M. The return code indicates whether the acquisition was successful. RU Obtain storage unconditionally. The default location is above 16M. LV Value Description LV=n Obtain n bytes (maximum value of n is 2G-1) LV=nK Obtain nK bytes (maximum value of n is 2097151) LV=nM Obtain nM bytes (maximum value of n is 2047) LV=(reg) Length required is in GR reg Note All storage requests will be rounded up to the next 8-byte boundary and is not initialized. LOC (optional) If omitted: type=R default to LOC=ABOVE type=RC default to LOC=BELOW type=RU default to LOC=BELOW Value Description LOC=BELOW LOC=RES LOC=24 LOC=(24) Try to acquire storage below 16M. LOC=ABOVE LOC=ANY LOC=31 LOC=(31) LOC=(24,31) Try to acquire storage above 16M. A (optional) After successful completion GR1 will contain the address of the acquired storage. This 4-byte address may be placed at label, or at the address in GRreg. The length will be returned in GR0, rounded as necessary. Usage GETMAIN 1024 bytes below 16M, unconditionally. GETMAIN R,LV=1024 GETMAIN number of bytes in GR3 below 16M, conditionally, GETMAIN RC,LV=(R3),LOC=BELOW Memory allocation Storage is limited by the MEM(nnn) parameter on ez390 with nnn in megabytes. The default is MEM(1) . When the value is 16 or less then all GETMAINs will allocate storage LOC=BELOW. When the value is above 16, then 16M bytes is available LOC=BELOW and the rest LOC=ABOVE. There is a preset maximum of MEM(50) set by Java. If this is insufficient, then code -Xmx nnnnnnnnn after the -Xrs option on ez390 to extend the MEM limit. Warning Over-extending memory this way may degrade the performance of your operating system. Register Usage R0 = Input flags, output length R1 = Input length, output address R15= Return code Return GR15 has a return code: 0 - GETMAIN ok 4 - Conditional request unsuccessful Abends S804 Invalid request - Can occur if LRECL/BLKSIZE on a DCB are both zero S80A Unconditional out of memory GETVIS - Acquire storage (VSE) name GETVIS LENGTH=,ADDRESS=,LOC= All forms map to GETMAIN R LENGTH and ADDRESS are mandatory. Parameters map to GETMAIN as follows: LENGTH=n Maps to LV=n LENGTH=(reg) Maps to LV=(reg) ADDRESS=label Maps to A=label ADDRESS=(reg) GR reg is not a pointer, the GETMAINd area address is placed in GR reg. LOC= Maps the same. Register Usage R0 = Input flags, output length R1 = Input length, output address R15= Return code Return GR15 has a return code: 0 - GETVIS ok Abends S804 Invalid request - Can occur if LRECL/BLKSIZE on a DCB are both zero S80A Unconditional out of memory FREEMAIN - Free storage name FREEMAIN LV=,LA=,A= Specify either LV= or LA=, if both are present LV= will be ignored. Parameters LV Value Description LV=n Free n bytes (maximum value of n is 2G-1) LV=nK Free nK bytes (maximum value of n is 2097151) LV=nM Free nM bytes (maximum value of n is 2047) LV=label label must be an equated value LV=(reg) Length to be freed is in GRreg LA Value Description LA=label The location of a 4-byte length LA=(reg) GR reg must point to a 4-byte length A (optional) If A= is omitted then GR1 must contain the address of the storage to be freed. Value Description A=label The location of the 4-byte address of the storage to be freed. A=(reg) The 4-byte address of the storage to be freed is in GR reg. Note The storage address specified must be on a doubleword boundary. A section of a previous GETMAIN may be freed. It is the programmer's responsibility to manage the resulting fragmentation. Register Usage R0 = length R1 = address R15= return code Return GR15 has a return code: 0 - FREEMAIN ok Abends S804 Invalid request S90A Attempt to FREEMAIN an area which is not on a doubleword boundary SA0A Attempt to FREEMAIN an area already free FREEVIS - Free storage (VSE) name FREEVIS LENGTH=,ADDRESS= All forms map to FREEMAIN R Defaults are LENGTH=(0) and ADDRESS=(1). Parameters map to FREEMAIN as follows: LENGTH=n Maps to LV=n LENGTH=(reg) Maps to LV=(reg) ADDRESS=label Maps to A=label ADDRESS=(reg) Maps to A=(reg) Register Usage R0 = length R1 = address R15= return code Return GR15 has a return code: 0 - FREEVIS ok Abends S804 Invalid request CPOOL - Obtain a storage area CPOOL BUILD,CPID=label,PCELLCT=nnn, SCELLCT=nnn,CSIZE=nnn,HDR='...' BUILD obtains a storage area divided into cells. Each subsequent GET retrieves the next cell. Warning FREE and DELETE are not yet implemented. CPID will contain the address of the GET routine for this cell PCELLCT contains the primary number of cells SCELLCT contains the secondary number of cells CSIZE is the size of each cell HDR is an optional string to identify the pool The GETMAIN size will be (PCELLCT+SCELLCT)*CSIZE CPOOL GET,CPID=label Get the next cell in this pool, GR1 contains the address or zero if all cells have been read.","title":"Storage services"},{"location":"reference/storage_services/#storage-services","text":"","title":"Storage services"},{"location":"reference/storage_services/#macro-reference","text":"","title":"Macro reference"},{"location":"reference/storage_services/#svc-functions","text":"The following is a list of the z390 SVC services that support the macros. DEC HEX Service 4 04 GETMAIN 4 04 GETVIS (VSE) 5 05 FREEMAIN 5 05 FREEVIS (VSE)","title":"SVC functions"},{"location":"reference/storage_services/#supporting-macros","text":"STORAGE - Obtain/release storage CPOOL - Obtain a storage area","title":"Supporting macros"},{"location":"reference/storage_services/#storage","text":"name STORAGE OBTAIN,LENGTH=,LOC=,COND= Acquire storage name STORAGE RELEASE,ADDR=,LENGTH= Free storage An alternative to GETMAIN and FREEMAIN . LENGTH= becomes the GETMAIN/FREEMAIN parameter LV= LOC= is the same COND=NO (default) is the GETMAIN type R COND=YES is the GETMAIN type RC ADDR= becomes the GETMAIN/FREEMAIN parameter A","title":"STORAGE - Obtain/release storage"},{"location":"reference/storage_services/#getmain","text":"name GETMAIN type,LV=,LOC=,A=","title":"GETMAIN - Acquire storage"},{"location":"reference/storage_services/#getvis","text":"name GETVIS LENGTH=,ADDRESS=,LOC= All forms map to GETMAIN R LENGTH and ADDRESS are mandatory. Parameters map to GETMAIN as follows: LENGTH=n Maps to LV=n LENGTH=(reg) Maps to LV=(reg) ADDRESS=label Maps to A=label ADDRESS=(reg) GR reg is not a pointer, the GETMAINd area address is placed in GR reg. LOC= Maps the same.","title":"GETVIS - Acquire storage (VSE)"},{"location":"reference/storage_services/#freemain","text":"name FREEMAIN LV=,LA=,A= Specify either LV= or LA=, if both are present LV= will be ignored.","title":"FREEMAIN - Free storage"},{"location":"reference/storage_services/#freevis","text":"name FREEVIS LENGTH=,ADDRESS= All forms map to FREEMAIN R Defaults are LENGTH=(0) and ADDRESS=(1). Parameters map to FREEMAIN as follows: LENGTH=n Maps to LV=n LENGTH=(reg) Maps to LV=(reg) ADDRESS=label Maps to A=label ADDRESS=(reg) Maps to A=(reg)","title":"FREEVIS - Free storage (VSE)"},{"location":"reference/storage_services/#cpool","text":"CPOOL BUILD,CPID=label,PCELLCT=nnn, SCELLCT=nnn,CSIZE=nnn,HDR='...' BUILD obtains a storage area divided into cells. Each subsequent GET retrieves the next cell. Warning FREE and DELETE are not yet implemented. CPID will contain the address of the GET routine for this cell PCELLCT contains the primary number of cells SCELLCT contains the secondary number of cells CSIZE is the size of each cell HDR is an optional string to identify the pool The GETMAIN size will be (PCELLCT+SCELLCT)*CSIZE CPOOL GET,CPID=label Get the next cell in this pool, GR1 contains the address or zero if all cells have been read.","title":"CPOOL - Obtain a storage area"},{"location":"reference/structured_program/","text":"Structured programming macros Structured Programming Macros (SPM) provide a compatible subset of the macros that IBM supplies as part of its licensed HLASM Toolkit product. These macros are based on the original 1978 public domain structure programming macros distributed as SHARE CBT tape #177. They have been enhanced to use structured macro extensions . Macro reference IF, ELSEIF, ELSE, ENDIF - alternate selection DO, ENDDO - iteration SELECT, WHEN, OTHRWISE, ENDSEL - selection by value using compares CASENTRY, CASE, ENDCASE - selection by value using branch table PM, PENTRY, PEXIT - perform block of code and return to next instruction ASMMSP.CPY - copybook for compatibility with HLASM Toolkit programs that require this copybook ZSTRGBL.CPY - copybook included in each structured programming macros (SPM) with shared global variables ZSTREQU - macro called from ZSTRGBL to define shared EQU's for condition code operands HLASM compatible versions Also included are translated versions of all the structured SPM's in the z390\\mac\\spm directory. The translated version are for use on systems with HLASM or other mainframe assemblers which do not yet support the SPE's. The following regression test programs are included: rt\\test\\TESTSPM1.MLC - test IF, DO, SELECT, and CASENTRY structures The following z390 utilities are written in structured form using these structured macro: linklib\\REPRO.MLC - VSAM load and unload utility linklib\\SUPERZAP.MLC - dump and path file utility linklib\\FPCONMFC.MLC - interface between z390 BFP/DFP/HFP regression tests and the mainframe compatible external format conversion routine linklib\\FPCONVRT.MAC.","title":"Structured programming macros"},{"location":"reference/structured_program/#structured-programming-macros","text":"Structured Programming Macros (SPM) provide a compatible subset of the macros that IBM supplies as part of its licensed HLASM Toolkit product. These macros are based on the original 1978 public domain structure programming macros distributed as SHARE CBT tape #177. They have been enhanced to use structured macro extensions .","title":"Structured programming macros"},{"location":"reference/structured_program/#macro-reference","text":"IF, ELSEIF, ELSE, ENDIF - alternate selection DO, ENDDO - iteration SELECT, WHEN, OTHRWISE, ENDSEL - selection by value using compares CASENTRY, CASE, ENDCASE - selection by value using branch table PM, PENTRY, PEXIT - perform block of code and return to next instruction ASMMSP.CPY - copybook for compatibility with HLASM Toolkit programs that require this copybook ZSTRGBL.CPY - copybook included in each structured programming macros (SPM) with shared global variables ZSTREQU - macro called from ZSTRGBL to define shared EQU's for condition code operands","title":"Macro reference"},{"location":"reference/structured_program/#hlasm-compatible-versions","text":"Also included are translated versions of all the structured SPM's in the z390\\mac\\spm directory. The translated version are for use on systems with HLASM or other mainframe assemblers which do not yet support the SPE's. The following regression test programs are included: rt\\test\\TESTSPM1.MLC - test IF, DO, SELECT, and CASENTRY structures The following z390 utilities are written in structured form using these structured macro: linklib\\REPRO.MLC - VSAM load and unload utility linklib\\SUPERZAP.MLC - dump and path file utility linklib\\FPCONMFC.MLC - interface between z390 BFP/DFP/HFP regression tests and the mainframe compatible external format conversion routine linklib\\FPCONVRT.MAC.","title":"HLASM compatible versions"},{"location":"reference/svc_services/","text":"SVC services SVC functions DEC HEX Service 1 01 WAIT 2 02 POST 11 0B TIME(and date) 11 0B GETIME (VSE) 40 28 GETENV 46 2E TTIMER 47 2F STIMER 52 34 CMDPROC 53 35 WTO 103 67 XLATE 160 A0 WTOR 170 AA CTD 171 AB CFD Supporting Macros COMRG - Address Communications region (VSE) Macro reference TIME(SVC) - Obtain the time and date name TIME type,addr,LINKAGE=SVC,DATETYPE=,CLOCKTYPE= Obtain the time and/or date in various formats. Parameters Type DEC - Decimal name TIME name TIME DEC Returns: Time in GR0 as HHMMSSTH Hours, mins and secs to 2 decimal places. The values are unsigned packed decimal: X'21420654' = 21:42:06.54 The MVO instruction can be used after storing the register to convert it to standard packed decimal format. Date in GR1 as CCYYDDDF - Century, year, day number and sign. The values are signed decimal: CC is (almost) the century number. YY the year number. DDD the day number within the year. F the positive sign. X'0106003F' = 3 rd January 2006 After storing, AP DATE,=P'1900000' can be used to convert to a 4-digit year. BIN - Binary name TIME BIN Returns: Time in GR0 in hundredths of a second since midnight in binary. Date in GR1 as CCYYDDDF - Century, year, day number and sign. TU - Time units name TIME TU Returns: Time in GR0 in timer units of 26.04166\u00b5s since midnight in binary. Date in GR1 as CCYYDDDF - Century, year, day number and sign. INS - Instruction count name TIME INS Returns: Instruction count in GR1 (64 bit value). MIC - Microseconds name TIME MIC,label name TIME MIC,(reg) Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 8 bytes specified. Date in GR1 as CCYYDDDF - Century, year, day number and sign. NS - Nanoseconds name TIME NS,label name TIME NS,(reg) Returns: Time in units of 1ns in binary since midnight. The time is stored at the 8 bytes specified. STCK - Microseconds bits 0-51 name TIME STCK,label name TIME STCK,(reg) Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 8 bytes specified and uses only bits 0-51 of the 8-byte field. Date in GR1 as above. TS - Timestamp name TIME TS,label name TIME TS,(reg) Returns: A string of 29 bytes at the label or pointed to by reg. The format is \"YYYY-MM-DD HH:MM:SS.NNNNNNNNN\". CLOCK - Microseconds since 1/1/1900 CLOCKTYPE=STCK name TIME CLOCK,label,CLOCKTYPE=STCK name TIME CLOCK,(reg),CLOCKTYPE=STCK Returns: Time in units of 1\u00b5s in binary since 1 st January 1900. The time is stored at the 8 bytes specified and uses only bits 0-51 of the 8-byte field. CLOCKTYPE=STCKE name TIME CLOCK,label,CLOCKTYPE=STCKE name TIME CLOCK,(reg),CLOCKTYPE=STCKE Returns: Time in units of 1\u00b5s in binary since 1 st January 1900. The time is stored at the 16 bytes specified: Byte 0 : Zero Bytes 1-13 : The time Bytes 14-15 : Programmable field set by the SCKPF instruction and not currently implemented. The time uses only bits 8-111 of the 16-byte field with bits 8-59 being the value in microseconds. CLOCKTYPE=JAVA name TIME CLOCK,label,CLOCKTYPE=JAVA name TIME CLOCK,(reg),CLOCKTYPE=JAVA Returns: Time in units of 1ms in binary since 1 st January 1970. The time is stored at the 8 bytes specified. Register Usage R0 = Code for units and date type R1 = Result area Return GR15 has a return code: 0 - TIME ok 4 - Invalid request TIME(SYSTEM) - Obtain the time and date name TIME type,addr,LINKAGE=SYSTEM,DATETYPE=,CLOCKTYPE= Parameters DATETYPE Specify the date format returned. All the formats are 4 bytes and the values are unsigned packed decimal. The MVO instruction can be used to convert it to standard packed decimal format. YYYY the year number. DDD the day number within the year. DD the day number within the month. MM the month number. YYYYDDD (default) stored as 0YYYYDDD MMDDYYYY DDMMYYYY YYYYMMDD Type DEC - Decimal name TIME ,label,LINKAGE=SYSTEM name TIME ,(reg),LINKAGE=SYSTEM name TIME DEC,label,LINKAGE=SYSTEM name TIME DEC,(reg),LINKAGE=SYSTEM Returns: Time as HHMMSSTH The time is stored at the 4 bytes specified. Hours, mins and secs to 2 decimal places. The values are unsigned packed decimal: X'21420654' = 21:42:06.54 The MVO instruction can be used to convert it to standard packed decimal format. The date is stored at label+8 or 8(reg). BIN - Binary name TIME BIN,label,LINKAGE=SYSTEM name TIME BIN,(reg),LINKAGE=SYSTEM Returns: The time is stored at the 4 bytes specified in hundredths of a second since midnight The date is stored at label+8 or 8(reg). MIC - Microseconds name TIME MIC,label,LINKAGE=SYSTEM name TIME MIC,(reg),LINKAGE=SYSTEM Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 8 bytes specified. The date is stored at label+8 or 8(reg). STCK - Microseconds 0-51 bits only name TIME STCK,label.LINKAGE=SYSTEM name TIME STCK,(reg),LINKAGE=SYSTEM Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 8 bytes specified and uses only bits 0-51 of the 8-byte field. The date is stored at label+8 or 8(reg). STCKE - Microseconds 16 byte name TIME STCKE,label.LINKAGE=SYSTEM name TIME STCKE,(reg),LINKAGE=SYSTEM Returns: Time in units of 1\u00b5s in binary since midnight. The time is stored at the 16 bytes specified: Byte 0 : Zero Bytes 1-13 : The time Bytes 14-15 : Programmable field set by the SCKPF instruction and not currently implemented. The time uses only bits 8-111 of the 16-byte field with bits 8-59 being the value in microseconds. Note The DATETYPE parameter is ignored. Register Usage R0 = Code for units and date type R1 = Result area Return GR15 has a return code: 0 - TIME ok 4 - Invalid request GETIME - Obtain time and date (VSE) GETIME type Obtain the time in various formats (VSE only). The time is stored in the GR0/GR1 register pair. Parameters type - date type STANDARD (default) Time in GR1 as 0HHMMSSc . Hours, mins and secs in packed format. BIN - Binary Time in GR1 in seconds since midnight in binary. TU - Time unit Time in GR1 in timer units of 26.04166\u00b5s since midnight in binary. MIC - Microseconds Time in units of 1\u00b5s in binary since midnight. Return GR15 has a return code: 0 - GETIME ok 4 - Invalid request STIMER - Wait for an interval of time Wait for an interval of time. name STIMER WAIT,BINTVL=label name STIMER WAIT,DINTVL=label name STIMER WAIT,MICVL=label name STIMER WAIT,TUINTVL=label Start a timer and continue. When the time expires the exit routine is invoked. name STIMER REAL,exit,BINTVL=label name STIMER REAL,exit,DINTVL=label name STIMER REAL,exit,MICVL=label name STIMER REAL,exit,TUINTVL=label Only one STIMER can be waiting for expiry at any moment. In each case the label points to a number of timer units. value effect Maximum value BINTVL Fullword with 100 th of a second units. X'7FFFFFFF' is approx. 249 days. DINTVL Doubleword PL8'HHMMSSth', where th is 2 decimal positions of seconds. 99595999, approximately 4 days. MICVL Doubleword with microsecond units X'7FFFFFFFFFFFFFFF', or nearly 300000 years TUINTVL Fullword with 26.04166\u00b5s units X'7FFFFFFF', approximately 16 hours. Parameters exit Can be label or (reg). When the time expires, the exit routine is invoked. GR15 has the address of the exit routine. Other registers must be assumed to be destroyed. Note STIMER REAL is measuring clock time, and not the time that the Z390 program is executing. Register Usage R0 = Code for timer units and exit address R1 = Address of the timer units R15 = By implication, exit routine address TTIMER - Test or cancel STIMER REAL Test or cancel a previously set STIMER REAL name TTIMER CANCEL,type,addr Parameters CANCEL CANCEL means that the STIMER timing is terminated. type TU (default) Returns the remaining time in GR0 as 4 bytes in timer units of 26.04166\u00b5s. addr is ignored. MIC,addr Using MIC requires addr which may be specified as label or (reg). The remaining time is returned at the doubleword address in microseconds. Usage Cancel the current STIMER REAL, return the remaining time in GR0 in timer units. TTIMER CANCEL Return the remaining time in microseconds at REMAIN. TTIMER ,MIC,REMAIN ...... REMAIN DS D Register Usage R0 = Code for timer units, returned value R1 = Address of returned timer units Return GR15 has a return code: * 0 TTIMER ok * 4 TU units remaining exceed 31 bits CMDPROC - execute host OS commands Open, close, read and write from the host command processor or shell. With the CMDPROC macro, you can issue OS shell commands, receive the replies from those commands line by line and start other programs. There is a limit of 10 command processors that can be open at any time. The limit is only to protect the operating system from storage depletion. In all cases below, ID may be defined as a numeric value or in a general register. For example, ID=2 or ID=(R5). Parameters ID ID may range from 0 (default) to 9. If the ID exceeds 9 then an abend SFFF will occur Subcommands START name CMDPROC START,ID=,CMDLOG= Start a command processor and assign an identifier. If the memory queue exceeds the MAXQUE value (default 1000) then the memory queue is written to the log and CMDPROC=YES is assumed. An error message is generated. CMDLOG CMDLOG=YES (Default) - All output from the command processor is written to the log. CMDLOG=NO - All output is saved in a memory queue. Use this option if you intend to use CMDPROC READ to retrieve command processor messages. STOP name CMDPROC STOP,ID= Close a previously opened command processor. WRITE name CMDPROC WRITE,label,ID= name CMDPROC WRITE,literal,ID= name CMDPROC WRITE,(reg),ID= Send a command to a previously opened command processor. label or (reg) Points to a constant which terminates with X'00' or is defined as a double-quoted string within a standard C-type constant. literal Double-quoted string within a standard C-type constant preceded by an equals sign. name CMDPROC WRITE,CMD1,ID=5 ...... CMD1 DC C'DIR /X',X'00' name CMDPROC WRITE,CMD1,ID=5 ...... CMD1 DC C'\"DIR /X\"' READ name CMDPROC READ,label,len,ID=,WAIT= Obtain the output, a line at a time, from the result of a command issued by CMDPROC WRITE from a previously opened command processor. label is the receiving area and may be specified as (reg). len Maximum length that is passed to your program. The default is the implied length of the receiving field. Maximum value is 4095 bytes. len may be specified as (reg) . Maximum register value is 2G - 1 bytes. If label is specified as (reg) , then len is mandatory. WAIT= Time in milliseconds before the READ will terminate if no output from the command processor is available to be read. Default is 500 milliseconds. Maximum value is 4095 (4 seconds). WAIT may be specified as (reg). Maximum value is X'7FFFFFFF' (about 24 days). Register Usage R0 = Operation code and ID R1 = Command area R2 = Length R3 = Wait value R15 = Formation of ID and return code Return GR15 has a return code: 0 - CMDPROC ok 4 - READ terminated as WAIT time has expired 8 - READ terminated because the command processor has ended 16 - Command Processor abnormally ended (see log message) WTO - Write to operator Display a message on the GUI console. The record descriptor word (RDW) defines the variable length text message generated by the WTO macro. DC AL2(len,0),C'text' len includes the 4 bytes for the RDW. Formats Text name WTO 'text' The RDW that describes the message is generated internally. List name WTO 'text',MF=L No text is written to the console; only the RDW and text is generated. This allows a 'collection' of messages to be constructed which can be used by the execute form. Execute 1 name WTO MF=E GR1 must be preloaded with the address of an RDW previously generated with the list form of WTO. Execute 2 name WTO MF=(E,label) name WTO MF=(E,(reg)) label or (reg) points to an RDW previously generated with the list form of the WTO. Register Usage R1 = Branch around RDW or parm pointer XLATE - EBCDIC to ASCII name XLATE area,len,TO= Translates data to EBCDIC or ASCII. Parameters area area may be specified as label or (reg) . len len may be specified as a number or (reg). Maximum numeric value is 4095 bytes. Maximum register value is 2G - 1 bytes. TO Type of conversion to perform: TO=A - convert area to ASCII. TO=E - convert area to EBCDIC. Register Usage R0 = Area address and codes R1 = Length WTOR - Write to operator Display a message on the GUI console and receive a response. name WTOR 'text',reply,len,ecb name WTOR \"text\",reply,len,ecb The RDW (see WTO) that describes the message is generated internally. The text appears on the console. Parameters reply Specified as label or (reg), is the field into which the reply is put. The reply appears on the console. len Maximum length of reply. If reply is specified as (reg) then len is mandatory. If len is omitted, then the implied length of reply is used. ecb Specified as label or (reg), by convention defined as DC F'0'. After the WTOR macro, instruction execution can proceed until the reply is completed by the user (commonly the Return key). Usage: Implied length, named ECB, wait for reply immediately. WTOR 'Enter your name',NAME,,MYECB WAIT ECB=MYECB ...... NAME DC CL40' ' MYECB DC F'0' Usage: Register notation, maximum length, no wait for reply. LA R5,NAME LA R6,MYECB WTOR 'Enter your name',(R5),40,(R6) ...... TM MYECB,X'40' BO GOTREPLY ...... NAME DC CL40' ' MYECB DC F'0' Register Usage R0 = Reply address R1 = Branch around RDW R14 = Reply length R15 = ECB address WAIT - Wait for ECB completion name WAIT num,ECB= name WAIT num,ECBLIST= ECB or ECBLIST must be specified. Parameters num num is optional and defaults to 1. For ECB= num must be 1 or omitted. For ECBLIST= num is the minimum number of ECBs that must be posted before the WAIT is complete. This value must, of course, be less or equal to the number of ECBs in the list. An abend SF05 will occur if this is not the case. ECB= Specified as label or (reg). The location of a single 4-byte ECB. ECBLIST= Specified as label or (reg). The location of a sequence of 4-byte addresses, each of which points to a 4-byte ECB. The last 4-byte address must have bit 0 set to 1. Note For DECBs, use the CHECK macro rather than WAIT, otherwise error routines may not be correctly invoked. Usage Wait for 2 out of 3 ECBs. WAIT 2,ECBLIST ...... ECBLIST DC A(ECB1) DC A(ECB2) DC A(X'80000000'+ECB3) ECB1 DC F'0' ECB2 DC F'0' ECB3 DC F'0' Register Usage R0 = Number of ECBs R1 = ECB address POST - Signal ECB completion Signal the completion of one ECB. name POST ecb,code Parameters ecb ecb is required. Specified as label or (reg). The location of a single 4-byte ECB. code code is optional and defaults to zero. Specified as a value (eg. 14 or X'123') or as (reg). Return The completion code is placed in bits 2-31 of the ECB. Register Usage R0 = Event completion code R1 = ECB address CTD - Convert binary or FP value name CTD type,IN=input,OUT=output,LINKAGE= Convert a binary or floating point value to a printable format. Parameters type This is a numeric value which determines the operation to be carried out. Equates are automatically generated. The value of type also determines the length of the input field. type may be specified in a register eg. (R5). Value Equate Length Description 1 CTD_INT128 16 binary 2 CTD_EH 4 short HFP 3 CTD_EB 4 short BFP 4 CTD_DH 8 long HFP 5 CTD_DB 8 long BFP 6 CTD_LH 16 extended HFP 7 CTD_LB 16 extended BFP 8 CTD_DD 8 long DFP 9 CTD_ED 4 short DFP 10 CTD_LD 16 extended DFP IN= The input field may be specified as a literal eg. IN==DH'3.8' , a label, a register pointer eg. IN=(R4) or a register eg. IN=R4 . For some types, input from a register implies the use of a register pair as follows: Value Equate Register specified 1 CTD_INT128 Any even general register, input is from the even/odd pair. 2 CTD_EH Any floating point register. 3 CTD_EB Any floating point register. 4 CTD_DH Any floating point register. 5 CTD_DB Any floating point register. 8 CTD_DD Any floating point register. 9 CTD_ED Any floating point register. 6 CTD_LH The first floating point register of a valid pair, input is from the the register pair. 7 CTD_LB The first floating point register of a valid pair, input is from the the register pair. 10 CTD_LD The first floating point register of a valid pair, input is from the the register pair. OUT= The output field may be specified as a label or a register pointer eg. OUT=(R4) . The output field is always 45 bytes, and is initialized to blanks. Not all 45 bytes may be used. The output field will be ASCII if the ASCII option is used, otherwise EBCDIC will be used. The output field has the following format in this sequence: Output field Condition - If the value is negative n...n Digits preceding the decimal point. If the value is less than 1 and there is no exponent, then 0 is output. eg. 0.04 . Decimal point if there are decimal positions n...n Digits following the decimal point if the value is not a whole number E Indicates an exponent follows - Indicates a negative exponent nnnn The exponent value, 1-4 digits Examples: Value Output zero 0 root2 1.4142... -root2 -1.4142... 50! 3.0414...E64 2 power -50 8.8817...E-16 LINKAGE= SVC (default) invokes SVC 170 CALL generates a CALL to module FPCONMFC Register Usage R0 = Parameter formation R1 = Parameter list R14 = Subroutine call R15 = Subroutine address and return code Return GR15 has a return code: 0 - CTD ok 8 - Invalid data address CFD - Convert to binary or FP value Convert a printable format number to a binary or floating point value. name CFD type,IN=input,OUT=output,LINKAGE= Parameters type This is a numeric value which determines the operation to be carried out. Equates are automatically generated. The value of type also determines the length of the output field. type may be specified in a register eg. (R5). Value Equate Length Description 21 CFD_INT128 16 binary 22 CFD_EH 4 short HFP 23 CFD_EB 4 short BFP 24 CFD_DH 8 long HFP 25 CFD_DB 8 long BFP 26 CFD_LH 16 extended HFP 27 CFD_LB 16 extended BFP 28 CFD_DD 8 long DFP 29 CFD_ED 4 short DFP 30 CFD_LD 16 extended DFP IN= The input field may be specified as a label or a register pointer eg. (R4). The input field must be in ASCII if the ASCII option is used, otherwise EBCDIC. The input field is always 45 bytes, and has the following format in this sequence: output field condition Optional preceding blanks - If the value is negative n...n Digits preceding the decimal point. . Decimal point if there are decimal positions n...n Digits following the decimal point if the value is not a whole number E Indicates an exponent follows - Indicates a negative exponent nnnn The exponent value, 1-4 digits For CFD_INT128, all correct forms are accepted and any decimal places are discarded: 129E-1 = 12 OUT= The output field may be specified as a label, a register pointer eg. OUT=(R4) or a register eg. OUT=R4 For some types, output to a register implies the use of a register pair as follows: Value Equate Register specified 21 CTD_INT128 Any even general register, input is from the even/odd pair. 22 CTD_EH Any floating point register. 23 CTD_EB Any floating point register. 24 CTD_DH Any floating point register. 25 CTD_DB Any floating point register. 28 CTD_DD Any floating point register. 29 CTD_ED Any floating point register. 26 CTD_LH The first floating point register of a valid pair, input is from the the register pair. 27 CTD_LB The first floating point register of a valid pair, input is from the the register pair. 30 CTD_LD The first floating point register of a valid pair, input is from the the register pair. LINKAGE= SVC (default) invokes SVC 171 CALL generates a CALL to module FPCONMFC Register Usage R1 = Parameter list R14 = Subroutine call R15 = Subroutine address and return code Return GR15 has a return code: 0 - CFD ok 8 - Invalid data address 12 - invalid input data or number too large for format type GETENV - Get environment variable Get an environment variable from the OS command environment. GETENV extracts the string in a program. name GETENV setname name GETENV (reg) Parameters setname setname is the label of a null terminated string or the string can be pointed to by reg. SETNAME DC C'MYDATA',X'00' GETENV acquires a storage area for the variable and sets the address in GR2. The string is terminated with X'00'. Register Usage R0 = Function code R1 = setname pointer R2 = Address of variable R15 = Return code Return GR15 has a return code: 0 - GETENV ok 4 - setname is null 8 - variable is null COMRG - Comm region addressability Note VSE only Establish addressability to the Communications region in the ZCVT. COMRG REG=(reg) If REG is omitted it defaults to GR1. It is the users responsibility to provide a DSECT to map the COMRG. Register Usage R1 = Address the ZCVT reg used in REG parm. Time periods ms - milliseconds 0.001 seconds (one thousandth) \u00b5s - microseconds 0.000001 seconds (one millionth) ns - nanoseconds 0.000000001 seconds (one billionth) Event Control Block Bits 0-1 00 - The initial state. WAIT requires both these bits to be zero. 10 - When the WAIT macro is issued for the ECB, this wait bit is set and the program enters the wait state. 01 - Set to this state internally or by the POST macro indicates that the event is complete or that the task in a wait state is to be resumed. It is valid to test for this state using a bit test instruction like TM. 11 Invalid. Bits 2-31 Completion code, set internally or by the POST macro.","title":"SVC services"},{"location":"reference/svc_services/#svc-services","text":"","title":"SVC services"},{"location":"reference/svc_services/#svc-functions","text":"DEC HEX Service 1 01 WAIT 2 02 POST 11 0B TIME(and date) 11 0B GETIME (VSE) 40 28 GETENV 46 2E TTIMER 47 2F STIMER 52 34 CMDPROC 53 35 WTO 103 67 XLATE 160 A0 WTOR 170 AA CTD 171 AB CFD","title":"SVC functions"},{"location":"reference/svc_services/#supporting-macros","text":"COMRG - Address Communications region (VSE)","title":"Supporting Macros"},{"location":"reference/svc_services/#macro-reference","text":"","title":"Macro reference"},{"location":"reference/svc_services/#time-svc","text":"name TIME type,addr,LINKAGE=SVC,DATETYPE=,CLOCKTYPE= Obtain the time and/or date in various formats.","title":"TIME(SVC) - Obtain the time and date"},{"location":"reference/svc_services/#time-system","text":"name TIME type,addr,LINKAGE=SYSTEM,DATETYPE=,CLOCKTYPE=","title":"TIME(SYSTEM) - Obtain the time and date"},{"location":"reference/svc_services/#gettime","text":"GETIME type Obtain the time in various formats (VSE only). The time is stored in the GR0/GR1 register pair.","title":"GETIME - Obtain time and date (VSE)"},{"location":"reference/svc_services/#stimer","text":"Wait for an interval of time. name STIMER WAIT,BINTVL=label name STIMER WAIT,DINTVL=label name STIMER WAIT,MICVL=label name STIMER WAIT,TUINTVL=label Start a timer and continue. When the time expires the exit routine is invoked. name STIMER REAL,exit,BINTVL=label name STIMER REAL,exit,DINTVL=label name STIMER REAL,exit,MICVL=label name STIMER REAL,exit,TUINTVL=label Only one STIMER can be waiting for expiry at any moment. In each case the label points to a number of timer units. value effect Maximum value BINTVL Fullword with 100 th of a second units. X'7FFFFFFF' is approx. 249 days. DINTVL Doubleword PL8'HHMMSSth', where th is 2 decimal positions of seconds. 99595999, approximately 4 days. MICVL Doubleword with microsecond units X'7FFFFFFFFFFFFFFF', or nearly 300000 years TUINTVL Fullword with 26.04166\u00b5s units X'7FFFFFFF', approximately 16 hours.","title":"STIMER - Wait for an interval of time"},{"location":"reference/svc_services/#ttimer","text":"Test or cancel a previously set STIMER REAL name TTIMER CANCEL,type,addr","title":"TTIMER - Test or cancel STIMER REAL"},{"location":"reference/svc_services/#cmdproc","text":"Open, close, read and write from the host command processor or shell. With the CMDPROC macro, you can issue OS shell commands, receive the replies from those commands line by line and start other programs. There is a limit of 10 command processors that can be open at any time. The limit is only to protect the operating system from storage depletion. In all cases below, ID may be defined as a numeric value or in a general register. For example, ID=2 or ID=(R5).","title":"CMDPROC - execute host OS commands"},{"location":"reference/svc_services/#wto","text":"Display a message on the GUI console. The record descriptor word (RDW) defines the variable length text message generated by the WTO macro. DC AL2(len,0),C'text' len includes the 4 bytes for the RDW.","title":"WTO - Write to operator"},{"location":"reference/svc_services/#xlate","text":"name XLATE area,len,TO= Translates data to EBCDIC or ASCII.","title":"XLATE - EBCDIC to ASCII"},{"location":"reference/svc_services/#wtor","text":"Display a message on the GUI console and receive a response. name WTOR 'text',reply,len,ecb name WTOR \"text\",reply,len,ecb The RDW (see WTO) that describes the message is generated internally. The text appears on the console.","title":"WTOR - Write to operator"},{"location":"reference/svc_services/#wait","text":"name WAIT num,ECB= name WAIT num,ECBLIST= ECB or ECBLIST must be specified.","title":"WAIT - Wait for ECB completion"},{"location":"reference/svc_services/#post","text":"Signal the completion of one ECB. name POST ecb,code","title":"POST - Signal ECB completion"},{"location":"reference/svc_services/#ctd","text":"name CTD type,IN=input,OUT=output,LINKAGE= Convert a binary or floating point value to a printable format.","title":"CTD - Convert binary or FP value"},{"location":"reference/svc_services/#cfd","text":"Convert a printable format number to a binary or floating point value. name CFD type,IN=input,OUT=output,LINKAGE=","title":"CFD - Convert to binary or FP value"},{"location":"reference/svc_services/#getenv","text":"Get an environment variable from the OS command environment. GETENV extracts the string in a program. name GETENV setname name GETENV (reg)","title":"GETENV - Get environment variable"},{"location":"reference/svc_services/#comrg","text":"Note VSE only Establish addressability to the Communications region in the ZCVT. COMRG REG=(reg) If REG is omitted it defaults to GR1. It is the users responsibility to provide a DSECT to map the COMRG.","title":"COMRG - Comm region addressability"},{"location":"reference/svc_services/#time-periods","text":"ms - milliseconds 0.001 seconds (one thousandth) \u00b5s - microseconds 0.000001 seconds (one millionth) ns - nanoseconds 0.000000001 seconds (one billionth)","title":"Time periods"},{"location":"reference/svc_services/#event-control-block","text":"","title":"Event Control Block"},{"location":"reference/svc_services/#bits-0-1","text":"00 - The initial state. WAIT requires both these bits to be zero. 10 - When the WAIT macro is issued for the ECB, this wait bit is set and the program enters the wait state. 01 - Set to this state internally or by the POST macro indicates that the event is complete or that the task in a wait state is to be resumed. It is valid to test for this state using a bit test instruction like TM. 11 Invalid.","title":"Bits 0-1"},{"location":"reference/svc_services/#bits-2-31","text":"Completion code, set internally or by the POST macro.","title":"Bits 2-31"},{"location":"reference/vsam_file_services/","text":"zVSAM services With the exception of the DDNAME parameter explained below, all supported parameters are implemented compatibly with IBM's VSAM implementation. For details, please refer to z/OS DFSMS Macro Instructions for Data Sets (SC23-6852-02) . Macro reference ACB - Access control block label ACB AM=VSAM, X DDNAME=ddname, X PASSWD=ptr, X EXLST=ptr, X MACRF=(keyword list), X BUFSP=nr, X BUFND=nr, X BUFNI=nr, X RMODE31=keyword, X STRNO=1, X BSTRNO=nr, X MAREA=ptr, X MLEN=nr, X RLSREAD=keyword, X SHRPOOL=nr The ACB macro will generate an ACB and initialize it according to the parameters specified on the macro invocation. Direct access to subfields in the ACB is discouraged. Use SHOWCB ACB=, TESTCB ACB= and/or MODCB ACB= to inspect, test, and/or modify the ACB's content. All keywords on the ACB macro are optional. Before the cluster is opened, all ACB values can be modified using MODCB ACB=, or by changing the ACB directly. The latter is not recommended, as it is not guaranteed to be portable or compatible with future versions of zVSAM. Parameters AM - Access method Designates this ACB as a zVSAM ACB. DDNAME - Data name DDNAME refers to the name of an environment variable in the host OS. This variable in turn should contain the path and qualified filename of the cluster to be opened. The qualifier is the name of an environment variable in the host OS and is the path to the assembled catalog. SET ddname=drive:\\path\\catalog.filename SET catalog=drive:\\path Warning The ddname variable may only contain one dot PASSWD - Password pointer Pointer to password for the cluster. Points to a single byte length followed by the password. X'05',C'ABCDE' EXLST - Exit list pointer Pointer to an exit list. See EXLST macro for more details. MACRF - Processing options A list of keywords is provided. MACRF=(KEY,DIR) Keyword group Keyword Description [ADR, KEY, CNV] ADR Addressed access to ESDS by (X)RBA. Using (X)RBA to access a KSDS is not supported. KEY Keyed access to a KSDS. RRN access to an RRDS. CNV Not supported. Keyword is flagged with a warning message. [DFR | NDF] DFR Allow writes to be deferred NDF Do not defer writes [DIR, SEQ, SKP] DIR Direct access to ESDS, KSDS or RRDS SEQ Sequential access to ESDS, KSDS or RRDS SKP Skip sequential access to KSDS or RRDS. Only for keyed access. Allows the use of POINT. [IN, OUT] IN Read only access for ESDS, KSDS or RRDS OUT Both read and write access for ESDS, KSDS or RRDS [NIS | SIS] NIS Normal Insert Strategy for KSDS SIS Sequential Insert Strategy for KSDS [NRM | AIX] NRM DDNAME indicates cluster to be processed AIX DDNAME of a path to access an AIX directly, rather than using it to access records in the underlying base cluster. [NRS | RST] Not supported. Keyword is flagged with a warning message [LSR | GSR | NSR | RLS] Local, Global or no Shared Buffers. RLS is not supported [NUB | UBF] Not supported. Keyword is flagged with a warning message [CFX | NFX] Not supported. Keyword is flagged with a warning message [DDN | DSN] Not supported. Keyword is flagged with a warning message [ICI | NCI] Not supported. Keyword is flagged with a warning message [LEW | NLW] Not supported. Keyword is flagged with a warning message BUFSP - Buffer storage Max amount of storage (in bytes) to use for buffers. Maximum buffer space in virtual storage for this cluster. This is the combined size in bytes of all buffers allocated for this cluster. If (BUFND + BUFNI) * Block_size exceeds the value specified for BUFSP, then BUFND and BUFNI will be reduced proportionally to keep the total allocation below the limit specified in the BUFSP parameter. BUFND - Data buffers Number of data buffers to allocate for this ACB. Specify a number between 1 and 65535. BUFNI - Index buffers Number of index buffers to allocate for this ACB. Specify a number between 1 and 65535. RMODE31 - Above the line storage usage The default value for RMODE31 is NONE. Specifies whether buffers and/or control blocks should be allocated below or above the 16M line: option effect NONE Control Blocks and buffers below 16M CB Control Blocks above or below 16M, buffers below 16M BUFF Control Blocks below 16M, buffers above or below 16M ALL Control Blocks and buffers above 16M or below 16M STRNO - Concurrent requests Number of concurrent requests allowable for this ACB. Specify a number between 1 and 255. BSTRNO - Initial allocated requests Beginning number of concurrent requests allocated to this ACB when a path is opened. Only applies if MACRF=NSR. Specify a number between 0 and 255. Unsupported options The following options are currently not supported. If used, the keyword is flagged as ignored with a warning message. MAREA MLEN RLSREAD SHRPOOL OPEN - Open cluster label OPEN (entry[,entry]...), MODE=, MF=, The open macro is used to open one or more clusters and/or one or more sequential files in a single call. A cluster needs to be opened before it can be processed. Parameters entry - ACB/DCB address addr[,options],[...] The OPEN macro accepts a list of entries. Each entry consists of two consecutive parameters, address and options. addr - Address of ACB or DCB The address can be specified as an A-type address or as a register. If a register is coded the register number or name must be enclosed in parentheses. The address can be either the address of a DCB or the address of an ACB options For DCB, options may be encoded according to the z390 File Services . For ACB, options list is ignored and should be coded as an omitted parameter. For ACB's, all options are taken from the ACB, not the open parm list. Open parameter list entries have two different formats depending on the MODE parameter. MODE=24 AL1(option),AL3(DCB/ACB address) R1 points to the list. MODE=31 AL1(option),XL3'00',AL4(DCB/ACB address) R0 points to the list and R1=0. Available option values: INPUT - X'40' OUTPUT - X'20' UPDATE - X'60' The last entry has the X'80' bit on in option. MF - Parm Available options: option effect MF=I or omitted An open parmlist is generated inline, plus a call to the OPEN SVC using the parmlist. MF=L An open parmlist is generated inline. MF=(E,addr) Code to modify/populate the open parameter list at the indicated address, which may be a relocatable constant or a (register), plus a call to the OPEN SVC using the parmlist. MODE - Residence mode Residency mode of all control blocks involved. MODE=24 - Use below the line only MODE=31 (Default) - if any resides above the line. EXLST - Exit list control block label EXLST AM=VSAM, EODAD=(addr[,mod]), LERAD=(addr[,mod]), SYNAD=(addr[,mod]), JRNAD=(addr[,mod]), UPAD=(addr[,mod]), RLSWAIT=(addr[,mod]) The EXLST macro will generate an exit list control block and initialize it according to the parameters specified on the macro invocation. Info The structure and layout of the generated EXLST are not part of the interface and are therefore not shown. Direct access to subfields in the EXLST is discouraged. Use SHOWCB EXLST=, TESTCB EXLST= and/or MODCB EXLST= to inspect, test, and/or modify the EXLST's content. All keywords on the EXLST macro are optional. Before the cluster is opened, all EXLST values can be modified using MODCB EXLST= , or by changing the EXLST directly. The latter is not recommended, as it is not guaranteed to be portable or compatible with future versions of zVSAM. The AMODE for the exit routines is encoded in the address using the common convention. For exit modifiers, if a routine is not active it will not be called by zVSAM. The secondary modifier of L (for Load from linklib) is not currently supported. Parameters AM - Access method AM=VSAM - Designates this EXLST as a zVSAM EXLST. EODAD - End of data exit EODAD=(addr[,mod]) addr - entry address Optional parameter to specify the entry address of an exit that handles an end-of-data condition during sequential access. mod - modifier A - Active N - Not active As long as the routine is not active it will not be called by zVSAM. The secondary modifier of L (for Load from linklib) is not currently supported. LERAD - Logical error analysis exit LERAD=(addr[,mod]) addr - entry address Entry address of an exit routine that handles logic errors. The AMODE for the routine is encoded in the address using the common convention. mod - modifier A - Active N - Not active As long as the routine is not active it will not be called by zVSAM. The secondary modifier of L (for Load from linklib) is not currently supported. SYNAD - Physical error analysis exit SYNAD=(addr[,mod]) addr - entry address Optional parameter to specify the entry address of an exit that handles physical errors. mod - modifier A - Active N - Not-active CLOSE - Close cluster RPL - Request parameter list POINT GET PUT ERASE CHECK ENDREQ VERIFY GENCB - Generate control block MODCB - Modify control block TESTCB - Test control block SHOWCB - Show control block","title":"zVSAM services"},{"location":"reference/vsam_file_services/#zvsam-services","text":"With the exception of the DDNAME parameter explained below, all supported parameters are implemented compatibly with IBM's VSAM implementation. For details, please refer to z/OS DFSMS Macro Instructions for Data Sets (SC23-6852-02) .","title":"zVSAM services"},{"location":"reference/vsam_file_services/#macro-reference","text":"","title":"Macro reference"},{"location":"reference/vsam_file_services/#acb-access-control-block","text":"label ACB AM=VSAM, X DDNAME=ddname, X PASSWD=ptr, X EXLST=ptr, X MACRF=(keyword list), X BUFSP=nr, X BUFND=nr, X BUFNI=nr, X RMODE31=keyword, X STRNO=1, X BSTRNO=nr, X MAREA=ptr, X MLEN=nr, X RLSREAD=keyword, X SHRPOOL=nr The ACB macro will generate an ACB and initialize it according to the parameters specified on the macro invocation. Direct access to subfields in the ACB is discouraged. Use SHOWCB ACB=, TESTCB ACB= and/or MODCB ACB= to inspect, test, and/or modify the ACB's content. All keywords on the ACB macro are optional. Before the cluster is opened, all ACB values can be modified using MODCB ACB=, or by changing the ACB directly. The latter is not recommended, as it is not guaranteed to be portable or compatible with future versions of zVSAM.","title":"ACB - Access control block"},{"location":"reference/vsam_file_services/#open-open-cluster","text":"label OPEN (entry[,entry]...), MODE=, MF=, The open macro is used to open one or more clusters and/or one or more sequential files in a single call. A cluster needs to be opened before it can be processed.","title":"OPEN - Open cluster"},{"location":"reference/vsam_file_services/#exlst-exit-list-control-block","text":"label EXLST AM=VSAM, EODAD=(addr[,mod]), LERAD=(addr[,mod]), SYNAD=(addr[,mod]), JRNAD=(addr[,mod]), UPAD=(addr[,mod]), RLSWAIT=(addr[,mod]) The EXLST macro will generate an exit list control block and initialize it according to the parameters specified on the macro invocation. Info The structure and layout of the generated EXLST are not part of the interface and are therefore not shown. Direct access to subfields in the EXLST is discouraged. Use SHOWCB EXLST=, TESTCB EXLST= and/or MODCB EXLST= to inspect, test, and/or modify the EXLST's content. All keywords on the EXLST macro are optional. Before the cluster is opened, all EXLST values can be modified using MODCB EXLST= , or by changing the EXLST directly. The latter is not recommended, as it is not guaranteed to be portable or compatible with future versions of zVSAM. The AMODE for the exit routines is encoded in the address using the common convention. For exit modifiers, if a routine is not active it will not be called by zVSAM. The secondary modifier of L (for Load from linklib) is not currently supported.","title":"EXLST - Exit list control block"},{"location":"reference/vsam_file_services/#close-close-cluster","text":"","title":"CLOSE - Close cluster"},{"location":"reference/vsam_file_services/#rpl-request-parameter-list","text":"","title":"RPL - Request parameter list"},{"location":"reference/vsam_file_services/#point","text":"","title":"POINT"},{"location":"reference/vsam_file_services/#get","text":"","title":"GET"},{"location":"reference/vsam_file_services/#put","text":"","title":"PUT"},{"location":"reference/vsam_file_services/#erase","text":"","title":"ERASE"},{"location":"reference/vsam_file_services/#check","text":"","title":"CHECK"},{"location":"reference/vsam_file_services/#endreq","text":"","title":"ENDREQ"},{"location":"reference/vsam_file_services/#verify","text":"","title":"VERIFY"},{"location":"reference/vsam_file_services/#gencb-generate-control-block","text":"","title":"GENCB - Generate control block"},{"location":"reference/vsam_file_services/#modcb-modify-control-block","text":"","title":"MODCB - Modify control block"},{"location":"reference/vsam_file_services/#testcb-test-control-block","text":"","title":"TESTCB - Test control block"},{"location":"reference/vsam_file_services/#showcb-show-control-block","text":"","title":"SHOWCB - Show control block"},{"location":"reference/zCOBOL_NIST_COBOL_1985_Test_Results/","text":"Macro Syntax Error File : reference/zCOBOL_NIST_COBOL_1985_Test_Results.md Line 708 in Markdown file: Missing end of comment tag ## Trademarks {#Trademarks}","title":"Macro Syntax Error"},{"location":"reference/zCOBOL_NIST_COBOL_1985_Test_Results/#macro-syntax-error","text":"File : reference/zCOBOL_NIST_COBOL_1985_Test_Results.md Line 708 in Markdown file: Missing end of comment tag ## Trademarks {#Trademarks}","title":"Macro Syntax Error"},{"location":"reference/zCOBOL_System_Programmer_Guide/","text":"Macro Syntax Error File : reference/zCOBOL_System_Programmer_Guide.md Line 261 in Markdown file: Missing end of comment tag ## Trademarks {#Trademarks}","title":"Macro Syntax Error"},{"location":"reference/zCOBOL_System_Programmer_Guide/#macro-syntax-error","text":"File : reference/zCOBOL_System_Programmer_Guide.md Line 261 in Markdown file: Missing end of comment tag ## Trademarks {#Trademarks}","title":"Macro Syntax Error"},{"location":"reference/zpar/","text":"zPAR and zPARTRS zPAR - z390 and zCOBOL Program Analysis Reports zPARTRS - Source Execution Trace Utility http://www.z390.info/zpar/ ZPAR - z390 and zcobol Program Analysis Reports ZPARTRS Source Execution Trace Utility ZPARTRS - Trace Source COBOL, Assembler, and EXEC CICS Execution Report ZPARTRS can be used to generate a z390 COBOL, Assembler, and EXEC CICS source code execution trace report from an existing z390 instruction execution TRE trace file and the associated program LST and PRN files. zpar\\ZPARTRS dir\\pgm options - trace command for zcobol and z390 assembler dir\\pgm - the name and optional directory path of the TRE execution trace file must be the first user parameter passed to ZPARTRS.BAT. The output trace file will be dir\\pgm.TRS with trace and any error messages. Options - up to 8 additional options separated by spaces can follow the dir\\pgm parameter: Option Description ASM/NOASM trace assembler program source statements (default is ASM). (Note this ZPARTRS option to turn ASM source tracing on or off is different from the z390 NOASM option specified in the ZPARTRS.OPT file to suppress assembly and only execute the conditional macro code in ZPARTRS.MLC.) CBL/NOCBL trace zcobol source program statements (default is CBL) DETAIL/NODETAIL include both the TRE instruction trace with operand values and the corresponding source assembler program instruction line with operand names and comments (the default is NODETAIL to only include the assembler source line with PSW and CC) EXCLUDE(pgm1+pgm2+pgmn) list of program modules to exclude from trace (examples include EXCLUDE(DISPLAY) to suppress tracing of the COBOL DISPLAY support module. Only the code to generate parameter list and call will be generated.) INCLUDE(pgm1+pgm2+pgmn) list of program modules to include in source trace (the default is to only include the first program loaded in the TRE trace if no INCLUDE parameter is included). LOADLIB(path) define optional path for all LST and PRN files. The default is to use the path in the TRE trace loads for LST files and use the LST include paths for PRN files. This is useful if you want to save a trace and associated source files seprate from normal execution environment. NOMSG exclude all messages such as WTO, TRACE and error messages (default is to include all messages from included source modules. The trace also shows single line .... with count of skipped instructions and messages). NOTIME exclude any time-stamps found in TRE file (default is to include them) Examples Example EXEC CICS, COBOL, and Assembler source traces for the following: DEMO.MLC - Assembler WTO \"Hello World\" demo program. ASMLG demo\\DEMO TRACE generates demo\\DEMO.TRE trace file for assembler demo program with WTO 'Hello World' zpar\\ZPARTRS demo\\DEMO NOTIME generate assembler source trace in demo\\DEMO.TRS. zpar\\ZPARTRS demo\\DEMO DETAIL NOTIME generate detail assembler trace including both the TRE instruction operand values and the assembler source lines in demo\\DEMO.TRS. HELLO.CBL - COBOL program with DISPLAY \"Hello World\". CBLCLG zcobol\\demo\\HELLO TRACE(E) generates zcobol\\demo\\HELLO.TRE trace file. zpar\\ZPARTRS zcobol\\demo\\HELLO NOTIME NOASM generate COBOL only source trace in zcobol\\demo\\HELLO.TRS. zpar\\ZPARTRS zcobol\\demo\\HELLO NOTIME generate COBOL and assembler source trace in zcobol\\demo\\HELLO.TRS zpar\\ZPARTRC zcobol\\demo\\HELLO NOTIME DETAIL generate COBOL and detail assembler trace with both TRE and assembler source in zcobol\\demo\\HELLO.TRS. TESTGUI6.MLC - Assembler EXEC CICS transaction program with form to enter name, address, and zip. cics\\Z390CICG starts zCICS session using local terminal with client side trace turned on in cics\\Z390CICS.INI file. The commands entered for the TESTGUI6 trace were CLEAR,GUI6,don,tab,9057 Waterash, tab, 33782, enter, F3, clear, CEMT P SHUT . ZPAR\\ZPARTRS cics\\DON0 INCLUDE(TESTGUI6) NOMSG NOTIME (command for trace of assembler EXEC CICS TESTGUI6.MLC assembler transaction source program lines executed during session. The assembler EXEC CICS source statements appear as ECA= type messages with line breaks.) ZPAR\\ZPARTRS cics\\DON0 INCLUDE(TESTGUI6) DETAIL NOMSG NOTIME (command for detail trace of assembler EXEC CICS TESTGUI6.MLC assembler transaction source program lines executed during session. The original TRE lines with operand hex values are followed by assembler source lines with labels and comments. The assembler EXEC CICS source statements appear as ECA= type messages with line breaks.) ZPAR\\ZPARTRS cics\\DON0 INCLUDE(TESTGUI6) NOASM NOMSG NOTIME (command for trace of just the assembler EXEC CICS statements in TESTGUI6.MLC assembler transaction source program lines executed during session. Note the use of NOASM suppresses ASM instructions and only the EXEC CICS assembler statements are traced. The assembler EXEC CICS source statements appear as ECA= type messages with line breaks.) TESTBEC1.CBL - EXEC CICS COBOL program to display lines of text at prompt. The screen capture following execution of BEC1 transaction. ZPAR\\ZPARTRS cics\\DON0 INCLUDE(TESTBEC1) NOASM NOMSG NOTIME - generate trace of COBOL source program lines executed during session. ZPAR\\ZPARTRS cics\\DON0 INCLUDE(TESTBEC1) NOMSG NOTIME - generate trace of COBOL and assembler source program lines executed during session. ZPARTRS User Guide The program zpar\\ZPARTRS.MLC reads the linker listing LST file for every z390 load module executed in the trace via LINK, LOAD, or XCTL in order to find the PRN file for every included module in each load module. If LOADLIB(path) is specified, all the LST and PRN files will be loaded from that directory otherwise the LST files will be loaded from path specified in the TRE trace for each LOAD svc, and the PRN files will be loaded from the path specified on the INCLUDE statements in each LST file. If no INCLUDE option is specified, the first loaded program is the only program source traced. The source code for each statically linked PRN is loaded into memory and cross referenced to the PSW-ADDR corresponding to current load address using HLASM created macro variables which store source code by PSW address name. Note the same source program may be loaded multiple times at different addresses during execution. The output source trace file is created with same path and name as TRE file but with suffix TRS. If no corresponding PRN source line is found when generating all assembler, the original TRE instruction trace line with opcode and operands is generated instead as message. This can occur due to missing LST or PRN files or due to generation of instructions using DC hex values for multiple instructions, use of ORG to overlay instructions, etc. Source assembler lines PSW-ADDR - instruction PSW trace address with high bit indicating 31 or 24 bit AMODE from TRE file PSW-CC - condition code at start of instruction from TRE file MODULE-NAME - source module name included in 390 load module (case sensitive) MOD-ADDR - relative module address from PRN listing LINE - source assembler line with comments Source COBOL lines LINE # - line number of source statement MOD_NAME - source module name included in 390 load module (case sensitive) LINE - COBOL or EXEC CICS source line with comments (note assembler EXEC CICS lines show up as ECA= instead of CBL=) ZPARTRS Debugging Tips on debugging problems with ZPARTRS: The generated TRS file contains all the generated error messages starting with ERR=. These messages also appear on the zpar\\zpartrs.err log as mnotes with 4, 8, or 16 error level. The total error count and max level is displayed at end of report. The zpartrs return code is set to highest MNOTE error level. The file zpar\\ZPARTRS.OPT contains default options. You can turn on TRACEM to generate apar\\ZPARTRS.TRM trace file to help debug any conditional macro errors occurring. Note this really slows down the execution so cut down test TRE files are best. INCLUDE and EXCLUDE are mutually exclusive so only specify one or the other. If no source code is found in an included PRN file, an error is generated. This can occur if the PRN listing has PRINT NOGEN or PRINT OFF. ZPARTRS is dependent on PRN file containing source code listing with zcobol statement comments (*ZC) and/or assembler instruction listing. ZPARTRS source components The source code for the 3 files requires to run ZPARTRS are here: ZPARTRS.MLC - structured conditional macro assembler source program ZPARTRS.BAT = batch command with up to 9 user parameters ZPARTRS.OPT - default options for execution of ZPARTRS referenced by BAT file","title":"zPAR and zPARTRS"},{"location":"reference/zpar/#zpar-and-zpartrs","text":"zPAR - z390 and zCOBOL Program Analysis Reports zPARTRS - Source Execution Trace Utility http://www.z390.info/zpar/ ZPAR - z390 and zcobol Program Analysis Reports ZPARTRS Source Execution Trace Utility","title":"zPAR and zPARTRS"},{"location":"reference/zpar/#zpartrs-trace-source-cobol-assembler-and-exec-cics-execution-report","text":"ZPARTRS can be used to generate a z390 COBOL, Assembler, and EXEC CICS source code execution trace report from an existing z390 instruction execution TRE trace file and the associated program LST and PRN files. zpar\\ZPARTRS dir\\pgm options - trace command for zcobol and z390 assembler dir\\pgm - the name and optional directory path of the TRE execution trace file must be the first user parameter passed to ZPARTRS.BAT. The output trace file will be dir\\pgm.TRS with trace and any error messages. Options - up to 8 additional options separated by spaces can follow the dir\\pgm parameter: Option Description ASM/NOASM trace assembler program source statements (default is ASM). (Note this ZPARTRS option to turn ASM source tracing on or off is different from the z390 NOASM option specified in the ZPARTRS.OPT file to suppress assembly and only execute the conditional macro code in ZPARTRS.MLC.) CBL/NOCBL trace zcobol source program statements (default is CBL) DETAIL/NODETAIL include both the TRE instruction trace with operand values and the corresponding source assembler program instruction line with operand names and comments (the default is NODETAIL to only include the assembler source line with PSW and CC) EXCLUDE(pgm1+pgm2+pgmn) list of program modules to exclude from trace (examples include EXCLUDE(DISPLAY) to suppress tracing of the COBOL DISPLAY support module. Only the code to generate parameter list and call will be generated.) INCLUDE(pgm1+pgm2+pgmn) list of program modules to include in source trace (the default is to only include the first program loaded in the TRE trace if no INCLUDE parameter is included). LOADLIB(path) define optional path for all LST and PRN files. The default is to use the path in the TRE trace loads for LST files and use the LST include paths for PRN files. This is useful if you want to save a trace and associated source files seprate from normal execution environment. NOMSG exclude all messages such as WTO, TRACE and error messages (default is to include all messages from included source modules. The trace also shows single line .... with count of skipped instructions and messages). NOTIME exclude any time-stamps found in TRE file (default is to include them)","title":"ZPARTRS - Trace Source COBOL, Assembler, and EXEC CICS Execution Report"},{"location":"reference/zpar/#examples","text":"Example EXEC CICS, COBOL, and Assembler source traces for the following:","title":"Examples"},{"location":"reference/zpar/#zpartrs-user-guide","text":"The program zpar\\ZPARTRS.MLC reads the linker listing LST file for every z390 load module executed in the trace via LINK, LOAD, or XCTL in order to find the PRN file for every included module in each load module. If LOADLIB(path) is specified, all the LST and PRN files will be loaded from that directory otherwise the LST files will be loaded from path specified in the TRE trace for each LOAD svc, and the PRN files will be loaded from the path specified on the INCLUDE statements in each LST file. If no INCLUDE option is specified, the first loaded program is the only program source traced. The source code for each statically linked PRN is loaded into memory and cross referenced to the PSW-ADDR corresponding to current load address using HLASM created macro variables which store source code by PSW address name. Note the same source program may be loaded multiple times at different addresses during execution. The output source trace file is created with same path and name as TRE file but with suffix TRS. If no corresponding PRN source line is found when generating all assembler, the original TRE instruction trace line with opcode and operands is generated instead as message. This can occur due to missing LST or PRN files or due to generation of instructions using DC hex values for multiple instructions, use of ORG to overlay instructions, etc.","title":"ZPARTRS User Guide"},{"location":"reference/zpar/#source-assembler-lines","text":"PSW-ADDR - instruction PSW trace address with high bit indicating 31 or 24 bit AMODE from TRE file PSW-CC - condition code at start of instruction from TRE file MODULE-NAME - source module name included in 390 load module (case sensitive) MOD-ADDR - relative module address from PRN listing LINE - source assembler line with comments","title":"Source assembler lines"},{"location":"reference/zpar/#source-cobol-lines","text":"LINE # - line number of source statement MOD_NAME - source module name included in 390 load module (case sensitive) LINE - COBOL or EXEC CICS source line with comments (note assembler EXEC CICS lines show up as ECA= instead of CBL=)","title":"Source COBOL lines"},{"location":"reference/zpar/#zpartrs-debugging","text":"Tips on debugging problems with ZPARTRS: The generated TRS file contains all the generated error messages starting with ERR=. These messages also appear on the zpar\\zpartrs.err log as mnotes with 4, 8, or 16 error level. The total error count and max level is displayed at end of report. The zpartrs return code is set to highest MNOTE error level. The file zpar\\ZPARTRS.OPT contains default options. You can turn on TRACEM to generate apar\\ZPARTRS.TRM trace file to help debug any conditional macro errors occurring. Note this really slows down the execution so cut down test TRE files are best. INCLUDE and EXCLUDE are mutually exclusive so only specify one or the other. If no source code is found in an included PRN file, an error is generated. This can occur if the PRN listing has PRINT NOGEN or PRINT OFF. ZPARTRS is dependent on PRN file containing source code listing with zcobol statement comments (*ZC) and/or assembler instruction listing.","title":"ZPARTRS Debugging"},{"location":"reference/zpar/#zpartrs-source-components","text":"The source code for the 3 files requires to run ZPARTRS are here: ZPARTRS.MLC - structured conditional macro assembler source program ZPARTRS.BAT = batch command with up to 9 user parameters ZPARTRS.OPT - default options for execution of ZPARTRS referenced by BAT file","title":"ZPARTRS source components"},{"location":"user_guide/z390/commands/","text":"Commands The following is a list of commands available as part of the z390 toolkit. These commands are scripts that are included in the z390 source and distribution and can be enabled by including the script directory in your system path. Alternatively you can reference the scripts directly from the command line by specifying the full path. Windows (z390 install dir)\\bat MacOS/Unix (z390 install dir)/bash Command reference z390 Start the GUI interface with optional startup command file input. mac Run mz390 macro processor to expand MLC macro source file to BAL assembler source file. asm Run mz390 and az390 assembler to expand MLC macro assembler source file and generate relocatable OBJ relocatable object file. Note The default object file format is binary 80 byte record mainframe compatible format. Use option OBJHEX for ASCII text format containing hex format for object code. The OBJHEX format supports single CSECT\u2019s over 16 MB and you can read the OBJ file for debugging purposes. See Z390 options for more details. asml Run mz390, az390, and lz390 to expand MLC macro assembler source, assemble, and link to generate 390 load module. asmlg Run mz390, az390, lz390 and ez390 to expand MLC macro source, assemble, link, and execute 390 load module. link Run lz390 linker to read one or more relocatable OBJ files and create binary relocatable 390 load module file. If the linker option AUTOLINK is on, the linker will search SYSLIB OBJ file directory for external references to be statically linked. See z390 options for more details. The linker includes options for AMODE and RMODE to control loading and execution modes. The linker also has optional input command file with suffix LKD which may contain explicit INCLUDE, ENTRY, ALIAS, and NAME commands. exec Run ez390 emulator to execute 390 load module. Interactive debugger The ez390 emulator supports the following interactive test commands when the TEST option is specified: addr=sdt \u2013 set memory value (i.e. 1r?=x'80' changes mem at (r1) 31 bit reg=sdt - set register value (i.e. 15r=8 changes reg 15 to 8) A addr \u2013 set or reset up to 100 instruction address stops with hex address or relative expression such as *+4 AR nn \u2013 display specified access register else all AR 0-15 B=addr - set base for rel addr (ie B=15r% sets base to (r15) 24 bit D \u2013 display DCB file information from TIOT E \u2013 toggle between EBCDIC and ASCII mode F nn \u2013 display floating point register else FPC and all FPR 0-15 FPC \u2013 display floating-point-control register FPC+ \u2013 display floating-point-control register in verbose mode G - nn/addr/opcode - exec nn instr. or until specified instruction address or opcode is found with no trace. One instruction is always executed before next opcode break even if it\u2019s the same instruction such as a BCT 1, . Addresses are distinguished from count by hex . or relative expression term such as , +, or -. H - list help command summary J addr - jump to new addr and trace instruction L - list all regs and trace current instruction L reg - list contents of register (ie l 1r dumps register 1 L addr len - list contents of memory area (ie l 10. 4 dumps cvt addr M \u2013 display total memory in MB and total allocate and free bytes P \u2013 display current loaded program information from CDE including name, entry and length PSW \u2013 display current PSW PSW+ \u2013 display current PSW in verbose mode PSW16 \u2013 display 16 byte current PSW Q - quit execution now R nn \u2013 display specified general purpose register else all GPR 0-15 S - clear register, address, and memory breaks S reg??sdt - set break on register change S addr??sdt - set break on memory change T nn/addr/opcode - trace nn instr. or until specified instruction address or opcode is found. One instruction is always executed before next opcode break even if it\u2019s the same instruction such as a BCT 1, . Addresses are distinguished from count by hex . or relative expression term such as , +, or -. The symbol EPA may be used in place of address to refer to last program load point address. V - validate/verify V * nn - validate nn bytes starting at PSW address V psw.subfield - validate PSW subfield V nnr - validate GPR nn Z - exit test and run to end of program without trace * addr = hex.,+-hex, *+-hex, dec, nnr% (24 bit), nnr? (31 bit) * reg = nnr where nn = 0-15 * sdt = self defining term (b'01',c'ab',f'1',h'2',x'ff') * ?? = break compare operator (=,!=,<,<=,>,>=)","title":"Commands"},{"location":"user_guide/z390/commands/#commands","text":"The following is a list of commands available as part of the z390 toolkit. These commands are scripts that are included in the z390 source and distribution and can be enabled by including the script directory in your system path. Alternatively you can reference the scripts directly from the command line by specifying the full path. Windows (z390 install dir)\\bat MacOS/Unix (z390 install dir)/bash","title":"Commands"},{"location":"user_guide/z390/commands/#command-reference","text":"","title":"Command reference"},{"location":"user_guide/z390/commands/#z390","text":"Start the GUI interface with optional startup command file input.","title":"z390"},{"location":"user_guide/z390/commands/#mac","text":"Run mz390 macro processor to expand MLC macro source file to BAL assembler source file.","title":"mac"},{"location":"user_guide/z390/commands/#asm","text":"Run mz390 and az390 assembler to expand MLC macro assembler source file and generate relocatable OBJ relocatable object file. Note The default object file format is binary 80 byte record mainframe compatible format. Use option OBJHEX for ASCII text format containing hex format for object code. The OBJHEX format supports single CSECT\u2019s over 16 MB and you can read the OBJ file for debugging purposes. See Z390 options for more details.","title":"asm"},{"location":"user_guide/z390/commands/#asml","text":"Run mz390, az390, and lz390 to expand MLC macro assembler source, assemble, and link to generate 390 load module.","title":"asml"},{"location":"user_guide/z390/commands/#asmlg","text":"Run mz390, az390, lz390 and ez390 to expand MLC macro source, assemble, link, and execute 390 load module.","title":"asmlg"},{"location":"user_guide/z390/commands/#link","text":"Run lz390 linker to read one or more relocatable OBJ files and create binary relocatable 390 load module file. If the linker option AUTOLINK is on, the linker will search SYSLIB OBJ file directory for external references to be statically linked. See z390 options for more details. The linker includes options for AMODE and RMODE to control loading and execution modes. The linker also has optional input command file with suffix LKD which may contain explicit INCLUDE, ENTRY, ALIAS, and NAME commands.","title":"link"},{"location":"user_guide/z390/commands/#exec","text":"Run ez390 emulator to execute 390 load module.","title":"exec"},{"location":"user_guide/z390/structured_macro/","text":"Structured Macro Extensions z390 has extended the HLASM macro syntax to add support for structured macro code. This is sometimes referred to as Structured Programming Extensions or SPE. Warning z390 structured macro extensions are not supported by IBM HLASM. You need to translate the macros from structured to standard first. Instructions Alternate selection of code blocks AIF (expression) - execute the following block of code if expression is true AELSEIF (expression) - end prior block and execute following block if expression is true AELSE - end prior block and execute following block if prior AIF and AELSEIF false AEND - end last block for AIF at current level of nesting Repeat execution of code block AWHILE (expression) - repeat following code block while expression is true (test at beginning) AEXIT AWHILE - exit to end of inner most AWHILE (for exceptions within nested AIF) AEND - end block of code for AWHILE at current level of nesting AUNTIL (expression) - repeat following code block until expression is true (test at end) AEXIT AUNTIL - exit to end of inner most AUNTIL (for exceptions within nested AIF) AEND - end block of code for AUNTIL at current level of nesting Perform code block ACALL name - call the named code block and return to next instruction AENTRY name - define start of performed block of code (skip over if entered sequentially) AEXIT AENTRY - exit from AENTRY block of code (for exceptions within nested AIF) AEND - end the current performed code block and exit to next statement after APM Perform selection of code blocks based on index from 0 to 255 ACASE (expression) - execute selected block based on value of index expression AWHEN values - define end of previous block and start of code block for index values values can be decimal (0-255), character C'?', or hex X'??' one or more values may be specified separated by commas a range of values may be specified as (value1,value2) for example AWHEN (C'0',C'9') defines EBCDIC digits 240-249 AEXIT ACASE - exit to end of current ACASE (for exceptions within nested AIF) AELSE - define optional code block if no AWHEN block defined for current index AEND - end code block for ACASE Additional extension to indent label field by preceding with colon (:) Translating to standard The following items are included for general use: zstrmac - script to convert macro to standard HLASM format bldzstrmacs - script to translate all the SPM's in z390\\mac directory to HLASM compatible format rt\\test\\ZSTRMAC2.ZSM - structured translator which can be translated to standard HLASM compatible code using itself. rt\\test\\ZSTRMAC1.MLC - bootstrap structured translator which is HLASM compatible. linklib\\zstrmac.txt - the generated HLASM compatible translator. Regression tests You can execute the regression tests by using the script runzstrmactests . The following regression test programs are included: rt\\test\\ZSTRMAC1.MLC - bootstrap version of translator written in standard HLASM. rt\\test\\ZSTRMAC2.ZSM - structured version of the translator which uses all the structures. rt\\test\\TESTSPE1.ZSM - test program for ZSTRMAC1 with all the basic structures. rt\\test\\TESTSPE2.ZSM - test program for ZSTRMAC2 with all the basic structures in lower case rt\\test\\TESTSPE3.ZSM - test of all 256 ACASE values using all forms of AWHEN operands rt\\test\\TESTSPE4.ZSM - test error messages rt\\test\\TESTSPM1.MLC - test program for structured programming macros Demo The following demo programs using the macro extensions are include: demo\\DEMOM8Q1.MLC - solve 8 queens chess problem suing recursive structured macro Utilities The following z390 utility programs using the macro extensions are included: linklib\\RTGENDIR.MLC - read file system directory and create list of file names linklib\\RTGENCMP.MLC - read merged list of files from 2 directories and generate compare commands linklib\\RTGENDIF.MLC - read difference files and generate erase commands for identical files The following system macros use the macro extensions: EQUREGS.MAC - generate EQU symbols if not already generated for GPR and FPR registers ZCLOSE.MAC - close files (called from CLOSE and other user macros in concatenated directories) ZOPEN.MAC - open files (called from OPEN and other user macros in concatenated directories)","title":"Structured Macro Extensions"},{"location":"user_guide/z390/structured_macro/#structured-macro-extensions","text":"z390 has extended the HLASM macro syntax to add support for structured macro code. This is sometimes referred to as Structured Programming Extensions or SPE. Warning z390 structured macro extensions are not supported by IBM HLASM. You need to translate the macros from structured to standard first.","title":"Structured Macro Extensions"},{"location":"user_guide/z390/structured_macro/#instructions","text":"","title":"Instructions"},{"location":"user_guide/z390/structured_macro/#alternate-selection-of-code-blocks","text":"AIF (expression) - execute the following block of code if expression is true AELSEIF (expression) - end prior block and execute following block if expression is true AELSE - end prior block and execute following block if prior AIF and AELSEIF false AEND - end last block for AIF at current level of nesting","title":"Alternate selection of code blocks"},{"location":"user_guide/z390/structured_macro/#repeat-execution-of-code-block","text":"AWHILE (expression) - repeat following code block while expression is true (test at beginning) AEXIT AWHILE - exit to end of inner most AWHILE (for exceptions within nested AIF) AEND - end block of code for AWHILE at current level of nesting AUNTIL (expression) - repeat following code block until expression is true (test at end) AEXIT AUNTIL - exit to end of inner most AUNTIL (for exceptions within nested AIF) AEND - end block of code for AUNTIL at current level of nesting","title":"Repeat execution of code block"},{"location":"user_guide/z390/structured_macro/#perform-code-block","text":"ACALL name - call the named code block and return to next instruction AENTRY name - define start of performed block of code (skip over if entered sequentially) AEXIT AENTRY - exit from AENTRY block of code (for exceptions within nested AIF) AEND - end the current performed code block and exit to next statement after APM","title":"Perform code block"},{"location":"user_guide/z390/structured_macro/#perform-selection-of-code-blocks-based-on-index-from-0-to-255","text":"ACASE (expression) - execute selected block based on value of index expression AWHEN values - define end of previous block and start of code block for index values values can be decimal (0-255), character C'?', or hex X'??' one or more values may be specified separated by commas a range of values may be specified as (value1,value2) for example AWHEN (C'0',C'9') defines EBCDIC digits 240-249 AEXIT ACASE - exit to end of current ACASE (for exceptions within nested AIF) AELSE - define optional code block if no AWHEN block defined for current index AEND - end code block for ACASE Additional extension to indent label field by preceding with colon (:)","title":"Perform selection of code blocks based on index from 0 to 255"},{"location":"user_guide/z390/structured_macro/#translating-to-standard","text":"The following items are included for general use: zstrmac - script to convert macro to standard HLASM format bldzstrmacs - script to translate all the SPM's in z390\\mac directory to HLASM compatible format rt\\test\\ZSTRMAC2.ZSM - structured translator which can be translated to standard HLASM compatible code using itself. rt\\test\\ZSTRMAC1.MLC - bootstrap structured translator which is HLASM compatible. linklib\\zstrmac.txt - the generated HLASM compatible translator.","title":"Translating to standard"},{"location":"user_guide/z390/structured_macro/#regression-tests","text":"You can execute the regression tests by using the script runzstrmactests . The following regression test programs are included: rt\\test\\ZSTRMAC1.MLC - bootstrap version of translator written in standard HLASM. rt\\test\\ZSTRMAC2.ZSM - structured version of the translator which uses all the structures. rt\\test\\TESTSPE1.ZSM - test program for ZSTRMAC1 with all the basic structures. rt\\test\\TESTSPE2.ZSM - test program for ZSTRMAC2 with all the basic structures in lower case rt\\test\\TESTSPE3.ZSM - test of all 256 ACASE values using all forms of AWHEN operands rt\\test\\TESTSPE4.ZSM - test error messages rt\\test\\TESTSPM1.MLC - test program for structured programming macros","title":"Regression tests"},{"location":"user_guide/z390/structured_macro/#demo","text":"The following demo programs using the macro extensions are include: demo\\DEMOM8Q1.MLC - solve 8 queens chess problem suing recursive structured macro","title":"Demo"},{"location":"user_guide/z390/structured_macro/#utilities","text":"The following z390 utility programs using the macro extensions are included: linklib\\RTGENDIR.MLC - read file system directory and create list of file names linklib\\RTGENCMP.MLC - read merged list of files from 2 directories and generate compare commands linklib\\RTGENDIF.MLC - read difference files and generate erase commands for identical files The following system macros use the macro extensions: EQUREGS.MAC - generate EQU symbols if not already generated for GPR and FPR registers ZCLOSE.MAC - close files (called from CLOSE and other user macros in concatenated directories) ZOPEN.MAC - open files (called from OPEN and other user macros in concatenated directories)","title":"Utilities"},{"location":"user_guide/z390/z390_filetypes/","text":"z390 File types The scope value details where the option is used. M - mz390 macro processor which reads ASCII assembler source and generates expanded BAL A - az390 assembler which reads BAL and generated OBJ relocatable object code L - lz390 linker which reads OBJ relocatable object files and generates 390 load module E - ez390 emulator runtime which loads and executes 390 load module File extension Scope Format File Description File or Report Format Description BAL MA ASCII Basic Assembly Language generated ASCII source file generated by mz390 when option BAL is specified. When option ASM is on (the default), mz390 starts az390 as a separate process running in parallel and passes generated BAL statements directly to it. This allows the first pass of assembler processing to be overlapped with macro expansion and eliminates need to write this file to external disk. Basic Assembler format is free form within first 71 characters with optional label starting in position 1 followed by opcode followed by operands if any. If continuation is required a non-space character appears in position 72. Positions 73-80 may be used for sequence numbering. The ICTL instruction may be used to change these default settings but it is not recommended as the macro and copybook files are all in the default format. Embedded AREAD records longer than 71 characters must be in standard continuation format for preloading of MLC and MAC files (a z390 restriction). Note the default NOALLOW limits AREAD and PUNCH records to maximum of 80. CPY MA ASCII Copybook source included in source programs, macros, or other copybooks. Same format as BAL. DAT M ASCII Text data input files read via AREAD statements in macro processor specifying ID=, DDNAME= or DSNAME= extended parameters. AREAD with no extended parameters reads the next statement in the input stream. Same format as BAL except text records can be any length with no continuation format required using ALLOW. ERR MALE ASCII Output log of all START and ENDED messages plus any errors plus any error file references. Text file with messages showing start and stop statistics for each step and any error messages issued by those steps. A cross reference of all macro and copybook files with errors is included at the end. For full cross reference of all macros and copybooks used see STA file. LOG E ASCII Output log for GUI or batch command execution controlled by CON option. Test file with messages issued during program execution including start and stop statistics plus any errors and any WTO write to operator messages. LKD L ASCII Optional input command for linker (INCLUDE, ENTRY, ALIAS, NAME). Same format as BAL. MAC M ASCII Macro source files Same format as BAL. MLC M ASCII Macro assembler source programs read by mz390. Same format as BAL. MOD LE Binary Binary code output from linker with no header and no RLD records. This type file can be created using option MOD and can be loaded as a data table by Micro Focus CICS. Binary file with all CSECT binary data. For example DC C'ABC' using option MOD will result in 3 byte MOD file containing x'C1C2C3'. OBJ AL EBCDIC, ASCII Output relocatable object code file for macro assembler with two format options. The default is mainframe linker compatible relocatable object code 80 byte records (ESD, TXT, RLD, and END). When OBJHEX option is specified for assembler, ASCII readable text extended format supporting 31 bit long sections is generated. The z390 linker can read either format by examining the file. OPT MALE ASCII Optional options files referenced via @file option from command line or other option files Text file with z390 options entered in free format delimited by spaces. An * will terminate options on a line and start comments on that line. PCH M ASCII Output text files written via PUNCH statements in macro processor using optional ID=, DDNAME=, or DSNAME= extended parameters. The default is pgm.PCH. Text file output which is not limited to 80 byte BAL format using ALLOW. Any macro program generating BAL output must format continuations. PRN A ASCII Output assembly language listing from az390. Text file with the following listing fields: 1) hex relative offset to instruction 2) hex bytes in instruction or data with up to 8 bytes per line. Direction PRINT DATA will force listing all data 8 bytes per line. 3) (file #/file-line #) generated-line # identified the file # and the relative file line # for the MLC, MAC, or CPY file that the generated line came from followed by the sequential generated line #. 4) Flag field has + for macro generated lines, and = for line from copybook. 5) BAL line with label, opcode, and operands. STA MALE ASCII Output statistics file listing options set, program statistics, and file references. Text file with detail statistics on each step including all option settings, complete macro and copybook cross reference for mz390, and execution statistics. TRA A ASCII Trace output file for assembler (lists each line being assembled during each pass). Text file with az390 assembler trace output including source file name, relative line, generated line, relative hex offset, and source statement for each assembler pass which may be 2 or more depending on usage of LOCTR. TRE E ASCII Trace output file for emulator (lists each instruction, address, and operand values). Text file with ez390 emulator execution trace output showing, hex PSW address, condition code, hex instruction, mnemonic, operand register and storage values at the start of each instruction. Blank line inserted for each branch to non sequential address. The high bit of PSW hex address indicates 24 or 31 bit address mode. TRL L ASCII Trace output file for linker (lists each OBJ record processed). Text file with lz390 linker trace output including ESD external symbol hex addresses and lengths, TXT text records with relative offset within ESD and hex data. RLD relocation records showing hex offset, field length, and ESD symbol. TRM M ASCII Trace output file for macro process (TRACEM lists each macro line executed, TRACEP lists every macro pseudo code instruction executed showing the current value of local and global variables used in SET statements and AIF statements etc). Text file with mz390 macro processor trace output file which is typically generated in parallel with the generation of the first pass information in the TRA file since mz390 and az390 run as concurrent tasks. This file includes source file name, relative line number, and source macro statement. For generated BAL output lines the source file# and relative line# cross reference is also include. If the TRACEP option is specified, this file also includes listing of the generation and execution of macro pseudo code instructions. TRS E ASCII Report from ZPARTRS utility Trace CBL AND ASM source execution. ZSM M ASCII ZSTRMAC Structured Conditional Macro source programs. Use ZSTRMAC.BAT file1 file2 to translate ZSM type file to standard HLASM compatible MLC type source file. 390 LE Binary Executable z390 load modules created by linker from OBJ files and loaded by emulator. The 390 load modules contain 20 byte header with the following: 1) 4 byte ASCII character version '1002' 2) 1 byte flag AMODE31 'T' or 'F' 3) 1 byte flag RMODE31 'T' or 'F' 4) 2 bytes reserved '??' 5) 4 byte length of code 6) 4 byte offset to entry 7) 4 byte count of RLD's following code The code for all CSECT's follows the header. The RLD table follows the code if any. Each RLD field in load module is relocated by the load address determined at load time. The 5 byte RLD records are as follows: 1) 4 byte offset to RLD field in code 2) 1 byte field length See option MOD and file type MOD to create code without header or any RLD's.","title":"z390 File types"},{"location":"user_guide/z390/z390_filetypes/#z390-file-types","text":"The scope value details where the option is used. M - mz390 macro processor which reads ASCII assembler source and generates expanded BAL A - az390 assembler which reads BAL and generated OBJ relocatable object code L - lz390 linker which reads OBJ relocatable object files and generates 390 load module E - ez390 emulator runtime which loads and executes 390 load module File extension Scope Format File Description File or Report Format Description BAL MA ASCII Basic Assembly Language generated ASCII source file generated by mz390 when option BAL is specified. When option ASM is on (the default), mz390 starts az390 as a separate process running in parallel and passes generated BAL statements directly to it. This allows the first pass of assembler processing to be overlapped with macro expansion and eliminates need to write this file to external disk. Basic Assembler format is free form within first 71 characters with optional label starting in position 1 followed by opcode followed by operands if any. If continuation is required a non-space character appears in position 72. Positions 73-80 may be used for sequence numbering. The ICTL instruction may be used to change these default settings but it is not recommended as the macro and copybook files are all in the default format. Embedded AREAD records longer than 71 characters must be in standard continuation format for preloading of MLC and MAC files (a z390 restriction). Note the default NOALLOW limits AREAD and PUNCH records to maximum of 80. CPY MA ASCII Copybook source included in source programs, macros, or other copybooks. Same format as BAL. DAT M ASCII Text data input files read via AREAD statements in macro processor specifying ID=, DDNAME= or DSNAME= extended parameters. AREAD with no extended parameters reads the next statement in the input stream. Same format as BAL except text records can be any length with no continuation format required using ALLOW. ERR MALE ASCII Output log of all START and ENDED messages plus any errors plus any error file references. Text file with messages showing start and stop statistics for each step and any error messages issued by those steps. A cross reference of all macro and copybook files with errors is included at the end. For full cross reference of all macros and copybooks used see STA file. LOG E ASCII Output log for GUI or batch command execution controlled by CON option. Test file with messages issued during program execution including start and stop statistics plus any errors and any WTO write to operator messages. LKD L ASCII Optional input command for linker (INCLUDE, ENTRY, ALIAS, NAME). Same format as BAL. MAC M ASCII Macro source files Same format as BAL. MLC M ASCII Macro assembler source programs read by mz390. Same format as BAL. MOD LE Binary Binary code output from linker with no header and no RLD records. This type file can be created using option MOD and can be loaded as a data table by Micro Focus CICS. Binary file with all CSECT binary data. For example DC C'ABC' using option MOD will result in 3 byte MOD file containing x'C1C2C3'. OBJ AL EBCDIC, ASCII Output relocatable object code file for macro assembler with two format options. The default is mainframe linker compatible relocatable object code 80 byte records (ESD, TXT, RLD, and END). When OBJHEX option is specified for assembler, ASCII readable text extended format supporting 31 bit long sections is generated. The z390 linker can read either format by examining the file. OPT MALE ASCII Optional options files referenced via @file option from command line or other option files Text file with z390 options entered in free format delimited by spaces. An * will terminate options on a line and start comments on that line. PCH M ASCII Output text files written via PUNCH statements in macro processor using optional ID=, DDNAME=, or DSNAME= extended parameters. The default is pgm.PCH. Text file output which is not limited to 80 byte BAL format using ALLOW. Any macro program generating BAL output must format continuations. PRN A ASCII Output assembly language listing from az390. Text file with the following listing fields: 1) hex relative offset to instruction 2) hex bytes in instruction or data with up to 8 bytes per line. Direction PRINT DATA will force listing all data 8 bytes per line. 3) (file #/file-line #) generated-line # identified the file # and the relative file line # for the MLC, MAC, or CPY file that the generated line came from followed by the sequential generated line #. 4) Flag field has + for macro generated lines, and = for line from copybook. 5) BAL line with label, opcode, and operands. STA MALE ASCII Output statistics file listing options set, program statistics, and file references. Text file with detail statistics on each step including all option settings, complete macro and copybook cross reference for mz390, and execution statistics. TRA A ASCII Trace output file for assembler (lists each line being assembled during each pass). Text file with az390 assembler trace output including source file name, relative line, generated line, relative hex offset, and source statement for each assembler pass which may be 2 or more depending on usage of LOCTR. TRE E ASCII Trace output file for emulator (lists each instruction, address, and operand values). Text file with ez390 emulator execution trace output showing, hex PSW address, condition code, hex instruction, mnemonic, operand register and storage values at the start of each instruction. Blank line inserted for each branch to non sequential address. The high bit of PSW hex address indicates 24 or 31 bit address mode. TRL L ASCII Trace output file for linker (lists each OBJ record processed). Text file with lz390 linker trace output including ESD external symbol hex addresses and lengths, TXT text records with relative offset within ESD and hex data. RLD relocation records showing hex offset, field length, and ESD symbol. TRM M ASCII Trace output file for macro process (TRACEM lists each macro line executed, TRACEP lists every macro pseudo code instruction executed showing the current value of local and global variables used in SET statements and AIF statements etc). Text file with mz390 macro processor trace output file which is typically generated in parallel with the generation of the first pass information in the TRA file since mz390 and az390 run as concurrent tasks. This file includes source file name, relative line number, and source macro statement. For generated BAL output lines the source file# and relative line# cross reference is also include. If the TRACEP option is specified, this file also includes listing of the generation and execution of macro pseudo code instructions. TRS E ASCII Report from ZPARTRS utility Trace CBL AND ASM source execution. ZSM M ASCII ZSTRMAC Structured Conditional Macro source programs. Use ZSTRMAC.BAT file1 file2 to translate ZSM type file to standard HLASM compatible MLC type source file. 390 LE Binary Executable z390 load modules created by linker from OBJ files and loaded by emulator. The 390 load modules contain 20 byte header with the following: 1) 4 byte ASCII character version '1002' 2) 1 byte flag AMODE31 'T' or 'F' 3) 1 byte flag RMODE31 'T' or 'F' 4) 2 bytes reserved '??' 5) 4 byte length of code 6) 4 byte offset to entry 7) 4 byte count of RLD's following code The code for all CSECT's follows the header. The RLD table follows the code if any. Each RLD field in load module is relocated by the load address determined at load time. The 5 byte RLD records are as follows: 1) 4 byte offset to RLD field in code 2) 1 byte field length See option MOD and file type MOD to create code without header or any RLD's.","title":"z390 File types"},{"location":"user_guide/z390/z390_options/","text":"z390 Options The scope value details where the option is used. M - mz390 macro processor which reads ASCII assembler source and generates expanded BAL A - az390 assembler which reads BAL and generated OBJ relocatable object code L - lz390 linker which reads OBJ relocatable object files and generates 390 load module E - ez390 emulator runtime which loads and executes 390 load module !!! Note: most options can be prefixed with NO to turn the feature off. Use of parameters with parentheses in *nix shells Unix shells like sh and bash interpret parentheses if not quoted. For this reason, if you need to specify a parameter that contains parentheses, then that parameter should be quoted. For example, the SYSMAC parameter is quoted as it uses parentheses, whereas the ALIGN parameter is not. \"SYSMAC(foldername)\" ALIGN Option Scope Default Description @filename MALE Options in Z390.OPT file if found Retrieve additional options from free form text file with default suffix OPT. Options can be specified delimited by spaces on as many lines as required. All characters on a line following * are ignored as comments. The @file option can be nested. The default path is the program path. If a file named Z390.OPT exists in the z390 install directory, these options will be applied first as default options. ALIGN A YES Align DS/DC data fields based on type unless explicit length is specified. If duplication factor is 0, then NOALIGN is ignored. ALLOW M NO Allow extensions to HLASM syntax. See note below this table for details. The default of NOALLOW insures HLASM compatibility. AMODE24 LE NO Set 390 load module options to start in 24 bit address mode. AMODE31 LE YES Set 390 load module options to start in 31 bit address mode. ASCII AE NO Generate ASCII versus EBCDIC DC character constants, compare character strings in ASCII versus EBCDIC in macro processor, generate ASCII versus EBCDIC output for UNPK, ED, and EDMK. See note following this table. ASM MA YES Run az390 assembler as subtask of mz390 passing BAL. Note NOASM is for use in pure text processing programs which only use conditional macro code and AREAD/PUNCH with extensions to process ASCII text files. NOASM does not support ordinary symbol attribute tests, OPSYN, or lookahead mode, and requires CHKMAC(0) and CHKSRC(0-2). ASSIST MAE NO Enable assembly and execution of ASSIST I/O and debugging instructions. This option also sets NOLOADHIGH. See ASSIST Support . AUTOLINK L YES Search for unresolved external references in SYSOBJ directory list which defaults to linklib. BAL M NO Generate BAL expanded assembler source file. BS2000 MA NO Support Siemens BS2000 assembler global variables. CHKMAC(0-2) M 0 Check macros during loading. See note below this table for details. CHKSRC(0-3) MA 1 Check input source files. See note below this table for details. CICS MA NO Support EXEC CICS pre-processor expansion and constants. If this option is not on during macro expansion, PROLOG and EPILOG option settings will be ignored. CODEPAGE MALE CODEPAGE(ISO-8859-1+IBM1047) Values: ebcdic+ascii[+LIST]. If +LIST is added the mapping of the 2 codepages along with printable character and Unicode values are displayed on ERR file. A hex dump of the tables and a list of the valid ASCII and EBCDIC Unicode Charset codepages are listed. You can replace the EBCDIC codepage name with a file specification such as IBM1047.HCP (example included) which is in hex dump format. The above defaults match z/OS. CON MALE YES Console output for all start/stop, error, trace, MNOTE's with level > 4, and WTO messages. When the TRACE??? option is specified, the CON option is turned off so only start/stop and abort error messages appear on console log. You can specify CON after last TRACE option to turn it back on if you want all display, trace, and error messages displayed on console log. All the trace messages appear on corresponding TR? file for each z390 program executed. DUMP E NO Generate full memory dump on LOG or TRE if abort. EDF M YES CICS Execution Diagnostic Facility. EPILOG M YES Generate epilog macro call DFHEIEND for CICS program at END statement if CICS option and EPILOG option are on. ERR(100) MALE 100 Terminate process if total errors for program exceeds limit. Use ERR(0) to eliminate any error limit and always generate PRN file. ERRSUM M NO Generate critical error summary on console and ERR file listing missing macros and copybooks. This option requires ASM option and is turned on automatically if missing macros or copybooks are found in the executed macro code path. When ERRSUM is on, ERR(0) is set to prevent abort prior to finding all macro and copybook references. All errors are listed on ERR file along with summary report. Note several iterations may be required to identify and resolve all missing macros and copybooks. GUAM E NO Support one or more GUI Graphical User Access Method dialogs for MCS, TN3270, or graphics user interface. INIT E YES Initialize all registers to hex x'F4', all memory to hex x'F5', and all uninitialized load module areas to x'F6' for easier identification of access to uninitialized registers, memory or program fields. Use NOINIT to perform low value initialization. INSTALL(dir) MALE NO Define alternate z390 install directory to run batch command. The default is set from Java property \"user.dir\". IPL(pgm) E none Execute 390 program at startup. LIST ALE YES Generate PRN, LST, and LOG files for assembler, linker, and execution respectively. LISTCALL MA YES Generate level macro call and exit comments in BAL file which are used by assembler to format first level macro calls preceding assembler lines with \"+\" for macro generated source. LISTUSE A YES List active USING definitions each time USING or DROP changes status in the PRN assembly listing file. LOADHIGH E YES Load programs and allocate memory for GETMAIN/STORAGE from high end of first FQE large enough to satisfy request. The ASSIST option changes this option to NOLOADHIGH causing initial program to load starting at X'8000' which simplifies relative address calculations. LOG(file) MALE pgm Set file name for ERR, TR?, and LOG files. The default is the program name. This option is required when running multiple copies of the same program via CMD startup in order to create separate unique ERR, TR?, and LOG files. Otherwise duplicate programs running in parallel will mod the same ERR, TR?, and LOG file. MACHINE A -- MACHINE / OPTABLE options determine which opcode table is used during assembly. See table below for details, MAXCALL(num) M 50 Set limit for nested macro calls. MAXDISPLAY(num) M 80 Use to increase zCOBOL DISPLAY line size up to 256 characters. MAXESD(num) AL 1000 Set limit for ESD sections or entries in one program. MAXFILE(num) M 1000 Maximum macro and copybook files. MAXGBL(num) M 100000 Maximum global macro variables. MAXHEIGHT(num) E 600 Maximum pixel height for GUI dialog windows. MAXLCL(num) M 100000 Maximum local macro variables. MAXLINE(num) MA 200000 Maximum MLC, MAC, CPY, and BAL source lines that can be loaded into memory during an assembly. MAXLOG(num) MALE 1000000 Maximum GUI log file output before truncation begins by removing 50% to limit memory consumption. The only limit on size of log file is MAXSIZE. MAXPARM(num) M 10000 Maximum length of any string during macro processing. This is an extension as HLASM limit is currently 1024. MAXPASS(num) A 2 Maximum passes of the BAL source by assembler to resolve forward nested symbol references prior to final pass to generate object code. The number of LOCTR statements is added to this limit in order to resolve the final address of each LOCTR section. MAXPC(num) M 50000 Maximum pseudo code instructions held in cache before LRU replacement begins. MAXQUE(num) E 1000 Maximum output queue length from any CMD started task before queue messages are automatically copied to GUI output log to conserve memory and prevent stall. MAXRLD(num) L 10000 Maximum RLD relocation records allowed in a program. MAXSIZE(num) MALE 50 Maximum size of any output file in MB. MAXSYM(num) MA 50000 Maximum symbols in one macro assembly. MAXWARN(num) MA 4 Maximum MNOTE warning level without generating error. MAXWIDTH(num) E 800 Maximum pixel width for GUI dialog windows. MCALL A NO List each macro call and exit on the PRN assembly listing in addition to first level calls if LISTCALL option is also on. MEM(num) E 1 Memory allocated for 390 program execution in MB. Note for RMODE31 loads and GETMAIN's memory above the 16 MB line must be allocated. For example MEM(32) would provide 16 MB below the line and 16 MB above. MINHEIGHT(num) E 150 Minimum pixel height for GUI dialog windows. MINWIDTH(num) E 150 Minimum pixel width for GUI dialog windows. MNOTE(num) MA 0 Control MNOTE error/warning messages during macro expansion and assembly. See note below this table for details. MOD L NO Generate raw code file from lz390 with .MOD suffix and no header or trailer and no RLD's. OBJ A YES Generate relocatable object code file. OBJHEX A NO Generate ASCII readable form of OBJ file with support for 31 bit long sections. The default is to generate binary OBJ file which is compatible with mainframe linkers but is limited to 24 bit long sections. OPTABLE A z390 MACHINE / OPTABLE options determine which opcode table is used during assembly. See table below for details. PARM('text') E '' Define character string parm passed to executable program via address in R1 at startup pointing to a fullword pointing to a halfword length followed by EBCDIC characters. When the length is zero, no PARM is present. PC M YES Generate macro pseudo code in cache memory for speeding up macro code that is executed more than once during macro expansion. PCOPT M YES Optimize macro pseudo code by looking for push, add/sub, store sequences and replacing them with inc/dec pseudo code opcodes. These pseudo codes are maintained in a cache in memory during macro execution only and have no effect on generated object code. PRINTALL A NO Suppress PRINT OFF and PRINT NOGEN commands to force all source lines on PRN listing. PDSMEM8 M NO If PDSMEM8 option is specified, error messages will be issued for any macro or copybook file names with length greater than 8. This option is available to provide compatibility with mainframe PDS libraries that are limited to 8 character names. Note zCOBOL and zCICS use names longer than 8 characters such as zcobol\\IDENTIFICATION.MAC and cics\\CICS_INQUIRE.MAC. PROFILE(file) M NO Insert COPY file in front of MLC source file. PROLOG M YES Generate CICS prolog macro calls DFHEIGBL, DFHEISTG, and DFHEIENT if CICS option and PROLOG options are on. PROTECT E YES Prevent modification of PSA in low memory 8K block. REFORMAT M NO Reformat expanded BAL code to align all opcodes at column 10 and operands at column 16 if possible. REGS E NO Generate GPR register trace before and after each instruction if TRACE option on. RMODE24 LE YES Set 390 load module options to load module below the 16MB line. RMODE31 LE NO Set 390 load module options to load module above the 16MB line. Note this load module option requires option MEM to be set to include enough memory above the 16MB line. STATS[(file)] MALE NO Generate statistics file STA with final options listing, macro and copybook file listing, plus all program statistics. If file is omitted the program path and file name are used with STA suffix. SYS390(dir) LE pgm dir Define directory for storing and retrieving 390 load modules. SYSBAL(dir) MA pgm dir Define directory for storing and retrieving generated BAL files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSCPY(dir) MA pgm dir Define one or more directories for retrieving CPY source input files. If the option starts with + the directories listed will be concatenated with current list. Multiple directories are always separated by +. This option may also override suffix by adding *.sfx. SYSDAT(dir) M pgm dir Define directory for retrieving DAT source input files for AREAD. Set to SYSDAT(.) for current directory when no path is specified on DSNAME parm for AREAD. SYSERR(dir) MALE pgm dir Define directory for output ERR files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSLKD(file) L pgm dir Define input source file for linker commands such as INCLUDE, ALIAS, ENTRY, and NAME. SYSLOG(dir) E pgm dir Define directory for output LOG file. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSLST(dir) AL pgm dir Define directory for output LST files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSMAC(dir) M mac dir Define one or more directories for source MAC files. If the option starts with + the directories listed will be appended to the maclib list. Multiple directories can be specified in one parameter and are always separated by +. When you specify this option more than once and want previous parameter instructions to remain in place, ensure that you start parameter with a + otherwise it will drop prior directories. This option may also override suffix by adding *.sfx. SYSMLC(dir) MA pgm dir Define directory for source input MLC files. SYSOBJ(dir) AL pgm dir Define directory for OBJ relocatable object files. SYSOPT(dir) MALE pgm dir Define directory for @file option files. This option may override suffix using *.sfx. SYSPARM('txt') M none Define text string which can be accessed by mz390 global macro variable &SYSPARM. SYSPCH(dir) M pgm dir Define directory for PCH output files from PUNCH. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). Note PUNCH output is in ASCII source format and is not directed to the OBJ file. These files may be used as linker input commands via SYSLKD(file) option. Set to SYSPCH(.) for current directory when no path is specified on DSNAME parm for PUNCH. SYSPRN(dir) A pgm dir Define directory for assembler listing PRN output files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSTERM(file) MALE pgm.ERR Define alternate file for all start/end messages plus any error messages, plus related source file statistics for each file containing errors. The default is the program name with ERR suffix. SYSTRC(dir) MALE pgm dir Define directory for output TRACE TR? files. TEST E NO Start execution with interactive TEST mode active which prompts for commands such as T opcode or G opcode to trace or execution to the next occurrence of opcode name. TEST(ddname) E NO Define input command file to run TEST commands. ddname is an environment variable set to the name of the command file. THREAD A NO Assign continuing CSECT addresses for multiple CSECT's assembled in the same module to help identify location of instruction and data labels. TIME[(num)] MALE YES Limit execution time of each program to the number of seconds specified. The default is 15 seconds. NOTIME and NOTIMING both turn off this option. Use NOTIME to allow tasks such as SOA servers like z390CICS to run continuously while still supporting application use of timing functions. TIMING MALE YES Calculate elapsed time and instructions per second statistics for display on START/END messages and STA statistics. TIMING also displays current z390 and J2SE version on start message and memory usage on ended message. Note NOTIMING is used in regression tests to force generated files to be identical by using fixed data/time stamp using GregorianCalendar(2005,0,2,22,33,44). NOTIMING suppresses versions on start message and memory usage on ended message. NOTIMING also sets NOTIME which prevents application from using time functions. TRACE E NO Turn on ez390 execution trace generation on TRE file and turn off CON. TRACE will display every instruction executed along with address and value of each operand. Any combination of the following trace options can be set using the TRACE(...) option: AEGILMPQTV. TRACE(*) will also set TRACEALL. Note the &SYSTRACE global SETC variable can be used to turn any trace options on or off during execution. See table below for details. TRACEALL MALE NO Turn on all trace options generating TRM, TRA, TRL, and TRE files and turn off CON. See table below for details. TRAP E YES Trap any unexpected J2SE program exceptions and generate emulator 0C5 exception which can be handled by SPIE/STAE exits if defined. NOTRAP can be used with Eclipse source debugger to stop at J2SE statement causing exception. TS MALE NO Generate JDBC compatible time-stamp on all TRACE and ERR file records for use in debugging time dependent issue. VCB E YES Generate VSAM cache buffer for improving VSAM performance by storing most recently accessed records and indexes. WRITENONPRINTABLE MA NO Write non-printable characters to PRN, BAL and PCH files. The default value NOWRITENONPRINTABLE replaces all non-printable characters with the '.' character. This avoids issues caused by writing control characters such as 0x0A (Line Feed) or 0x0D (Carriage Return). XREF A YES Cross reference symbols to source lines in PRN assembly listing. ZSTRMAC M YES Support expansion of ZSTRMAC structured conditional macro code instructions during loading of MLC, MAC, and CPY files. Note z390 macros in z390\\mac directory now are using zstrmac for structured coding. NOZSTRMAC can only be used with MVS, VSE, or other non-structured macro libraries. ZVSAM E 0 ZVSAM 0=no vsam, 1=zvsam1 support Note on ALLOW mode: The following features are enabled in allow mode: 1. No quotes required for SETC variables 2. Duplication factor does not require (..) 3. Array declarations with variables in expression accepted 4. Substring starting beyond end returns null string 5. Quoted strings allowed in SETA and SETB expressions 6. Allow &var as null string if not found during substitution 7. Allow duplicate local and global variable declarations 8. Allow AREAD and PUNCH file records greater than 80 characters. Note on ASCII mode: ASCII mode is not mainframe compatible and requires careful review of program to insure no EBCDIC immediate compare constants such as X'40', 64, X'F0', 240 etc. are used and that there are no assumptions about EBCDIC versus ASCII collating sequences which have numbers and letters reversed, and EBCDIC letters are non-contiguous. Typically HLASM compatible programs are run in default EBCDIC mode and DCB RECFM=FT|VT or some other translation option is used to convert between EBCDIC and ASCII where necessary. Note there are a few instructions affected by ASCII mode: 1. ED/EDMK generate ASCII versus EBCDIC but the mask must always be in EBCDIC (masks are usually coded in X'...' format) 2. UNPK generates X'3' versus X'F' in zone field (high order nibble). Note on CHKMAC options: - 0 - no checking - 1 - check for missing AGO and AIF labels and issue warning - 2 - also check missing labels and also check for non comment text after MEND Note on CHKSRC options: - 0 - no checking - 1 - check MLC or BAL input source files for any non-ASCII characters and issue error - 2 - check MLC, MAC, CPY, and BAL input source files for any non-ASCII characters and issue error - 3 - also check for out of sequence characters in 73-80 or any non-blank characters beyond 80 and issue error - - Note this should detect any EBCDIC literal character strings containing non-ASCII characters such as binary 0 byte which must be changed to hex X'00' type strings for portability. Note on MNOTE options: - 0 - default generates MNOTE error/warning during mz390 and az390 - 1 - suppress mz390 error/warning and only pass MNOTE to az390 - 2 - generates MNOTE error/warning during mz390 and suppresses passing them on to az390 Tracing options and equivalences TRACE will display every instruction executed along with address and value of each operand. Any combination of the following trace options can be set using the TRACE(...) option. TRACE(*) will also set TRACEALL. Note the &SYSTRACE global SETC variable can be used to turn any trace options on or off during execution. Option Scope Default Description TRACE E NO Turn on ez390 execution trace generation on TRE file and turn off CON. TRACE will display every instruction executed along with address and value of each operand. TRACEA or TRACE(A) A NO Turn on az390 assembly trace generation on TRA file and turn off CON. TRACEA will display each BAL statement during each pass of the assembler. TRACEC or TRACE(C) M NO Trace copy file code for TRACEM and TRACEP. The default is NOTRACEC to eliminate redundant code that usually just contains global variable declarations. TRACEG or TRACE(G) E NO Turn on ez390 emulator trace generation on TRE file with trace of GETMAIN/FREEMAIN FQE memory management control block changes and turn off CON. TRACEI or TRACE(I) M NO TRACEI will trace each AINSERT showing source on the TRM trace file. TRACEL or TRACE(L) L NO Turn on lz390 linker trace generation on TRL file and turn off CON. TRACEL shows each CSECT, ENTRY, EXTRN and OBJ file being loaded. TRACEM or TRACE(M) M NO Turn on mz390 macro processor trace generation on TRM file and turn off CON. TRACEM displays each conditional macro statement executed plus stored values and AIF compare values. TRACEP or TRACE(P) M NO Turn on mz390 macro processor pseudo code generation and execution trace on TRM file and turn off CON. TRACEP shows each conditional macro pseudo operation performed for each conditional macro statement and the values of all variables. TRACEQ or TRACE(Q) E NO Turn on ez390 emulator QSAM/BSAM DCB I/O trace generation on TRE file and turn off CON. TRACES or TRACE(S) M NO Display MLC source lines on console regardless of CON setting to help locate any loops, waits, or hangs in large macro process. If MCALL is also on, then *MCALL and *MEXIT comments will also be displayed to show location with nested macros. TRACET or TRACE(T) E NO Turn on ez390 emulator TGET/TPUT and TCP/IO trace generation on TRE file and turn off CON. TRACEV or TRACE(V) E NO Turn on ez390 emulator VSAM ACB/RPL I/O trace generation on TRE file and turn off CON. TRACEALL MALE NO Turn on all trace options generating TRM, TRA, TRL, and TRE files and turn off CON. Machine and optable options and equivalences Machine Machine Optable Optable Description S360-20 360-20 z390 extension: S360-20 specific subset of DOS instructions DOS S370 370 S370XA ARCH-0 XA S370ESA ARCH-1 ESA Synonyms for ESA S390 ARCH-2 ESA S390E ARCH-3 ESA ARCH-4 ESA zSeries ZSeries-1 ZS1 ZOP Synonyms for ZOP ZS ZS-1 ZS1 ZOP z800 z900 ZS1 ZOP ARCH-5 ZS1 ZOP z890 z990 ZS2 YOP Synonyms for YOP zSeries-2 ZS-2 ZS2 YOP ARCH-6 ZS2 YOP zSeries-3 ZS-3 ZS3 Z9 Synonyms for Z9 z9 ARCH-7 ZS3 Z9 zSeries-4 ZS-4 ZS4 Z10 Synonyms for Z10 z10 ARCH-8 ZS4 Z10 zSeries-5 ZS-5 ZS5 Z11 Synonyms for Z11 z114 z196 ZS5 Z11 z11 ARCH-9 ZS5 Z11 zSeries-6 ZS-6 ZS6 Z12 Synonyms for Z12 zBC12 zEC12 ZS6 Z12 z12 ARCH-10 ZS6 Z12 zSeries-7 ZS-7 ZS7 Z13 Synonyms for Z13 z13 ARCH-11 ZS7 Z13 zSeries-8 ZS-8 ZS8 Z14 Synonyms for Z14 z14 ARCH-12 ZS8 Z14 zSeries-9 ZS-9 ZS9 Z15 Synonyms for Z15 z15 ARCH-13 ZS9 Z15 zSeries-10 ZS-10 ZSA Z16 Synonyms for Z16 z16 ARCH-14 ZSA Z16 UNI All current instructions from optables above [DFLT] Cannot be specified, same as UNI plus one z390 directive for zCobol support z390 UNI plus all z390 instructions; not compatible with HLASM Remark: there is no machine option keyword equivalent for optable(DOS). Remark: option allow adds z390 instructions to specified optable. Remark: option assist adds ASSIST instructions to specified optable.","title":"z390 Options"},{"location":"user_guide/z390/z390_options/#z390-options","text":"The scope value details where the option is used. M - mz390 macro processor which reads ASCII assembler source and generates expanded BAL A - az390 assembler which reads BAL and generated OBJ relocatable object code L - lz390 linker which reads OBJ relocatable object files and generates 390 load module E - ez390 emulator runtime which loads and executes 390 load module !!! Note: most options can be prefixed with NO to turn the feature off. Use of parameters with parentheses in *nix shells Unix shells like sh and bash interpret parentheses if not quoted. For this reason, if you need to specify a parameter that contains parentheses, then that parameter should be quoted. For example, the SYSMAC parameter is quoted as it uses parentheses, whereas the ALIGN parameter is not. \"SYSMAC(foldername)\" ALIGN Option Scope Default Description @filename MALE Options in Z390.OPT file if found Retrieve additional options from free form text file with default suffix OPT. Options can be specified delimited by spaces on as many lines as required. All characters on a line following * are ignored as comments. The @file option can be nested. The default path is the program path. If a file named Z390.OPT exists in the z390 install directory, these options will be applied first as default options. ALIGN A YES Align DS/DC data fields based on type unless explicit length is specified. If duplication factor is 0, then NOALIGN is ignored. ALLOW M NO Allow extensions to HLASM syntax. See note below this table for details. The default of NOALLOW insures HLASM compatibility. AMODE24 LE NO Set 390 load module options to start in 24 bit address mode. AMODE31 LE YES Set 390 load module options to start in 31 bit address mode. ASCII AE NO Generate ASCII versus EBCDIC DC character constants, compare character strings in ASCII versus EBCDIC in macro processor, generate ASCII versus EBCDIC output for UNPK, ED, and EDMK. See note following this table. ASM MA YES Run az390 assembler as subtask of mz390 passing BAL. Note NOASM is for use in pure text processing programs which only use conditional macro code and AREAD/PUNCH with extensions to process ASCII text files. NOASM does not support ordinary symbol attribute tests, OPSYN, or lookahead mode, and requires CHKMAC(0) and CHKSRC(0-2). ASSIST MAE NO Enable assembly and execution of ASSIST I/O and debugging instructions. This option also sets NOLOADHIGH. See ASSIST Support . AUTOLINK L YES Search for unresolved external references in SYSOBJ directory list which defaults to linklib. BAL M NO Generate BAL expanded assembler source file. BS2000 MA NO Support Siemens BS2000 assembler global variables. CHKMAC(0-2) M 0 Check macros during loading. See note below this table for details. CHKSRC(0-3) MA 1 Check input source files. See note below this table for details. CICS MA NO Support EXEC CICS pre-processor expansion and constants. If this option is not on during macro expansion, PROLOG and EPILOG option settings will be ignored. CODEPAGE MALE CODEPAGE(ISO-8859-1+IBM1047) Values: ebcdic+ascii[+LIST]. If +LIST is added the mapping of the 2 codepages along with printable character and Unicode values are displayed on ERR file. A hex dump of the tables and a list of the valid ASCII and EBCDIC Unicode Charset codepages are listed. You can replace the EBCDIC codepage name with a file specification such as IBM1047.HCP (example included) which is in hex dump format. The above defaults match z/OS. CON MALE YES Console output for all start/stop, error, trace, MNOTE's with level > 4, and WTO messages. When the TRACE??? option is specified, the CON option is turned off so only start/stop and abort error messages appear on console log. You can specify CON after last TRACE option to turn it back on if you want all display, trace, and error messages displayed on console log. All the trace messages appear on corresponding TR? file for each z390 program executed. DUMP E NO Generate full memory dump on LOG or TRE if abort. EDF M YES CICS Execution Diagnostic Facility. EPILOG M YES Generate epilog macro call DFHEIEND for CICS program at END statement if CICS option and EPILOG option are on. ERR(100) MALE 100 Terminate process if total errors for program exceeds limit. Use ERR(0) to eliminate any error limit and always generate PRN file. ERRSUM M NO Generate critical error summary on console and ERR file listing missing macros and copybooks. This option requires ASM option and is turned on automatically if missing macros or copybooks are found in the executed macro code path. When ERRSUM is on, ERR(0) is set to prevent abort prior to finding all macro and copybook references. All errors are listed on ERR file along with summary report. Note several iterations may be required to identify and resolve all missing macros and copybooks. GUAM E NO Support one or more GUI Graphical User Access Method dialogs for MCS, TN3270, or graphics user interface. INIT E YES Initialize all registers to hex x'F4', all memory to hex x'F5', and all uninitialized load module areas to x'F6' for easier identification of access to uninitialized registers, memory or program fields. Use NOINIT to perform low value initialization. INSTALL(dir) MALE NO Define alternate z390 install directory to run batch command. The default is set from Java property \"user.dir\". IPL(pgm) E none Execute 390 program at startup. LIST ALE YES Generate PRN, LST, and LOG files for assembler, linker, and execution respectively. LISTCALL MA YES Generate level macro call and exit comments in BAL file which are used by assembler to format first level macro calls preceding assembler lines with \"+\" for macro generated source. LISTUSE A YES List active USING definitions each time USING or DROP changes status in the PRN assembly listing file. LOADHIGH E YES Load programs and allocate memory for GETMAIN/STORAGE from high end of first FQE large enough to satisfy request. The ASSIST option changes this option to NOLOADHIGH causing initial program to load starting at X'8000' which simplifies relative address calculations. LOG(file) MALE pgm Set file name for ERR, TR?, and LOG files. The default is the program name. This option is required when running multiple copies of the same program via CMD startup in order to create separate unique ERR, TR?, and LOG files. Otherwise duplicate programs running in parallel will mod the same ERR, TR?, and LOG file. MACHINE A -- MACHINE / OPTABLE options determine which opcode table is used during assembly. See table below for details, MAXCALL(num) M 50 Set limit for nested macro calls. MAXDISPLAY(num) M 80 Use to increase zCOBOL DISPLAY line size up to 256 characters. MAXESD(num) AL 1000 Set limit for ESD sections or entries in one program. MAXFILE(num) M 1000 Maximum macro and copybook files. MAXGBL(num) M 100000 Maximum global macro variables. MAXHEIGHT(num) E 600 Maximum pixel height for GUI dialog windows. MAXLCL(num) M 100000 Maximum local macro variables. MAXLINE(num) MA 200000 Maximum MLC, MAC, CPY, and BAL source lines that can be loaded into memory during an assembly. MAXLOG(num) MALE 1000000 Maximum GUI log file output before truncation begins by removing 50% to limit memory consumption. The only limit on size of log file is MAXSIZE. MAXPARM(num) M 10000 Maximum length of any string during macro processing. This is an extension as HLASM limit is currently 1024. MAXPASS(num) A 2 Maximum passes of the BAL source by assembler to resolve forward nested symbol references prior to final pass to generate object code. The number of LOCTR statements is added to this limit in order to resolve the final address of each LOCTR section. MAXPC(num) M 50000 Maximum pseudo code instructions held in cache before LRU replacement begins. MAXQUE(num) E 1000 Maximum output queue length from any CMD started task before queue messages are automatically copied to GUI output log to conserve memory and prevent stall. MAXRLD(num) L 10000 Maximum RLD relocation records allowed in a program. MAXSIZE(num) MALE 50 Maximum size of any output file in MB. MAXSYM(num) MA 50000 Maximum symbols in one macro assembly. MAXWARN(num) MA 4 Maximum MNOTE warning level without generating error. MAXWIDTH(num) E 800 Maximum pixel width for GUI dialog windows. MCALL A NO List each macro call and exit on the PRN assembly listing in addition to first level calls if LISTCALL option is also on. MEM(num) E 1 Memory allocated for 390 program execution in MB. Note for RMODE31 loads and GETMAIN's memory above the 16 MB line must be allocated. For example MEM(32) would provide 16 MB below the line and 16 MB above. MINHEIGHT(num) E 150 Minimum pixel height for GUI dialog windows. MINWIDTH(num) E 150 Minimum pixel width for GUI dialog windows. MNOTE(num) MA 0 Control MNOTE error/warning messages during macro expansion and assembly. See note below this table for details. MOD L NO Generate raw code file from lz390 with .MOD suffix and no header or trailer and no RLD's. OBJ A YES Generate relocatable object code file. OBJHEX A NO Generate ASCII readable form of OBJ file with support for 31 bit long sections. The default is to generate binary OBJ file which is compatible with mainframe linkers but is limited to 24 bit long sections. OPTABLE A z390 MACHINE / OPTABLE options determine which opcode table is used during assembly. See table below for details. PARM('text') E '' Define character string parm passed to executable program via address in R1 at startup pointing to a fullword pointing to a halfword length followed by EBCDIC characters. When the length is zero, no PARM is present. PC M YES Generate macro pseudo code in cache memory for speeding up macro code that is executed more than once during macro expansion. PCOPT M YES Optimize macro pseudo code by looking for push, add/sub, store sequences and replacing them with inc/dec pseudo code opcodes. These pseudo codes are maintained in a cache in memory during macro execution only and have no effect on generated object code. PRINTALL A NO Suppress PRINT OFF and PRINT NOGEN commands to force all source lines on PRN listing. PDSMEM8 M NO If PDSMEM8 option is specified, error messages will be issued for any macro or copybook file names with length greater than 8. This option is available to provide compatibility with mainframe PDS libraries that are limited to 8 character names. Note zCOBOL and zCICS use names longer than 8 characters such as zcobol\\IDENTIFICATION.MAC and cics\\CICS_INQUIRE.MAC. PROFILE(file) M NO Insert COPY file in front of MLC source file. PROLOG M YES Generate CICS prolog macro calls DFHEIGBL, DFHEISTG, and DFHEIENT if CICS option and PROLOG options are on. PROTECT E YES Prevent modification of PSA in low memory 8K block. REFORMAT M NO Reformat expanded BAL code to align all opcodes at column 10 and operands at column 16 if possible. REGS E NO Generate GPR register trace before and after each instruction if TRACE option on. RMODE24 LE YES Set 390 load module options to load module below the 16MB line. RMODE31 LE NO Set 390 load module options to load module above the 16MB line. Note this load module option requires option MEM to be set to include enough memory above the 16MB line. STATS[(file)] MALE NO Generate statistics file STA with final options listing, macro and copybook file listing, plus all program statistics. If file is omitted the program path and file name are used with STA suffix. SYS390(dir) LE pgm dir Define directory for storing and retrieving 390 load modules. SYSBAL(dir) MA pgm dir Define directory for storing and retrieving generated BAL files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSCPY(dir) MA pgm dir Define one or more directories for retrieving CPY source input files. If the option starts with + the directories listed will be concatenated with current list. Multiple directories are always separated by +. This option may also override suffix by adding *.sfx. SYSDAT(dir) M pgm dir Define directory for retrieving DAT source input files for AREAD. Set to SYSDAT(.) for current directory when no path is specified on DSNAME parm for AREAD. SYSERR(dir) MALE pgm dir Define directory for output ERR files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSLKD(file) L pgm dir Define input source file for linker commands such as INCLUDE, ALIAS, ENTRY, and NAME. SYSLOG(dir) E pgm dir Define directory for output LOG file. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSLST(dir) AL pgm dir Define directory for output LST files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSMAC(dir) M mac dir Define one or more directories for source MAC files. If the option starts with + the directories listed will be appended to the maclib list. Multiple directories can be specified in one parameter and are always separated by +. When you specify this option more than once and want previous parameter instructions to remain in place, ensure that you start parameter with a + otherwise it will drop prior directories. This option may also override suffix by adding *.sfx. SYSMLC(dir) MA pgm dir Define directory for source input MLC files. SYSOBJ(dir) AL pgm dir Define directory for OBJ relocatable object files. SYSOPT(dir) MALE pgm dir Define directory for @file option files. This option may override suffix using *.sfx. SYSPARM('txt') M none Define text string which can be accessed by mz390 global macro variable &SYSPARM. SYSPCH(dir) M pgm dir Define directory for PCH output files from PUNCH. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). Note PUNCH output is in ASCII source format and is not directed to the OBJ file. These files may be used as linker input commands via SYSLKD(file) option. Set to SYSPCH(.) for current directory when no path is specified on DSNAME parm for PUNCH. SYSPRN(dir) A pgm dir Define directory for assembler listing PRN output files. This option may also override file name and/or suffix (*.sfx overrides just the suffix in the pgm directory). SYSTERM(file) MALE pgm.ERR Define alternate file for all start/end messages plus any error messages, plus related source file statistics for each file containing errors. The default is the program name with ERR suffix. SYSTRC(dir) MALE pgm dir Define directory for output TRACE TR? files. TEST E NO Start execution with interactive TEST mode active which prompts for commands such as T opcode or G opcode to trace or execution to the next occurrence of opcode name. TEST(ddname) E NO Define input command file to run TEST commands. ddname is an environment variable set to the name of the command file. THREAD A NO Assign continuing CSECT addresses for multiple CSECT's assembled in the same module to help identify location of instruction and data labels. TIME[(num)] MALE YES Limit execution time of each program to the number of seconds specified. The default is 15 seconds. NOTIME and NOTIMING both turn off this option. Use NOTIME to allow tasks such as SOA servers like z390CICS to run continuously while still supporting application use of timing functions. TIMING MALE YES Calculate elapsed time and instructions per second statistics for display on START/END messages and STA statistics. TIMING also displays current z390 and J2SE version on start message and memory usage on ended message. Note NOTIMING is used in regression tests to force generated files to be identical by using fixed data/time stamp using GregorianCalendar(2005,0,2,22,33,44). NOTIMING suppresses versions on start message and memory usage on ended message. NOTIMING also sets NOTIME which prevents application from using time functions. TRACE E NO Turn on ez390 execution trace generation on TRE file and turn off CON. TRACE will display every instruction executed along with address and value of each operand. Any combination of the following trace options can be set using the TRACE(...) option: AEGILMPQTV. TRACE(*) will also set TRACEALL. Note the &SYSTRACE global SETC variable can be used to turn any trace options on or off during execution. See table below for details. TRACEALL MALE NO Turn on all trace options generating TRM, TRA, TRL, and TRE files and turn off CON. See table below for details. TRAP E YES Trap any unexpected J2SE program exceptions and generate emulator 0C5 exception which can be handled by SPIE/STAE exits if defined. NOTRAP can be used with Eclipse source debugger to stop at J2SE statement causing exception. TS MALE NO Generate JDBC compatible time-stamp on all TRACE and ERR file records for use in debugging time dependent issue. VCB E YES Generate VSAM cache buffer for improving VSAM performance by storing most recently accessed records and indexes. WRITENONPRINTABLE MA NO Write non-printable characters to PRN, BAL and PCH files. The default value NOWRITENONPRINTABLE replaces all non-printable characters with the '.' character. This avoids issues caused by writing control characters such as 0x0A (Line Feed) or 0x0D (Carriage Return). XREF A YES Cross reference symbols to source lines in PRN assembly listing. ZSTRMAC M YES Support expansion of ZSTRMAC structured conditional macro code instructions during loading of MLC, MAC, and CPY files. Note z390 macros in z390\\mac directory now are using zstrmac for structured coding. NOZSTRMAC can only be used with MVS, VSE, or other non-structured macro libraries. ZVSAM E 0 ZVSAM 0=no vsam, 1=zvsam1 support Note on ALLOW mode: The following features are enabled in allow mode: 1. No quotes required for SETC variables 2. Duplication factor does not require (..) 3. Array declarations with variables in expression accepted 4. Substring starting beyond end returns null string 5. Quoted strings allowed in SETA and SETB expressions 6. Allow &var as null string if not found during substitution 7. Allow duplicate local and global variable declarations 8. Allow AREAD and PUNCH file records greater than 80 characters. Note on ASCII mode: ASCII mode is not mainframe compatible and requires careful review of program to insure no EBCDIC immediate compare constants such as X'40', 64, X'F0', 240 etc. are used and that there are no assumptions about EBCDIC versus ASCII collating sequences which have numbers and letters reversed, and EBCDIC letters are non-contiguous. Typically HLASM compatible programs are run in default EBCDIC mode and DCB RECFM=FT|VT or some other translation option is used to convert between EBCDIC and ASCII where necessary. Note there are a few instructions affected by ASCII mode: 1. ED/EDMK generate ASCII versus EBCDIC but the mask must always be in EBCDIC (masks are usually coded in X'...' format) 2. UNPK generates X'3' versus X'F' in zone field (high order nibble). Note on CHKMAC options: - 0 - no checking - 1 - check for missing AGO and AIF labels and issue warning - 2 - also check missing labels and also check for non comment text after MEND Note on CHKSRC options: - 0 - no checking - 1 - check MLC or BAL input source files for any non-ASCII characters and issue error - 2 - check MLC, MAC, CPY, and BAL input source files for any non-ASCII characters and issue error - 3 - also check for out of sequence characters in 73-80 or any non-blank characters beyond 80 and issue error - - Note this should detect any EBCDIC literal character strings containing non-ASCII characters such as binary 0 byte which must be changed to hex X'00' type strings for portability. Note on MNOTE options: - 0 - default generates MNOTE error/warning during mz390 and az390 - 1 - suppress mz390 error/warning and only pass MNOTE to az390 - 2 - generates MNOTE error/warning during mz390 and suppresses passing them on to az390","title":"z390 Options"},{"location":"user_guide/z390/z390_options/#tracing-options-and-equivalences","text":"TRACE will display every instruction executed along with address and value of each operand. Any combination of the following trace options can be set using the TRACE(...) option. TRACE(*) will also set TRACEALL. Note the &SYSTRACE global SETC variable can be used to turn any trace options on or off during execution. Option Scope Default Description TRACE E NO Turn on ez390 execution trace generation on TRE file and turn off CON. TRACE will display every instruction executed along with address and value of each operand. TRACEA or TRACE(A) A NO Turn on az390 assembly trace generation on TRA file and turn off CON. TRACEA will display each BAL statement during each pass of the assembler. TRACEC or TRACE(C) M NO Trace copy file code for TRACEM and TRACEP. The default is NOTRACEC to eliminate redundant code that usually just contains global variable declarations. TRACEG or TRACE(G) E NO Turn on ez390 emulator trace generation on TRE file with trace of GETMAIN/FREEMAIN FQE memory management control block changes and turn off CON. TRACEI or TRACE(I) M NO TRACEI will trace each AINSERT showing source on the TRM trace file. TRACEL or TRACE(L) L NO Turn on lz390 linker trace generation on TRL file and turn off CON. TRACEL shows each CSECT, ENTRY, EXTRN and OBJ file being loaded. TRACEM or TRACE(M) M NO Turn on mz390 macro processor trace generation on TRM file and turn off CON. TRACEM displays each conditional macro statement executed plus stored values and AIF compare values. TRACEP or TRACE(P) M NO Turn on mz390 macro processor pseudo code generation and execution trace on TRM file and turn off CON. TRACEP shows each conditional macro pseudo operation performed for each conditional macro statement and the values of all variables. TRACEQ or TRACE(Q) E NO Turn on ez390 emulator QSAM/BSAM DCB I/O trace generation on TRE file and turn off CON. TRACES or TRACE(S) M NO Display MLC source lines on console regardless of CON setting to help locate any loops, waits, or hangs in large macro process. If MCALL is also on, then *MCALL and *MEXIT comments will also be displayed to show location with nested macros. TRACET or TRACE(T) E NO Turn on ez390 emulator TGET/TPUT and TCP/IO trace generation on TRE file and turn off CON. TRACEV or TRACE(V) E NO Turn on ez390 emulator VSAM ACB/RPL I/O trace generation on TRE file and turn off CON. TRACEALL MALE NO Turn on all trace options generating TRM, TRA, TRL, and TRE files and turn off CON.","title":"Tracing options and equivalences"},{"location":"user_guide/z390/z390_options/#machine-and-optable-options-and-equivalences","text":"Machine Machine Optable Optable Description S360-20 360-20 z390 extension: S360-20 specific subset of DOS instructions DOS S370 370 S370XA ARCH-0 XA S370ESA ARCH-1 ESA Synonyms for ESA S390 ARCH-2 ESA S390E ARCH-3 ESA ARCH-4 ESA zSeries ZSeries-1 ZS1 ZOP Synonyms for ZOP ZS ZS-1 ZS1 ZOP z800 z900 ZS1 ZOP ARCH-5 ZS1 ZOP z890 z990 ZS2 YOP Synonyms for YOP zSeries-2 ZS-2 ZS2 YOP ARCH-6 ZS2 YOP zSeries-3 ZS-3 ZS3 Z9 Synonyms for Z9 z9 ARCH-7 ZS3 Z9 zSeries-4 ZS-4 ZS4 Z10 Synonyms for Z10 z10 ARCH-8 ZS4 Z10 zSeries-5 ZS-5 ZS5 Z11 Synonyms for Z11 z114 z196 ZS5 Z11 z11 ARCH-9 ZS5 Z11 zSeries-6 ZS-6 ZS6 Z12 Synonyms for Z12 zBC12 zEC12 ZS6 Z12 z12 ARCH-10 ZS6 Z12 zSeries-7 ZS-7 ZS7 Z13 Synonyms for Z13 z13 ARCH-11 ZS7 Z13 zSeries-8 ZS-8 ZS8 Z14 Synonyms for Z14 z14 ARCH-12 ZS8 Z14 zSeries-9 ZS-9 ZS9 Z15 Synonyms for Z15 z15 ARCH-13 ZS9 Z15 zSeries-10 ZS-10 ZSA Z16 Synonyms for Z16 z16 ARCH-14 ZSA Z16 UNI All current instructions from optables above [DFLT] Cannot be specified, same as UNI plus one z390 directive for zCobol support z390 UNI plus all z390 instructions; not compatible with HLASM Remark: there is no machine option keyword equivalent for optable(DOS). Remark: option allow adds z390 instructions to specified optable. Remark: option assist adds ASSIST instructions to specified optable.","title":"Machine and optable options and equivalences"},{"location":"user_guide/zCICS/","text":"Manuals http://www.z390.org/cics/z390_EXEC_CICS_Assembler_and_COBOL_Support.pdf http://www.z390.org/cics/zCICS_Readme.pdf zCICS Application Programming Guide http://www.z390.org/cics/zCICS_Basic_Mapping_Support.pdf http://www.z390.org/cics/zCICS_Diagnosis_Reference.pdf http://www.z390.org/cics/zCICS_History.pdf http://www.z390.org/cics/zCICS_Sequential_Terminal_Support.pdf http://www.z390.org/cics/zCICS_Supplied_Transactions.pdf http://www.z390.org/cics/zCICS_System_Programmers_Guide.pdf http://www.z390.org/cics/zCICS_VSAM_Guide.pdf","title":"Manuals"},{"location":"user_guide/zCICS/#manuals","text":"http://www.z390.org/cics/z390_EXEC_CICS_Assembler_and_COBOL_Support.pdf http://www.z390.org/cics/zCICS_Readme.pdf zCICS Application Programming Guide http://www.z390.org/cics/zCICS_Basic_Mapping_Support.pdf http://www.z390.org/cics/zCICS_Diagnosis_Reference.pdf http://www.z390.org/cics/zCICS_History.pdf http://www.z390.org/cics/zCICS_Sequential_Terminal_Support.pdf http://www.z390.org/cics/zCICS_Supplied_Transactions.pdf http://www.z390.org/cics/zCICS_System_Programmers_Guide.pdf http://www.z390.org/cics/zCICS_VSAM_Guide.pdf","title":"Manuals"},{"location":"user_guide/zCICS/zcics_app_prog_guide/","text":"zCICS Application Programming Guide Introduction The EXEC CICS commands and parameters listed here are the only ones currently supported in the zCICS environment. Differences between mainframe operation and zCICS are explained. For the operation of each command and parameter please refer to the Manuals listed in the Reference section at the end of this document. If you create your own zCICS applications, it would be wise to create a .BAT file that re-assembles them all in one go. The internal interfaces are volatile at present and this will be a frequent instruction. The current zCICS environment and all test programs can be re-assembled using DFHALL.BAT. The test VSAM catalog and files can be rebuilt using DFHALLV.BAT. Assembly notes The CICS option must be used when executing mz390 command. PROLOG and EPILOG are defaults. NOEPILOG is supported but not fully tested, testing and correct usage is scheduled for a future release of zCICS. PROLOG inserts the following: DFHEISTG Define the prefix areas of the Dynamic Storage Area (DSA). DFHEIEND Replaces the END statement and defines the end of the DSA. DFHEIENT Replaces the first CSECT statement Establish linkage and base registers GETMAIN the DSA Establish addressability to the EIB and TCTTE Some COMMAREA management Other macros DFHEIBLK - EIB DSECT DFHPCT - Transaction definition DFHFCT \u2013 File definitions and options EXEC - Converts EXEC CICS statements into a unique macro call with a parameter list DFHREGS \u2013 A synonym for EQUREGS Copy books DFHAID - Standard CICS equates for AID keys DFHBMSCA - Mapping support equates DFHPCTUS - User transaction codes DFHFCTUS - User file definitions Inclusion of the macro DFHREGS/EQUREGS is mandatory. Register Usage R0 - Reserved for internal use R1 - Reserved for internal use R10 - TCTTE address, must not be modified R11 - EIB address, must not be modified R12 - Default base register R13 - DSA address, must not be modified R14 - Reserved for internal use R15 - Reserved for internal use Multiple base registers (assembler only) The standard entry for a CICS program is as follows: e.g. DFHEISTG DSECT MYFIELD DS CL100 demo user field ...... MYPROG CSECT This standard method with the PROLOG option (default) will generate a single code base of R12 and a single DSA base of R13. If you want to extend the code base and/or the DSA base registers, convert your code in line with the sample given and include the NOPROLOG option in mz390 command. e.g. DFHEISTG MYFIELD DS CL100 demo user field ...... MYPROG DFHEIENT CODEREG=(R8,R5),DATAREG=(R13,R6,R7) Note You cannot override the first DATAREG value, it will always be R13. i.e. if you code DATAREG=(R6,R7) you will get DATAREG=(R13,R7) . There is no cross-checking for register conflicts. Assembler EXEC CICS command syntax There is no formal definition of an EXEC CICS command in any IBM CICS\u00ae Manual. These assembler syntaxes are currently supported. In-line space separated name EXEC CICS function subfunction parm parm() In-line comma separated name EXEC CICS function,subfunction,parm,parm(), parm () Split, space separated Non-blank in column 72 is assumed for all lines except the last. Comments are only allowed following a dot or comma delimiter on the last line. name EXEC CICS function X subfunction X parm X parm() parm (). a nice comment Split, comma separated Comments are allowed on all lines that end with comma+space. name EXEC CICS function, some X subfunction, very X parm, nice X parm(),parm (), comments name is supported and optional. EXEC CICS is expected, EXECUTE CICS is not currently supported. subfunction is optional and depends on the function but must follow function, e.g. EXEC CICS WRITEQ TS parm() without spacing and parm () with spacing are allowed. VSAM support See the zCICS VSAM Guide for guidance in the setup of a VSAM environment. This document also contains extensions to the VSAM facilities currently available. Basic Mapping Support The EXEC CICS commands RECEIVE MAP , SEND MAP and SEND CONTROL are documented here. For general BMS documentation and the mapping macros DFHMSD, DFHMDI and DFHMDF see the zCICS BMS Guide . zCOBOL support EXEC CICS command format follows the rules for COBOL. Each command must end END-EXEC (a following dot may affect the logic). Parameters like SET() which address imported structures may use the ADDRESS OF special register. LENGTH , FLENGTH and KEYLENGTH which would normally allow a numeric option may use the LENGTH OF special register. Extra Parameters You can add NOEDF to any EXEC CICS command if you wish that command to be excluded from a CEDF session. You can add NOEDF to the mz390 command if you wish all CEDF intercepts in that program excluded. Command reference - General Commands HANDLE AID name EXEC CICS HANDLE AID key(label) key Warning The following parameters are not supported. CLRPARTN LIGHTPEN OPERID TRIGGER Note ANYKEY (no label) clears all settings for CLEAR, PA and PF keys. Parameters key The key label label may take three forms: Direct reference Indirect reference Adcon literal EXEC CICS HANDLE AID PA1(GOPA1) PA2(INDGOPA1) PA3(=A(GOPA1)) ...... GOPA1 DS 0H ...... INDGOPA1 DC A(GOPA1) Info There is a current limit of 30 AIDs. Errors AN INTERNAL ERROR HAS OCCURRED NO PARAMETERS SPECIFIED NUMBER OF AIDS EXCEEDS 30 BAD PARM HANDLE TYPE NOT RECOGNISED HANDLE CONDITION name EXEC CICS HANDLE CONDITION condition(label) condition Parameters condition Name of the condition to handle label Location in program to branch to when condition occurs. label may take three forms: Direct reference Indirect reference Adcon literal EXEC CICS HANDLE CONDITION EOF(ISEOF) ...... ISEOF DS 0H Note There is a current limit of 30 conditions. DSIDERR is supported as a synonym to FILENOTFOUND . Errors AN INTERNAL ERROR HAS OCCURRED NUMBER OF CONDITIONS EXCEEDS 30 BAD PARM HANDLE TYPE NOT RECOGNISED IGNORE CONDITION name EXEC CICS IGNORE CONDITION condition Warning Ignoring an error may lead to unpredictable abends. There is a current limit of 30 conditions. Parameters INVREQ, PGMIDERR or ERROR by default. The EXEC CICS command treated as never existed. INVREQ on EXEC CICS RETURN will abend the task ASRA as z390 cannot ignore a RETURN. LENGERR or ERROR by default... NOHANDLE and any outstanding HANDLE AID will not invoke this condition. DSIDERR is supported as a synonym to FILENOTFOUND. Errors BAD PARM IGNORE TYPE NOT RECOGNISED AN INTERNAL ERROR HAS OCCURRED NO PARAMETERS SPECIFIED NUMBER OF CONDITIONS EXCEEDS 30 POP HANDLE name EXEC CICS POP HANDLE For the HANDLE ABEND, a POP is the equivalent of a HANDLE ABEND RESET. Errors BAD PARM POP TYPE NOT RECOGNISED Conditions (RESP/RESP2) INVREQ/0 PUSH HANDLE name EXEC CICS PUSH HANDLE For the HANDLE ABEND, a PUSH is the equivalent of a HANDLE ABEND CANCEL . Errors BAD PARM PUSH TYPE NOT RECOGNISED ADDRESS name EXEC CICS ADDRESS X COMMAREA(label) X CWA(label) X EIB(label) CWA has a different implementation in zCICS. See CWA Management in zCICS Diagnosis Reference for more information. Errors BAD PARM ASSIGN name EXEC CICS ASSIGN The following parameters are not supported: ACTIVITY,ACTIVITYID,ALTSCRNHT,ALTSCRNWD,APPLID,ASRAINTRPT,ASRAKEY,ASRASPC,ASRASTG,BRIDGE, DELIMITER,DESTCOUNT,DESTID,DESTIDLENG,GCHARS,GCODES,INITPARM,INITPARMLEN,INPARTN, LDCMNEM,LDCNUM,NETNAME,NUMTAB,OPCLASS,OPERKEYS,OPID,OPSECURITY,ORGABCODE,PAGENUM, PARTNPAGE,PARTNPAGE,PRINSYSID,PROCESS,PROCESSTYPE,QNAME,SIGDATA,STATIONID,SYSID, TELLERID,USERID,USERNAME Note zCICS allows a CWA size greater than 32K. If the CWA does exceed 32K, then ASSIGN CWALENG() will return an incorrect value. Conditions (RESP/RESP2) INVREQ/2 INVREQ/5 Errors BAD PARM Command reference - Terminal Control RECEIVE name EXEC CICS RECEIVE X INTO(label) X LENGTH(label) X NOHANDLE Parameters INTO(label) and LENGTH(label) are mandatory. LENGTH must point to a 2-byte field. Although MAXLENGTH is not implemented yet, there is an internal maximum length set to the implied length of the INTO label. NOHANDLE is optional. Conditions (RESP/RESP2) NOTALLOC/0 LENGERR/0 Errors BAD PARM BOTH INTO AND LENGTH ARE REQUIRED LENGTH ERROR SEND name EXEC CICS SEND FROM(label) LENGTH() Parameters FROM(label) is mandatory. label must point to a 2-byte hex value. label may take three forms: Direct reference Indirect reference Adcon literal LENGTH can be specified as LENGTH(value) or LENGTH(label) LENGTH(value) supports the use of the length attribute. The parameters TERMINAL, WAIT, DEFAULT and TEXT are discarded. Conditions (RESP/RESP2) INVREQ/0 - Attempt to execute this in a non-terminal attached task. This is not documented in the IBM CICS\u00ae Manuals. LENGERR/E1 Errors BAD PARM FROM IS MANDATORY LENGTH IS MANDATORY SEND CONTROL name EXEC CICS SEND CONTROL CURSOR/CURSOR() ERASE/ERASEAUP ALARM FREEKB FRSET Parameters TERMINAL and WAIT are accepted and discarded. ACCUM and SET are not supported. CURSOR() refers to the 24x80 screen. CURSOR is not documented. SEND CONTROL CURSOR ERASEAUP means erase all input fields and don't move the cursor. Conditions (RESP/RESP2) INVREQ/0 - Attempt to execute this in a non-terminal attached task. This is not documented in the IBM CICS\u00ae Manual. Errors BAD PARM CURSOR POSITION AND SYMBOLIC CURSOR SPECIFIED ERASE AND ERASEAUP SPECIFIED Command reference - File control READ name EXEC CICS READ FILE()/DATASET() INTO()/SET() LENGTH()/FLENGTH() RIDFLD() RBA/XRBA/RRN/GENERIC GTEQ/EQUAL KEYLENGTH() Parameters LENGTH Can be specified as a constant, literal or label. constant must not exceed 32767. A literal or label must be 2 bytes and must not exceed 32767. FLENGTH Can be specified as a constant, literal or label. A constant must not exceed 2G-1. A literal or label must be 4 bytes and must not exceed 2G-1. Info LENGTH/FLENGTH : If SET is specified, LENGTH/FLENGTH are ignored and LENGERR cannot occur. If INTO is specified and LENGTH/FLENGTH are not, then the implied length of INTO is used. This may raise the LENGERR condition if the data length is larger. If LENGTH/FLENGTH is numeric then it specifies the maximum data length that can be received. LENGERR can be raised if the data length is larger. If LENGTH/FLENGTH is a label then it specifies the maximum data length that can be received. LENGERR can be raised if the data length is larger. The true data length is returned in label. KEYLENGTH Can be specified as a constant or label. A constant must not exceed 32767. A label must be 2 bytes and must not exceed 32767. Keylengths greater than 128 are ignored. The parameter is ignored for ESDS and RRDS. KEYLENGTH and GENERIC must be paired. If KEYLENGTH is zero by constant or label then parameters are changed internally: GENERIC/EQUAL or GENERIC/GTEQ Becomes KEYLENGTH(1) Key=X'00' GENERIC GTEQ RBA RIDFLD has a 4-byte RBA XRBA RIDFLD has an 8-byte RBA RRN RIDFLD has a 4-byte relative record number GTEQ/EQUAL The parameter is ignored for ESDS and RRDS. GENERIC KEYLENGTH must be specified. The parameter is ignored for ESDS and RRDS. Errors BAD PARM BOTH FILE AND DATASET ARE SPECIFIED BOTH GTEQ AND EQUAL ARE SPECIFIED BOTH INTO AND SET ARE SPECIFIED BOTH LENGTH AND FLENGTH ARE SPECIFIED BOTH RBA AND XRBA ARE SPECIFIED BOTH RRN AND (X)RBA ARE SPECIFIED FILE OR DATASET MUST BE SPECIFIED GENERIC CANNOT BE SPECIFIED WITH RRN OR (X)RBA GENERIC REQUIRES KEYLENGTH INTO OR SET MUST BE SPECIFIED INVALID FILE OR DATASET KEYLENGTH REQUIRES GENERIC RIDFLD IS MANDATORY Conditions (RESP/RESP2) FILENOTFOUND/1 DISABLED/50 ILLOGIC/110 INVREQ/20 INVREQ/25 INVREQ/42 LENGERR/E1 NOTFND/80 NOTOPEN/60 Note FLENGTH and XRBA are extensions; do not use these parameters if the source code is likely to be ported back to a mainframe environment. RBA access to a KSDS is not supported. DATASET is supported for legacy applications. It is noted that this parameter no longer appears in the IBM CICS\u00ae Manuals. When conditions are raised as a result of a VSAM error, the RPL feedback codes (2 nd and 4 th bytes) are placed in EIBRCODE +1 and +2. STARTBR name EXEC CICS STARTBR FILE()/DATASET() RIDFLD() REQID() RBA/XRBA/RRN/GENERIC GTEQ/EQUAL KEYLENGTH() Parameters REQID Can be specified as a constant, literal or label. A constant must not exceed 32767. A literal or label must be 2 bytes and must not exceed 32767. If omitted, zero is assumed. RBA RIDFLD has a 4-byte RBA XRBA RIDFLD has an 8-byte RBA RRN RIDFLD has a 4-byte relative record number KEYLENGTH Can be specified as a constant or label. A constant must not exceed 32767. A label must be 2 bytes and must not exceed 32767. Keylengths greater than 128 are ignored. The parameter is ignored for ESDS and RRDS. KEYLENGTH and GENERIC must be paired. If KEYLENGTH is zero by constant or label then parameters are changed internally: GENERIC/EQUAL or GENERIC/GTEQ Becomes KEYLENGTH(1) Key=X'00' GENERIC GTEQ GTEQ/EQUAL The parameter is ignored for ESDS and RRDS. GENERIC KEYLENGTH must be specified. The parameter is ignored for ESDS and RRDS. Conditions (RESP/RESP2) DISABLED/50 FILENOTFOUND/1 ILLOGIC/110 INVREQ/20 INVREQ/25 INVREQ/33 INVREQ/42 NOTFND/80 NOTOPEN/60 Note NOTFND cannot occur for an ESDS or RRDS Errors BAD PARM BOTH FILE AND DATASET ARE SPECIFIED BOTH GTEQ AND EQUAL ARE SPECIFIED BOTH RBA AND XRBA ARE SPECIFIED BOTH RRN AND (X)RBA ARE SPECIFIED FILE OR DATASET MUST BE SPECIFIED GENERIC CANNOT BE SPECIFIED WITH RRN OR (X)RBA GENERIC REQUIRES KEYLENGTH INVALID FILE OR DATASET KEYLENGTH REQUIRES GENERIC RIDFLD IS MANDATORY READNEXT name EXEC CICS READNEXT FILE()/DATASET() INTO()/SET() LENGTH()/FLENGTH() RIDFLD() REQID() RBA/XRBA/RRN KEYLENGTH() Parameters LENGTH Can be specified as a constant, literal or label. A constant must not exceed 32767. A literal or label must be 2 bytes and must not exceed 32767. FLENGTH Can be specified as a constant, literal or label. A constant must not exceed 2G-1. A literal or label must be 4 bytes and must not exceed 2G-1. Info LENGTH/FLENGTH If either is not a label then: If INTO is specified, then the length received is the implied length of INTO. This may raise the LENGERR condition if the data length is larger. If SET is specified, the complete record is returned and LENGERR cannot occur. If either is a label then: If INTO or SET is specified, then it specifies the maximum data length that can be received. LENGERR can be raised if the data length is larger. The true data length is returned in label. REQID Can be specified as a constant, literal or label. A constant must not exceed 32767. A literal or label must be 2 bytes and must not exceed 32767. If omitted, zero is assumed. RBA RIDFLD has a 4-byte RBA XRBA RIDFLD has an 8-byte RBA RRN RIDFLD has a 4-byte relative record number KEYLENGTH Can be specified as a constant or label. A constant must not exceed 32767. A label must be 2 bytes and must not exceed 32767. Keylengths greater than 128 are ignored. The parameter is ignored for ESDS and RRDS. If KEYLENGTH is zero by constant or label then parameters are changed internally: GENERIC/EQUAL or GENERIC/GTEQ Becomes KEYLENGTH(1) Key=X'00' GENERIC GTEQ Errors BAD PARM BOTH FILE AND DATASET ARE SPECIFIED BOTH INTO AND SET ARE SPECIFIED BOTH LENGTH AND FLENGTH ARE SPECIFIED BOTH RBA AND XRBA ARE SPECIFIED BOTH RRN AND (X)RBA ARE SPECIFIED FILE OR DATASET MUST BE SPECIFIED INTO OR SET MUST BE SPECIFIED INVALID FILE OR DATASET RIDFLD IS MANDATORY THIS TYPE OF INTO REQUIRES LENGTH/FLENGTH Conditions (RESP/RESP2) DISABLED/50 ENDFILE/90 FILENOTFOUND/1 ILLOGIC/110 INVREQ/20 INVREQ/25 INVREQ/26 INVREQ/34 INVREQ/42 LENGERR/E1 NOTFND/80 NOTOPEN/60 READPREV name EXEC CICS READPREV FILE()/DATASET() INTO()/SET() LENGTH()/FLENGTH() RIDFLD() REQID() RBA/XRBA/RRN KEYLENGTH() Parameters LENGTH Can be specified as a constant, literal or label. A constant must not exceed 32767. A literal or label must be 2 bytes and must not exceed 32767. FLENGTH Can be specified as a constant, literal or label. A constant must not exceed 2G-1. A literal or label must be 4 bytes and must not exceed 2G-1. Info LENGTH/FLENGTH If either is not a label then: If INTO is specified, then the length received is the implied length of INTO. This may raise the LENGERR condition if the data length is larger. If SET is specified, the complete record is returned and LENGERR cannot occur. If either is a label then: If INTO or SET is specified, then it specifies the maximum data length that can be received. LENGERR can be raised if the data length is larger. The true data length is returned in label. REQID Can be specified as a constant, literal or label. A constant must not exceed 32767. A literal or label must be 2 bytes and must not exceed 32767. If omitted, zero is assumed. RBA RIDFLD has a 4-byte RBA XRBA RIDFLD has an 8-byte RBA RRN RIDFLD has a 4-byte relative record number KEYLENGTH Can be specified as a constant or label. A constant must not exceed 32767. A label must be 2 bytes and must not exceed 32767. Keylengths greater than 128 are ignored. The parameter is ignored for ESDS and RRDS. If KEYLENGTH is specified, the value must be equal to the keylength defined for the file. Errors BAD PARM BOTH FILE AND DATASET ARE SPECIFIED BOTH INTO AND SET ARE SPECIFIED BOTH LENGTH AND FLENGTH ARE SPECIFIED BOTH RBA AND XRBA ARE SPECIFIED BOTH RRN AND (X)RBA ARE SPECIFIED FILE OR DATASET MUST BE SPECIFIED INTO OR SET MUST BE SPECIFIED INVALID FILE OR DATASET RIDFLD IS MANDATORY THIS TYPE OF INTO REQUIRES LENGTH/FLENGTH Conditions (RESP/RESP2) DISABLED/50 ENDFILE/90 FILENOTFOUND/1 ILLOGIC/110 INVREQ/20 INVREQ/24 INVREQ/26 INVREQ/41 LENGERR/E1 NOTFND/80 NOTOPEN/60 Note ENDFILE can occur when a READPREV attempts to read past the beginning of the file. ENDBR name EXEC CICS ENDBR X FILE()/DATASET() X REQID() Parameters REQID Can be specified as a constant, literal or label. A constant must not exceed 32767. A literal or label must be 2 bytes and must not exceed 32767. If omitted, zero is assumed. Note In real CICS, ENDBR cannot cause a file to open, but it will in zCICS. The ENDBR command will be invalid, and may result in a transaction abend. Errors BAD PARM BOTH FILE AND DATASET ARE SPECIFIED FILE OR DATASET MUST BE SPECIFIED INVALID FILE OR DATASET Conditions (RESP/RESP2) DISABLED/50 FILENOTFOUND/1 ILLOGIC/110 INVREQ/20 INVREQ/35 NOTOPEN/60 RESETBR name EXEC CICS RESETBR FILE()/DATASET() RIDFLD() REQID() RBA/XRBA/RRN/GENERIC GTEQ/EQUAL KEYLENGTH() Parameters REQID Can be specified as a constant, literal or label. A constant must not exceed 32767. A literal or label must be 2 bytes and must not exceed 32767. If omitted, zero is assumed. RBA RIDFLD has a 4-byte RBA XRBA RIDFLD has an 8-byte RBA RRN RIDFLD has a 4-byte relative record number KEYLENGTH Can be specified as a constant or label. A constant must not exceed 32767. A label must be 2 bytes and must not exceed 32767. Keylengths greater than 128 are ignored. The parameter is ignored for ESDS and RRDS. KEYLENGTH and GENERIC must be paired. If KEYLENGTH is zero by constant or label then parameters are changed internally: GENERIC/EQUAL or GENERIC/GTEQ Becomes KEYLENGTH(1) Key=X'00' GENERIC GTEQ GTEQ/EQUAL The parameter is ignored for ESDS and RRDS. GENERIC KEYLENGTH must be specified. The parameter is ignored for ESDS and RRDS. Note In real CICS, RESETBR cannot cause a file to open, but it will in zCICS. The RESETBR command will be invalid, and may result in a transaction abend. Errors BAD PARM BOTH FILE AND DATASET ARE SPECIFIED BOTH GTEQ AND EQUAL ARE SPECIFIED BOTH RBA AND XRBA ARE SPECIFIED BOTH RRN AND (X)RBA ARE SPECIFIED FILE OR DATASET MUST BE SPECIFIED GENERIC CANNOT BE SPECIFIED WITH RRN OR (X)RBA GENERIC REQUIRES KEYLENGTH INVALID FILE OR DATASET KEYLENGTH REQUIRES GENERIC RIDFLD IS MANDATORY Conditions (RESP/RESP2) DISABLED/50 FILENOTFOUND/1 ILLOGIC/110 INVREQ/20 INVREQ/25 INVREQ/36 INVREQ/42 NOTFND/80 NOTOPEN/60 Note NOTFND cannot occur for an ESDS or RRDS Command reference - Storage Control FREEMAIN name EXEC CICS FREEMAIN X DATA()/DATAPOINTER() X DATA(label) Parameters label may only be an indirect reference to the address. DATAPOINTER Must be specified as a permitted general register value. Errors BAD PARM BOTH DATA AND DATAPOINTER ARE SPECIFIED DATA OR DATAPOINTER MUST BE SPECIFIED Conditions (RESP/RESP2) INVREQ/1 GETMAIN name EXEC CICS GETMAIN X SET() X LENGTH()/FLENGTH() X INITIMG() Parameters SET SET is mandatory Must be specified as a permitted general register value. LENGTH Can be specified as a constant, literal or label. A constant must not exceed 32767. A literal or label must be 2 bytes and must not exceed 32767. FLENGTH Can be specified as a constant, literal or label. A constant must not exceed 2G-1. A literal or label must be 4 bytes and must not exceed 2G-1. INITIMG Is optional If omitted, the storage contents are not predictable. Can be specified as a constant, literal or label. Info zCOBOL supports all 3 data types, but for mainframe COBOL programs only label is supported. Only the first byte generated by the parameter is used. Errors BAD PARM BOTH LENGTH AND FLENGTH ARE SPECIFIED LENGTH OR FLENGTH MUST BE SPECIFIED SET IS MANDATORY Command reference - Temporary Storage Control Note FLENGTH is an extension; do not use this parameter if the source code is likely to be ported back to a mainframe environment. DELETEQ name EXEC CICS DELETEQ TS QUEUE()/QNAME() Parameters The parameters MAIN and AUXILIARY are accepted and discarded. QUEUE QUEUE may be specified as: A quoted string which must not exceed 8 bytes. A label which points to an 8-byte field. A literal not exceeding 8 bytes. Only label or literal may be used to specify a QUEUE with hex characters. QNAME QNAME may be specified as: A quoted string which must not exceed 16 bytes. A label which points to a 16-byte field. A literal not exceeding 16 bytes. Only label or literal may be used to specify a QNAME with hex characters. Errors BAD PARM BOTH QUEUE AND QNAME ARE SPECIFIED DELETEQ TYPE NOT RECOGNIZED INVALID QUEUE OR QNAME QUEUE OR QNAME MUST BE SPECIFIED Conditions (RESP/RESP2) INVREQ/0 QIDERR/0 READQ name EXEC CICS READQ TS QUEUE()/QNAME() INTO()/SET() LENGTH()/FLENGTH() NUMITEMS() ITEM()/NEXT Parameters The parameters MAIN and AUXILIARY are accepted and discarded. QUEUE QUEUE may be specified as: A quoted string which must not exceed 8 bytes. A label which points to an 8-byte field. A literal not exceeding 8 bytes. Only label or literal may be used to specify a QUEUE with hex characters. QNAME QNAME may be specified as: A quoted string which must not exceed 16 bytes. A label which points to a 16-byte field. A literal not exceeding 16 bytes. Only label or literal may be used to specify a QNAME with hex characters. LENGTH May be specified as LENGTH(value) or LENGTH(label) LENGTH(value) supports the use of the length attribute. label must point to a 2-byte hex value. FLENGTH Can be specified as a constant, literal or label. A constant must not exceed 2G-1. A literal or label must be 4 bytes and must not exceed 2G-1. LENGTH/FLENGTH can be omitted. When they are, the implied length of INTO is used. LENGTH/FLENGTH is mandatory when SET is used. ITEM May be specified as ITEM(value) or ITEM(label) label must point to a 2-byte hex value. Errors BAD PARM BOTH INTO AND SET ARE SPECIFIED BOTH ITEM AND NEXT ARE SPECIFIED BOTH LENGTH AND FLENGTH ARE SPECIFIED BOTH QUEUE AND QNAME ARE SPECIFIED INTO OR SET MUST BE SPECIFIED INVALID QUEUE OR QNAME ITEM OR NEXT MUST BE SPECIFIED QUEUE OR QNAME MUST BE SPECIFIED READQ TYPE NOT RECOGNIZED SET REQUIRES LENGTH Conditions (RESP/RESP2) INVREQ/0 LENGERR/0 ITEMERR/0 QIDERR/0 WRITEQ name EXEC CICS WRITEQ TS QUEUE()/QNAME() FROM() LENGTH()/FLENGTH() NUMITEMS() ITEM() REWRITE Parameters The parameters MAIN and AUXILIARY are accepted and discarded. QUEUE QUEUE may be specified as: A quoted string which must not exceed 8 bytes. A label which points to an 8-byte field. A literal not exceeding 8 bytes. Only label or literal may be used to specify a QUEUE with hex characters. QNAME QNAME may be specified as: A quoted string which must not exceed 16 bytes. A label which points to a 16-byte field. A literal not exceeding 16 bytes. Only label or literal may be used to specify a QNAME with hex characters. FROM FROM(label) is mandatory. label may take three forms: Direct reference Indirect reference Adcon literal LENGTH May be specified as LENGTH(value) or LENGTH(label) LENGTH(value) supports the use of the length attribute. label must point to a 2-byte hex value. LENGTH can be omitted. When they are, the implied length of FROM is used. LENGTH is mandatory when FROM is an indirect reference. FLENGTH Can be specified as a constant, literal or label. A constant must not exceed 2G-1. A literal or label must be 4 bytes and must not exceed 2G-1. FLENGTH can be omitted. When they are, the implied length of FROM is used. FLENGTH is mandatory when FROM is an indirect reference. ITEM May be specified as ITEM(value) or ITEM(label) label must point to a 2-byte hex value. Info For compatibility with old releases of CICS, ITEM is accepted without REWRITE and becomes NUMITEMS. ITEM must be a label in this case. Errors BAD PARM BOTH LENGTH AND FLENGTH ARE SPECIFIED BOTH QUEUE AND QNAME ARE SPECIFIED FROM IS MANDATORY IF NUMITEMS IS SPECIFIED, ITEM AND REWRITE ARE INVALID INVALID QUEUE OR QNAME LENGTH/FLENGTH IS MANDATORY FOR INDIRECT FROM LENGTH WITHOUT FROM NUMITEMS MUST BE A LABEL (MAY HAVE ORIGINATED AS ITEM) QUEUE OR QNAME MUST BE SPECIFIED REWRITE REQUIRES ITEM WRITEQ TYPE NOT RECOGNIZED Conditions (RESP/RESP2) INVREQ/0 LENGERR/0 ITEMERR/0 QIDERR/0 Command reference - Program Control ABEND name EXEC CICS ABEND ABCODE() CANCEL NODUMP Parameters ABCODE ABCODE can be specified as ABCODE('xxxx') or ABCODE(label) label must point to a 4-byte field. Errors ABCODE MUST NOT BEGIN WITH 'A' ABCODE IS INVALID BAD PARM HANDLE ABEND name EXEC CICS HANDLE ABEND CANCEL name EXEC CICS HANDLE ABEND RESET name EXEC CICS HANDLE ABEND LABEL(label) name EXEC CICS HANDLE ABEND PROGRAM() Parameters LABEL label may take three forms: Direct reference Indirect reference Adcon literal PROGRAM Can be specified as PROGRAM('xxxxxxxx') or PROGRAM(label) label must point to an 8-byte field. Any received COMMAREA when the EXEC CICS HANDLE ABEND is issued is passed to the handling program when an abend occurs. Note When an XCTL is executed, any HANDLE ABEND LABEL at the current logical level is cleared as the current program is no longer in use. HANDLE ABEND PROGRAMs are not cleared. Errors BAD PARM HANDLE TYPE NOT RECOGNISED INVALID PROGRAM NO PARAMETERS SPECIFIED PARMS MISSING OR TOO MANY PARMS LINK name EXEC CICS LINK PROGRAM() COMMAREA(label) LENGTH() CHANNEL() Executes another CICS program. Return is to the linker. In zCICS both CHANNEL and COMMAREA may be specified. A warning MNOTE is issued. Parameters PROGRAM PROGRAM is mandatory Can be specified as PROGRAM('xxxxxxxx') or PROGRAM(label) label must point to an 8-byte field. COMMAREA COMMAREA(label) is optional If COMMAREA is present, the address/length are passed. label may take three forms: Direct reference Indirect reference Adcon literal LENGTH Can be specified as LENGTH(value) or LENGTH(label) LENGTH(value) supports the use of the length attribute. label must point to a 2-byte hex value. LENGTH can be omitted. When it is, the implied length of the COMMAREA is used. LENGTH is mandatory when COMMAREA is an indirect reference. Errors BAD PARM INVALID CHANNEL INVALID PROGRAM PROGRAM IS MISSING LENGTH IS MANDATORY FOR INDIRECT COMMAREA LENGTH WITHOUT COMMAREA Warning CHANNEL and COMMAREA specified Conditions (RESP/RESP2) CHANNELERR/1 PGMIDERR/3 LOAD name EXEC CICS LOAD PROGRAM() ENTRY()/SET() LENGTH(label) FLENGTH(label) Loads a module. The intention in the zCICS environment is to load a table or some other data, not an executable program. Parameters PROGRAM PROGRAM is mandatory Can be specified as PROGRAM('xxxxxxxx') or PROGRAM(label) label must point to an 8-byte field. At present, only modules with a suffix of .390 may be LOADed. ENTRY/SET ENTRY and SET are optional Must be specified as a permitted general register value. Both are equivalent in zCICS. LENGTH LENGTH is optional LENGTH(label) is the only format. label must point to a 2-byte field. FLENGTH FLENGTH is optional FLENGTH(label) is the only format. label must point to a 4-byte field. Note At task end the LOADed module is not RELEASEd. Errors BAD PARM INVALID PROGRAM LENGTH AND FLENGTH SPECIFIED PROGRAM IS MISSING Conditions (RESP/RESP2) PGMIDERR/3 RELEASE name EXEC CICS RELEASE PROGRAM() Releases a previously loaded module. Parameters PROGRAM PROGRAM is mandatory Can be specified as PROGRAM('xxxxxxxx') or PROGRAM(label) label must point to an 8-byte field. Errors BAD PARM INVALID PROGRAM PROGRAM IS MISSING Conditions (RESP/RESP2) INVREQ/5 INVREQ/6 RETURN name EXEC CICS RETURN TRANSID() COMMAREA(label) LENGTH() CHANNEL() IMMEDIATE Returns to the last caller. In zCICS both CHANNEL and COMMAREA may be specified. A warning MNOTE is issued. Parameters TRANSID Optional, but when COMMAREA is specified, TRANSID is mandatory. Can be specified as TRANSID('xxxx') or TRANSID(label) label must point to a 4-byte field. COMMAREA COMMAREA(label) is optional label may take three forms: * Direct reference * Indirect reference * Adcon literal LENGTH Can be specified as LENGTH(value) or LENGTH(label) LENGTH(value) supports the use of the length attribute. label must point to a 2-byte hex value. LENGTH can be omitted. When it is, the implied length of the COMMAREA is used. LENGTH is mandatory when COMMAREA is an indirect reference. Errors BAD PARM IMMEDIATE REQUIRES TRANSID INVALID CHANNEL INVALID TRANSID TRANSID IS MISSING LENGTH IS MANDATORY FOR INDIRECT COMMAREA LENGTH WITHOUT COMMAREA Warning CHANNEL and COMMAREA specified Conditions (RESP/RESP2) See the section on IGNORE CONDITION for these conditions. CHANNELERR/1 INVREQ/1 INVREQ/2 XCTL name EXEC CICS XCTL PROGRAM() COMMAREA(label) LENGTH() CHANNEL() Executes another CICS program. In zCICS both CHANNEL and COMMAREA may be specified. A warning MNOTE is issued. If COMMAREA is present and both the address and length are the same as passed to the current program, then address/length are passed to the new program. If the address or length differs, then a copy of the COMMAREA is taken and the new address/length are passed to the new program. Return is to the last linker. Parameters PROGRAM PROGRAM is mandatory Can be specified as PROGRAM('xxxxxxxx') or PROGRAM(label) label must point to an 8-byte field. COMMAREA COMMAREA(label) is optional label may take three forms: Direct reference Indirect reference Adcon literal LENGTH Can be specified as LENGTH(value) or LENGTH(label) LENGTH(value) supports the use of the length attribute. label must point to a 2-byte hex value. LENGTH can be omitted. When it is, the implied length of the COMMAREA is used. LENGTH is mandatory when COMMAREA is an indirect reference. Errors BAD PARM INVALID CHANNEL INVALID PROGRAM PROGRAM IS MISSING LENGTH IS MANDATORY FOR INDIRECT COMMAREA LENGTH WITHOUT COMMAREA Warning CHANNEL and COMMAREA specified Conditions (RESP/RESP2) CHANNELERR/1 PGMIDERR/3 Command reference - Interval control Note FLENGTH is an extension; do not use this parameter if the source code is likely to be ported back to a mainframe environment. ASKTIME name EXEC CICS ASKTIME X ABSTIME() Errors BAD PARM DELAY name EXEC CICS DELAY REQID() INTERVAL()/TIME() FOR/UNTIL HOURS() MINUTES() SECONDS() INTERVAL Parameters INTERVAL Can be specified as INTERVAL(s) through to INTERVAL(hhmmss). INTERVAL(234) means wait for 2 minutes 34 seconds. INTERVAL(label) is also permitted (extension). label must point to a 6-byte character field with leading character zeros as needed. name EXEC CICS DELAY INTERVAL(MYTIME) ...... MYTIME DC C'000234' TIME Can be specified as TIME(s) through to TIME(hhmmss). TIME(234) means resume the task at 2 minutes 34 seconds after midnight. Expiration time rules apply; see the IBM CICS\u00ae Application Programming Guide. TIME(label) is also permitted (extension). label must point to a 6-byte character field with leading character zeros as needed. name EXEC CICS DELAY TIME(MYTIME) ...... MYTIME DC C'000234' FOR HOURS() MINUTES() SECONDS() FOR is an alternative to INTERVAL. HOURS/MINUTES/SECONDS must be numeric values. UNTIL HOURS() MINUTES() SECONDS() UNTIL is an alternative to TIME. HOURS/MINUTES/SECONDS must be numeric values. The result from the parameters is a time-of-day. UNTIL SECONDS(10000) means resume the task at 02:46:40. Expiration time rules apply; see the IBM CICS\u00ae Application Programming Guide. If no parameters are specified, then DELAY INTERVAL(0) is assumed. Errors BAD PARM BOTH FOR AND UNTIL ARE SPECIFIED BOTH INTERVAL AND TIME ARE SPECIFIED FOR/UNTIL SPECIFIED, BUT NO TIME PARMS HOURS/MINUTES/SECONDS ARE INVALID WITH INTERVAL OR TIME HOURS/MINUTES/SECONDS ARE SPECIFIED WITHOUT FOR/UNTIL INTERVAL/TIME CANNOT BE SPECIFIED WITH FOR/UNTIL INTERVAL/TIME MUST BE 1 TO 6 BYTES INVALID REQID Conditions (RESP/RESP2) INVREQ/4 INVREQ/5 INVREQ/6 FORMATTIME name EXEC CICS FORMATTIME Refer to IBM CICS\u00ae Application Programming reference for available parameters. Note STRINGFORMAT is discarded as there is only one option. DATESEP(label) and TIMESEP(label) are added as extensions. Only the first byte is used. DATESTRING returns the following 25-byte string. \"Mon, 17 Dec 2007 10:20:30\". The time zone (e.g. GMT) is not returned. Errors ABSTIME IS MANDATORY BAD PARM Conditions (RESP/RESP2) INVREQ/1 START name EXEC CICS START TRANSID() INTERVAL()/TIME() TERMID() REQID() FROM() LENGTH()/FLENGTH() CHANNEL() QUEUE() RTRANSID() RTERMID() AFTER/AT HOURS() MINUTES() SECONDS() Warning USERID is not supported. Parameters In zCICS both CHANNEL and other parms may be specified. A warning MNOTE is issued. INTERVAL and TIME follow the same syntax and rules as for DELAY. AFTER and AT follow the same syntax and rules as FOR and UNTIL in DELAY above. Errors AFTER/AT SPECIFIED, BUT NO TIME PARAMETERS BAD PARM BOTH AFTER AND AT ARE SPECIFIED BOTH INTERVAL AND TIME ARE SPECIFIED BOTH LENGTH AND FLENGTH ARE SPECIFIED FROM/(F)LENGTH MUST BOTH BE MISSING OR BOTH SPECIFIED HOURS/MINUTES/SECONDS ARE INVALID WITH INTERVAL OR TIME HOURS/MINUTES/SECONDS ARE SPECIFIED WITHOUT AFTER/AT INTERVAL/TIME CANNOT BE SPECIFIED WITH AFTER/AT INTERVAL/TIME MUST BE 1 TO 6 BYTES INVALID CHANNEL INVALID QUEUE INVALID REQID INVALID RTERMID INVALID RTRANSID INVALID TERMID INVALID TRANSID TRANSID IS MANDATORY Warning CHANNEL AND OTHER PARMS SPECIFIED BUT ALLOWED Conditions (RESP/RESP2) CHANNELERR/1 INVREQ/0 INVREQ/4 INVREQ/5 INVREQ/6 IOERR LENGERR TERMIDERR TRANSIDERR RETRIEVE name EXEC CICS RETRIEVE INTO()/SET() LENGTH()/FLENGTH() RTRANSID() RTERMID() QUEUE() Warning WAIT is not supported. Errors BAD PARM BOTH INTO AND SET ARE SPECIFIED BOTH LENGTH AND FLENGTH ARE SPECIFIED INTO OR SET MUST BE SPECIFIED INVALID QUEUE INVALID RTERMID INVALID RTRANSID LENGTH OR FLENGTH MUST BE A LABEL SET REQUIRES LENGTH OR FLENGTH Conditions (RESP/RESP2) INVREQ/0 ENDDATA ENVDEFERR LENGERR CANCEL name EXEC CICS CANCEL REQID() Warning TRANSID is not supported. Errors BAD PARM INVALID REQID REQID IS MANDATORY Conditions (RESP/RESP2) INVREQ NOTFND Command reference - Task Control ENQ name EXEC CICS ENQ RESOURCE() LENGTH() NOSUSPEND Parameters LENGTH Can be specified as LENGTH(value) or LENGTH(label) LENGTH(value) supports the use of the length attribute. Errors BAD PARM RESOURCE IS MANDATORY Warning ENQ on address may not work in zCICS but the command will be processed. Conditions (RESP/RESP2) ENQBUSY LENGERR/1 DEQ name EXEC CICS DEQ RESOURCE() LENGTH() Parameters LENGTH Can be specified as LENGTH(value) or LENGTH(label) LENGTH(value) supports the use of the length attribute. Errors BAD PARM RESOURCE IS MANDATORY Conditions (RESP/RESP2) LENGERR/1 Command reference - BMS RECEIVE name EXEC CICS RECEIVE MAP() MAPSET() INTO() Parameters Warning TERMINAL and ASIS are accepted and discarded. SET, FROM and LENGTH are not supported. MAP MAP can be a quoted string, maximum 7 characters or a label pointing to a 7-byte field. If MAP is a label, then INTO is mandatory. The map structure will not be cleared before the mapping takes place. If MAP is a string, then INTO is optional. If INTO is omitted, the default is map.I The map structure will be cleared before the mapping takes place. MAPSET MAPSET can be a quoted string, maximum 7 characters or an address pointing to an 8-byte field containing no more than 7 characters. If MAPSET is omitted, then the MAPname is used. Errors BAD PARM FROM NOT SUPPORTED INTO IS REQUIRED WHEN MAP IS A LABEL INVALID MAP NAME INVALID MAPSET NAME LENGTH NOT SUPPORTED MAP IS MANDATORY Conditions (RESP/RESP2) Note EIBRESP2 is an extension for MAPFAIL; please see the zCICS BMS Guide for more information. Many of the conditions can arise through a mismatch of map and structure. Typically a map is re-assembled but the programs using it are not. INVMPSZ/0 MAPFAIL/1 The map cannot be found in the mapset. MAPFAIL/2 A short read key (CLEAR or PA) has been pressed or there are no modified fields. MAPFAIL/3 Data has been received, but there are no named fields in the map. MAPFAIL/4 An SBA has been located, but there is no field in the map that matches. MAPFAIL/5 An SBA has been located, but it matches an unnamed field. MAPFAIL/6 The data received for this field is longer than the DFHMDF LENGTH= parameter. MAPFAIL/7 There has been a mismatch between the physical map and the DSECT. MAPFAIL/8 Data to be processed by PICIN is over 31 digits. Data is not numeric after being PACKed. Data length is greater than the edit pattern allows. INVREQ/0 SEND name EXEC CICS SEND MAP() MAPSET() CURSOR/CURSOR() DATAONLY/MAPONLY ERASE/ERASEAUP FROM() LENGTH() ALARM FREEKB FRSET SET() Parameters Warning TERMINAL and WAIT are accepted and discarded. ACCUM is not supported. MAP MAP can be a quoted string, maximum 7 characters or a label pointing to a 7-byte field. If MAP is a label, then FROM is mandatory. If MAP is a string, then FROM and/or LENGTH are optional. If FROM is omitted, the default is map.O If LENGTH is omitted, the default is map.L LENGTH LENGTH is supported but the value used is always that of the structure length. Can be specified as LENGTH(value) or LENGTH(label) LENGTH(value) supports the use of the length attribute. label must point to a 2-byte hex value. MAPSET MAPSET can be a quoted string, maximum 7 characters or a label pointing to an 8-byte field containing no more than 7 characters. If MAPSET is omitted, then MAP is used. SET SET() is currently intended to be an internal parameter. Warning SET does not conform to the standard used for BMS PAGING. Errors BAD PARM CONTROL IS NOT COMPATABLE WITH SEND MAP CURSOR POSITION AND SYMBOLIC CURSOR SPECIFIED DATAONLY AND MAPONLY SPECIFIED ERASE AND ERASEAUP SPECIFIED FROM IS REQUIRED WHEN MAP IS A LABEL INVALID MAP NAME INVALID MAPSET NAME MAP IS MANDATORY Conditions (RESP/RESP2) Note EIBRESP2 is an extension for MAPFAIL See zCICS BMS Guide for more information. INVMPSZ/0 MAPFAIL/1 The map cannot be found in the mapset. MAPFAIL/8 Data to be processed by PICOUT is over 31 digits. Data is not numeric after being PACKed. Data length is greater than the edit pattern allows. MAPFAIL/9 Override field or colour attribute is invalid INVREQ/0 Attempt to execute this in a non-terminal attached task. This is not documented in the IBM CICS\u00ae Manuals. SEND CONTROL CURSOR/CURSOR() ERASE/ERASEAUP ALARM FREEKB FRSET Command reference - Dump Control DUMP name EXEC CICS DUMP TRANSACTION DUMPCODE() COMPLETE FROM() LENGTH()/FLENGTH() SEGMENTLIST() LENGTHLIST() NUMSEGMENTS() Parameters TRANSACTION is mandatory. DUMPCODE is mandatory and can be a constant or label. label must point to a 4-byte field. No syntax checking is done. COMPLETE If there are no storage area parameters then COMPLETE is the default. Produces a SNAP dump ID=997,TEXT='DUMP dddd COMPLETE' If there are storage area parameters and COMPLETE is not specified, only the storage areas are dumped. FROM() LENGTH()/FLENGTH() Produces a SNAP dump ID=997,TEXT='DUMP dddd AREA' LENGTH Can be specified as a constant or label. A constant must not exceed 32767. A label must be 2 bytes and must not exceed 32767. FLENGTH Can be specified as a constant or label. A constant must not exceed 2G-1. A label must be 4 bytes and must not exceed 2G-1. SEGMENTLIST/LENGTHLIST/NUMSEGMENTS Produces multiple SNAP dumps ID=997,TEXT='DUMP dddd SEGMENT nnn' NUMSEGMENTS Can be specified as a constant or label. A constant must not exceed 2G-1. A label must be 4 bytes and must not exceed 2G-1. Errors BAD PARM BOTH LENGTH AND FLENGTH ARE SPECIFIED DUMPCODE IS GREATER THAN 4 BYTES DUMPCODE MUST BE SPECIFIED LENGTH OR FLENGTH REQUIRES FROM LENGTH OR FLENGTH MUST BE SPECIFIED SEGMENTLIST, LENGTHLIST AND NUMSEGMENTS MUST ALL BE SPECIFIED OR ALL ABSENT TRANSACTION MUST BE SPECIFIED Command reference - Inquire INQUIRE FILE name EXEC CICS INQUIRE FILE START name EXEC CICS INQUIRE FILE START AT() name EXEC CICS INQUIRE FILE END name EXEC CICS INQUIRE FILE() NEXT ... name EXEC CICS INQUIRE FILE() ... Parameters The following parameters are supported: ACCESSMETHOD ADD BASEDSNAME BROWSE DELETE DSNAME ENABLESTATUS KEYLENGTH KEYPOSITION OBJECT OPENSTATUS READ RECORDFORMAT RECORDSIZE TYPE UPDATE BASEDSNAME() DSNAME() The length of data returned is the implied length of the data area to a maximum of 128 bytes. Errors AT() IS SPECIFIED WITHOUT START BAD PARM FILE DOES NOT PRECEDE END FILE DOES NOT PRECEDE START FILE() CANNOT BE A STRING WHEN NEXT IS SPECIFIED FILE() IS MISSING INQUIRE TYPE NOT RECOGNIZED INVALID AT() INVALID FILE() NEXT AND END ARE SPECIFIED START AND END ARE SPECIFIED SET FILE name EXEC CICS SET FILE()/DATASET() ... Parameters The following parameters are supported: ADD() ADDABLE NOTADDABLE BROWSE() BROWSABLE NOTBROWSABLE DELETE() DELETABLE NOTDELETABLE ENABLESTATUS() ENABLED DISABLED OPENSTATUS() OPEN CLOSED READ() READABLE NOTREADABLE UPDATE() UPDATABLE NOTUPDATABLE Errors BAD PARM BOTH FILE AND DATASET SPECIFIED FILE OR DATASET MUST BE SPECIFIED INVALID FILE OR DATASET MORE THAN ONE ADD PARAMETER MORE THAN ONE BROWSE PARAMETER MORE THAN ONE DELETE PARAMETER MORE THAN ONE ENABLESTATUS PARAMETER MORE THAN ONE OPEN STATUS PARAMETER MORE THAN ONE READ PARAMETER MORE THAN ONE UPDATE PARAMETER Conditions (RESP/RESP2) FILENOTFOUND INVREQ/2 INVREQ/3 INVREQ/4 INVREQ/5 INVREQ/7 INVREQ/12 INVREQ/14 INVREQ/16 INVREQ/17 IOERR Command reference - Channel and containers GET name EXEC CICS GET CONTAINER() CHANNEL() INTO()/FLENGTH() SET()/FLENGTH() NODATA/FLENGTH() Errors BAD PARM BOTH INTO AND SET SPECIFIED CONTAINER IS MANDATORY INTO AND NODATA SPECIFIED INTO OR SET OR NODATA IS REQUIRED INVALID CHANNEL INVALID CONTAINER NODATA REQUIRES FLENGTH SET AND NODATA SPECIFIED SET OR NODATA REQUIRES FLENGTH AS LABEL SET REQUIRES FLENGTH Conditions (RESP/RESP2) CHANNELERR/2 INVREQ/4 LENGERR/11 PUT name EXEC CICS PUT CONTAINER() CHANNEL() FROM()/FLENGTH() Errors BAD PARM CONTAINER IS MANDATORY FLENGTH IS MANDATORY FOR INDIRECT FROM FLENGTH WITHOUT FROM FROM IS MANDATORY INVALID CHANNEL INVALID CONTAINER Conditions (RESP/RESP2) CHANNELERR/1 CONTAINERERR/18 INVREQ/4 LENGERR/1 DELETE name EXEC CICS DELETE CONTAINER() CHANNEL() Errors BAD PARM CONTAINER IS MANDATORY INVALID CHANNEL INVALID CONTAINER Conditions (RESP/RESP2) CHANNELERR/2 CONTAINERERR/10 MOVE name EXEC CICS MOVE CONTAINER() AS() CHANNEL() TOCHANNEL() Errors BAD PARM CONTAINER AND/OR AS ARE MISSING INVALID AS INVALID CHANNEL INVALID CONTAINER INVALID TOCHANNEL Conditions (RESP/RESP2) CHANNELERR/1 CHANNELERR/2 CONTAINERERR/10 CONTAINERERR/18 INVREQ/4 STARTBROWSE name EXEC CICS STARTBROWSE CONTAINER CHANNEL() BROWSETOKEN() Errors BAD PARM INVALID CHANNEL BROWSETOKEN IS MANDATORY STARTBROWSE TYPE NOT RECOGNISED Conditions (RESP/RESP2) ACTIVITYERR/2 CHANNELERR/2 GETNEXT name EXEC CICS GETNEXT CONTAINER() BROWSETOKEN() Errors BAD PARM BROWSETOKEN IS MANDATORY CONTAINER IS MANDATORY Conditions (RESP/RESP2) END/2 TOKENERR/3 ENDBROWSE name EXEC CICS ENDBROWSE CONTAINER BROWSETOKEN() Errors BAD PARM BROWSETOKEN IS MANDATORY ENDBROWSE TYPE NOT RECOGNISED Condition (RESP/RESP2) TOKENERR/3","title":"zCICS Application Programming Guide"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#zcics-application-programming-guide","text":"","title":"zCICS Application Programming Guide"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#introduction","text":"The EXEC CICS commands and parameters listed here are the only ones currently supported in the zCICS environment. Differences between mainframe operation and zCICS are explained. For the operation of each command and parameter please refer to the Manuals listed in the Reference section at the end of this document. If you create your own zCICS applications, it would be wise to create a .BAT file that re-assembles them all in one go. The internal interfaces are volatile at present and this will be a frequent instruction. The current zCICS environment and all test programs can be re-assembled using DFHALL.BAT. The test VSAM catalog and files can be rebuilt using DFHALLV.BAT. Assembly notes The CICS option must be used when executing mz390 command. PROLOG and EPILOG are defaults. NOEPILOG is supported but not fully tested, testing and correct usage is scheduled for a future release of zCICS. PROLOG inserts the following: DFHEISTG Define the prefix areas of the Dynamic Storage Area (DSA). DFHEIEND Replaces the END statement and defines the end of the DSA. DFHEIENT Replaces the first CSECT statement Establish linkage and base registers GETMAIN the DSA Establish addressability to the EIB and TCTTE Some COMMAREA management","title":"Introduction"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#other-macros","text":"DFHEIBLK - EIB DSECT DFHPCT - Transaction definition DFHFCT \u2013 File definitions and options EXEC - Converts EXEC CICS statements into a unique macro call with a parameter list DFHREGS \u2013 A synonym for EQUREGS","title":"Other macros"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#copy-books","text":"DFHAID - Standard CICS equates for AID keys DFHBMSCA - Mapping support equates DFHPCTUS - User transaction codes DFHFCTUS - User file definitions Inclusion of the macro DFHREGS/EQUREGS is mandatory.","title":"Copy books"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#register-usage","text":"R0 - Reserved for internal use R1 - Reserved for internal use R10 - TCTTE address, must not be modified R11 - EIB address, must not be modified R12 - Default base register R13 - DSA address, must not be modified R14 - Reserved for internal use R15 - Reserved for internal use","title":"Register Usage"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#multiple-base-registers-assembler-only","text":"The standard entry for a CICS program is as follows: e.g. DFHEISTG DSECT MYFIELD DS CL100 demo user field ...... MYPROG CSECT This standard method with the PROLOG option (default) will generate a single code base of R12 and a single DSA base of R13. If you want to extend the code base and/or the DSA base registers, convert your code in line with the sample given and include the NOPROLOG option in mz390 command. e.g. DFHEISTG MYFIELD DS CL100 demo user field ...... MYPROG DFHEIENT CODEREG=(R8,R5),DATAREG=(R13,R6,R7) Note You cannot override the first DATAREG value, it will always be R13. i.e. if you code DATAREG=(R6,R7) you will get DATAREG=(R13,R7) . There is no cross-checking for register conflicts.","title":"Multiple base registers (assembler only)"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#assembler-exec-cics-command-syntax","text":"There is no formal definition of an EXEC CICS command in any IBM CICS\u00ae Manual. These assembler syntaxes are currently supported.","title":"Assembler EXEC CICS command syntax"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#in-line-space-separated","text":"name EXEC CICS function subfunction parm parm()","title":"In-line space separated"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#in-line-comma-separated","text":"name EXEC CICS function,subfunction,parm,parm(), parm ()","title":"In-line comma separated"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#split-space-separated","text":"Non-blank in column 72 is assumed for all lines except the last. Comments are only allowed following a dot or comma delimiter on the last line. name EXEC CICS function X subfunction X parm X parm() parm (). a nice comment","title":"Split, space separated"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#split-comma-separated","text":"Comments are allowed on all lines that end with comma+space. name EXEC CICS function, some X subfunction, very X parm, nice X parm(),parm (), comments name is supported and optional. EXEC CICS is expected, EXECUTE CICS is not currently supported. subfunction is optional and depends on the function but must follow function, e.g. EXEC CICS WRITEQ TS parm() without spacing and parm () with spacing are allowed.","title":"Split, comma separated"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#vsam-support","text":"See the zCICS VSAM Guide for guidance in the setup of a VSAM environment. This document also contains extensions to the VSAM facilities currently available.","title":"VSAM support"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#basic-mapping-support","text":"The EXEC CICS commands RECEIVE MAP , SEND MAP and SEND CONTROL are documented here. For general BMS documentation and the mapping macros DFHMSD, DFHMDI and DFHMDF see the zCICS BMS Guide .","title":"Basic Mapping Support"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#zcobol-support","text":"EXEC CICS command format follows the rules for COBOL. Each command must end END-EXEC (a following dot may affect the logic). Parameters like SET() which address imported structures may use the ADDRESS OF special register. LENGTH , FLENGTH and KEYLENGTH which would normally allow a numeric option may use the LENGTH OF special register.","title":"zCOBOL support"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#extra-parameters","text":"You can add NOEDF to any EXEC CICS command if you wish that command to be excluded from a CEDF session. You can add NOEDF to the mz390 command if you wish all CEDF intercepts in that program excluded.","title":"Extra Parameters"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#command-reference-general-commands","text":"","title":"Command reference - General Commands"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#handle-aid","text":"name EXEC CICS HANDLE AID key(label) key Warning The following parameters are not supported. CLRPARTN LIGHTPEN OPERID TRIGGER Note ANYKEY (no label) clears all settings for CLEAR, PA and PF keys.","title":"HANDLE AID"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#handle-condition","text":"name EXEC CICS HANDLE CONDITION condition(label) condition","title":"HANDLE CONDITION"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#ignore-condition","text":"name EXEC CICS IGNORE CONDITION condition Warning Ignoring an error may lead to unpredictable abends. There is a current limit of 30 conditions.","title":"IGNORE CONDITION"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#pop-handle","text":"name EXEC CICS POP HANDLE For the HANDLE ABEND, a POP is the equivalent of a HANDLE ABEND RESET.","title":"POP HANDLE"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#push-handle","text":"name EXEC CICS PUSH HANDLE For the HANDLE ABEND, a PUSH is the equivalent of a HANDLE ABEND CANCEL .","title":"PUSH HANDLE"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#address","text":"name EXEC CICS ADDRESS X COMMAREA(label) X CWA(label) X EIB(label) CWA has a different implementation in zCICS. See CWA Management in zCICS Diagnosis Reference for more information.","title":"ADDRESS"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#assign","text":"name EXEC CICS ASSIGN The following parameters are not supported: ACTIVITY,ACTIVITYID,ALTSCRNHT,ALTSCRNWD,APPLID,ASRAINTRPT,ASRAKEY,ASRASPC,ASRASTG,BRIDGE, DELIMITER,DESTCOUNT,DESTID,DESTIDLENG,GCHARS,GCODES,INITPARM,INITPARMLEN,INPARTN, LDCMNEM,LDCNUM,NETNAME,NUMTAB,OPCLASS,OPERKEYS,OPID,OPSECURITY,ORGABCODE,PAGENUM, PARTNPAGE,PARTNPAGE,PRINSYSID,PROCESS,PROCESSTYPE,QNAME,SIGDATA,STATIONID,SYSID, TELLERID,USERID,USERNAME Note zCICS allows a CWA size greater than 32K. If the CWA does exceed 32K, then ASSIGN CWALENG() will return an incorrect value.","title":"ASSIGN"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#command-reference-terminal-control","text":"","title":"Command reference - Terminal Control"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#receive","text":"name EXEC CICS RECEIVE X INTO(label) X LENGTH(label) X NOHANDLE","title":"RECEIVE"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#send","text":"name EXEC CICS SEND FROM(label) LENGTH()","title":"SEND"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#send-control","text":"name EXEC CICS SEND CONTROL CURSOR/CURSOR() ERASE/ERASEAUP ALARM FREEKB FRSET","title":"SEND CONTROL"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#command-reference-file-control","text":"","title":"Command reference - File control"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#read","text":"name EXEC CICS READ FILE()/DATASET() INTO()/SET() LENGTH()/FLENGTH() RIDFLD() RBA/XRBA/RRN/GENERIC GTEQ/EQUAL KEYLENGTH()","title":"READ"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#startbr","text":"name EXEC CICS STARTBR FILE()/DATASET() RIDFLD() REQID() RBA/XRBA/RRN/GENERIC GTEQ/EQUAL KEYLENGTH()","title":"STARTBR"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#readnext","text":"name EXEC CICS READNEXT FILE()/DATASET() INTO()/SET() LENGTH()/FLENGTH() RIDFLD() REQID() RBA/XRBA/RRN KEYLENGTH()","title":"READNEXT"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#readprev","text":"name EXEC CICS READPREV FILE()/DATASET() INTO()/SET() LENGTH()/FLENGTH() RIDFLD() REQID() RBA/XRBA/RRN KEYLENGTH()","title":"READPREV"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#endbr","text":"name EXEC CICS ENDBR X FILE()/DATASET() X REQID()","title":"ENDBR"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#resetbr","text":"name EXEC CICS RESETBR FILE()/DATASET() RIDFLD() REQID() RBA/XRBA/RRN/GENERIC GTEQ/EQUAL KEYLENGTH()","title":"RESETBR"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#command-reference-storage-control","text":"","title":"Command reference - Storage Control"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#freemain","text":"name EXEC CICS FREEMAIN X DATA()/DATAPOINTER() X DATA(label)","title":"FREEMAIN"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#getmain","text":"name EXEC CICS GETMAIN X SET() X LENGTH()/FLENGTH() X INITIMG()","title":"GETMAIN"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#command-reference-temporary-storage-control","text":"Note FLENGTH is an extension; do not use this parameter if the source code is likely to be ported back to a mainframe environment.","title":"Command reference - Temporary Storage Control"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#deleteq","text":"name EXEC CICS DELETEQ TS QUEUE()/QNAME()","title":"DELETEQ"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#readq","text":"name EXEC CICS READQ TS QUEUE()/QNAME() INTO()/SET() LENGTH()/FLENGTH() NUMITEMS() ITEM()/NEXT","title":"READQ"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#writeq","text":"name EXEC CICS WRITEQ TS QUEUE()/QNAME() FROM() LENGTH()/FLENGTH() NUMITEMS() ITEM() REWRITE","title":"WRITEQ"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#command-reference-program-control","text":"","title":"Command reference - Program Control"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#abend","text":"name EXEC CICS ABEND ABCODE() CANCEL NODUMP","title":"ABEND"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#handle-abend","text":"name EXEC CICS HANDLE ABEND CANCEL name EXEC CICS HANDLE ABEND RESET name EXEC CICS HANDLE ABEND LABEL(label) name EXEC CICS HANDLE ABEND PROGRAM()","title":"HANDLE ABEND"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#link","text":"name EXEC CICS LINK PROGRAM() COMMAREA(label) LENGTH() CHANNEL() Executes another CICS program. Return is to the linker. In zCICS both CHANNEL and COMMAREA may be specified. A warning MNOTE is issued.","title":"LINK"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#load","text":"name EXEC CICS LOAD PROGRAM() ENTRY()/SET() LENGTH(label) FLENGTH(label) Loads a module. The intention in the zCICS environment is to load a table or some other data, not an executable program.","title":"LOAD"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#release","text":"name EXEC CICS RELEASE PROGRAM() Releases a previously loaded module.","title":"RELEASE"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#return","text":"name EXEC CICS RETURN TRANSID() COMMAREA(label) LENGTH() CHANNEL() IMMEDIATE Returns to the last caller. In zCICS both CHANNEL and COMMAREA may be specified. A warning MNOTE is issued.","title":"RETURN"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#xctl","text":"name EXEC CICS XCTL PROGRAM() COMMAREA(label) LENGTH() CHANNEL() Executes another CICS program. In zCICS both CHANNEL and COMMAREA may be specified. A warning MNOTE is issued. If COMMAREA is present and both the address and length are the same as passed to the current program, then address/length are passed to the new program. If the address or length differs, then a copy of the COMMAREA is taken and the new address/length are passed to the new program. Return is to the last linker.","title":"XCTL"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#command-reference-interval-control","text":"Note FLENGTH is an extension; do not use this parameter if the source code is likely to be ported back to a mainframe environment.","title":"Command reference - Interval control"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#asktime","text":"name EXEC CICS ASKTIME X ABSTIME()","title":"ASKTIME"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#delay","text":"name EXEC CICS DELAY REQID() INTERVAL()/TIME() FOR/UNTIL HOURS() MINUTES() SECONDS() INTERVAL","title":"DELAY"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#formattime","text":"name EXEC CICS FORMATTIME Refer to IBM CICS\u00ae Application Programming reference for available parameters. Note STRINGFORMAT is discarded as there is only one option. DATESEP(label) and TIMESEP(label) are added as extensions. Only the first byte is used. DATESTRING returns the following 25-byte string. \"Mon, 17 Dec 2007 10:20:30\". The time zone (e.g. GMT) is not returned.","title":"FORMATTIME"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#start","text":"name EXEC CICS START TRANSID() INTERVAL()/TIME() TERMID() REQID() FROM() LENGTH()/FLENGTH() CHANNEL() QUEUE() RTRANSID() RTERMID() AFTER/AT HOURS() MINUTES() SECONDS() Warning USERID is not supported.","title":"START"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#retrieve","text":"name EXEC CICS RETRIEVE INTO()/SET() LENGTH()/FLENGTH() RTRANSID() RTERMID() QUEUE() Warning WAIT is not supported.","title":"RETRIEVE"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#cancel","text":"name EXEC CICS CANCEL REQID() Warning TRANSID is not supported.","title":"CANCEL"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#command-reference-task-control","text":"","title":"Command reference - Task Control"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#enq","text":"name EXEC CICS ENQ RESOURCE() LENGTH() NOSUSPEND","title":"ENQ"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#deq","text":"name EXEC CICS DEQ RESOURCE() LENGTH()","title":"DEQ"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#command-reference-bms","text":"","title":"Command reference - BMS"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#receive_1","text":"name EXEC CICS RECEIVE MAP() MAPSET() INTO()","title":"RECEIVE"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#send_1","text":"name EXEC CICS SEND MAP() MAPSET() CURSOR/CURSOR() DATAONLY/MAPONLY ERASE/ERASEAUP FROM() LENGTH() ALARM FREEKB FRSET SET()","title":"SEND"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#send-control-cursorcursor-eraseeraseaup-alarm-freekb-frset","text":"","title":"SEND CONTROL CURSOR/CURSOR() ERASE/ERASEAUP ALARM FREEKB FRSET"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#command-reference-dump-control","text":"","title":"Command reference - Dump Control"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#dump","text":"name EXEC CICS DUMP TRANSACTION DUMPCODE() COMPLETE FROM() LENGTH()/FLENGTH() SEGMENTLIST() LENGTHLIST() NUMSEGMENTS()","title":"DUMP"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#command-reference-inquire","text":"","title":"Command reference - Inquire"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#inquire-file","text":"name EXEC CICS INQUIRE FILE START name EXEC CICS INQUIRE FILE START AT() name EXEC CICS INQUIRE FILE END name EXEC CICS INQUIRE FILE() NEXT ... name EXEC CICS INQUIRE FILE() ...","title":"INQUIRE FILE"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#set-file","text":"name EXEC CICS SET FILE()/DATASET() ...","title":"SET FILE"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#command-reference-channel-and-containers","text":"","title":"Command reference - Channel and containers"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#get","text":"name EXEC CICS GET CONTAINER() CHANNEL() INTO()/FLENGTH() SET()/FLENGTH() NODATA/FLENGTH()","title":"GET"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#put","text":"name EXEC CICS PUT CONTAINER() CHANNEL() FROM()/FLENGTH()","title":"PUT"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#delete","text":"name EXEC CICS DELETE CONTAINER() CHANNEL()","title":"DELETE"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#move","text":"name EXEC CICS MOVE CONTAINER() AS() CHANNEL() TOCHANNEL()","title":"MOVE"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#startbrowse","text":"name EXEC CICS STARTBROWSE CONTAINER CHANNEL() BROWSETOKEN()","title":"STARTBROWSE"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#getnext","text":"name EXEC CICS GETNEXT CONTAINER() BROWSETOKEN()","title":"GETNEXT"},{"location":"user_guide/zCICS/zcics_app_prog_guide/#endbrowse","text":"name EXEC CICS ENDBROWSE CONTAINER BROWSETOKEN()","title":"ENDBROWSE"},{"location":"user_guide/zCOBOL/commands/","text":"Commands The following is a list of commands available as part of zCOBOL. These commands are scripts that are included in the z390 source and distribution and can be enabled by including the script directory in your system path. Alternatively you can reference the scripts directly from the command line by specifying the full path. Windows (z390 install dir)\\bat MacOS/Unix (z390 install dir)/bash Command reference zc390 Convert CBL source file to macro assembler MLC source file cblc Compile CBL to HLASM BAL and assemble to relocatable object code cblcl Compile CBL to HLASM BAL, assemble, and link to z390 load module zc390clg Compile CBL to HLASM BAL, assemble, link, and execute z390 load module","title":"Commands"},{"location":"user_guide/zCOBOL/commands/#commands","text":"The following is a list of commands available as part of zCOBOL. These commands are scripts that are included in the z390 source and distribution and can be enabled by including the script directory in your system path. Alternatively you can reference the scripts directly from the command line by specifying the full path. Windows (z390 install dir)\\bat MacOS/Unix (z390 install dir)/bash","title":"Commands"},{"location":"user_guide/zCOBOL/commands/#command-reference","text":"","title":"Command reference"},{"location":"user_guide/zCOBOL/commands/#zc390","text":"Convert CBL source file to macro assembler MLC source file","title":"zc390"},{"location":"user_guide/zCOBOL/commands/#cblc","text":"Compile CBL to HLASM BAL and assemble to relocatable object code","title":"cblc"},{"location":"user_guide/zCOBOL/commands/#cblcl","text":"Compile CBL to HLASM BAL, assemble, and link to z390 load module","title":"cblcl"},{"location":"user_guide/zCOBOL/commands/#zc390clg","text":"Compile CBL to HLASM BAL, assemble, link, and execute z390 load module","title":"zc390clg"},{"location":"user_guide/zCOBOL/zCOBOL_System_Programmer_Guide/","text":"zCOBOL System Programmer's Guide Warning There are still a number of missing functions in zCOBOL, and until such time as zCOBOL successfully passes the NIST ANSI COBOL 1985 Test Suite, zCOBOL should be considered to still be in a beta test state. zCOBOL internals The zCOBOL compiler translates COBOL source language programs into executable code using the following 3 major components: The java program zc390.class in z390.jar reads COBOL language source program with file extension CBL and generates a z390 HLASM compatible mainframe assembler source program with MLC extension. Each COBOL verb becomes a macro call opcode and all the words following up to the next verb or period become positional parameters for the macro call. Periods generate a PERIOD macro call to terminate all structures which may be missing the optional END-IF type words. All dashes in words are converted to underscores unless in quotes. The level numbers in data division statements are mapped to WS macro call with level as first positional operand. The macros in COBOL verb macro library zcobol/*.mac parse the parameters for each verb, access global macro symbol table, and call code generation macros to generated executable code. For example the IF macro issues calls to GEN_COMP macro to generate executable source code to compare two fields, and issues call to GEN_BC to generate executable source code to branch on condition. There are currently 4 optional zCOBOL executable code generation macro libraries. The zcobol/z390 HLASM code generation library is the primary focus currently. There is a COBOL demo program zcobol/demo/HELLO.CBL which can be compiled and executed in all 4 different target language environments using the initial zCOBOL release. The following libraries are available: zcobol/z390 - zCOBOL code generation macros for HLASM native z9/10 code zcobol/java - zCOBOL code generation macros for J2SE Java zcobol/vce - zCOBOL code generation macros for MS Visual Express C++ zcobol/i586 - zCOBOL code generation macros for HLA and MASM native Intel code Once the z390 HLASM code generation macros are complete and all the NIST COBOL 1985 standards tests have been completed successfully as a first milestone, then these macros can be copied to the other libraries and modified to replace HLASM source code model statements with the other target language statements. zc390 Translator The zc390 translator is a java regular expression based parser which reads COBOL source program and generates HLASM compatible mainframe assembler source program in one pass. Each recognized COBOL verb starts a new assembler macro call statement with all the parameters up to the next verb, period, or paragraph label passed as positional parameters. Periods generate a separate macro call to PERIOD to generate end to all the structures in the previous sentence. Paragraph and section labels generate call to LABEL with the name and type of label to generate. All hyphens in names are translated to underscores for HLASM compatibility. COBOL Language Verb Macros All the macros for the COBOL language verbs and section headings are stored in the macro library zcobol/mac . These macros parse the parameters, validate them for any syntax errors, and issue calls to generation macros in separate directory as described below. For example, the zcobol/mac/IF.MAC macro generates multiple calls to the generation macros GEN_COMP , GEN_BC , GEN_B , and GEN_LABEL . There are no language specific code generation macros in the zCOBOL directory so it is shared across multiple target language environments. All the macros are written in structured form using the z390 ZSTRMAC SPE structured programming extensions such as AIF, AELSEIF, AELSE, AEND, AWHILE, etc. As a result there are no explicit AGO or AIF labels in these macros. See Structured Macro Entensions documentation for more details. COMPUTE Statement Example The COBOL compute statement is a good example to study to understand how the zCOBOL compiler works. The steps followed to compile the following MOVE and COMPUTE statements are as follows: 77 FLT - SRT USAGE FLOAT-SHORT OCCURS 2 . MOVE 1 . 1 TO FLT-SRT ( 2 ). COMPUT E FLT-SRT ( 2 ) = FLT-SRT ( 2 ) + 2 . 2 . zc390 translator generates the following 2 zCOBOL verb macro call statements: MOVE 1 . 1 , 'TO' , FLT_SRT , \"(',2,')'` COMPUT E FLT_SRT , '(' , 2 , ')' , = , FLT_SRT , '(\",2,' ) ',+,2.2 The MOVE macro uses shared copybook routine GET_FIELD_PARM to parse the two fields for MOVE and store resulting field name and symbol table index. For the literal 1.1 the index is 0, for the subscripted field, the name is set to explicit register reference including length offset(length,register) and the code is generated to set the register to address of the subscripted field. The MOVE macro next issues call to GEN_MOVE with the source and target field names and system table indexes. The GEN_MOVE macro checks the type of each field and generates appropriate code to move value from source to target field. In this case it uses LARL to set register to address of DFP short value of 1.1 in literal table and then generates MVC to move the literal to the target subscripted field. The COMPUTE uses GET_FIELD_PARM to obtain name and index of target field and then extracts parms in expression following the = and then calls ZC_CALC macro to generate code for expression and store result in specified target field. This macro can be used by IF and other verb macros to calculate expression for loop etc. The ZC_CALC macro parses the expression parameters into Backus Normal Form using two stacks. One stack has the operators in expression and the other has the field parm index pointers. Following the rules of precedence, the operators and associated parameter pointers are removed from the stacks and stored sequentially in an operation table containing the operators, 2 operands, and the target field for each operation. Temporary storage fields are represented using negative indexes instead of position and a table of temporary fields created along with their type is maintained. A queue of free temporary fields is maintained and once a temporary field has been used in an operation, that temporary field is on the free queue for reuse rather than allocating a new temporary storage field. Once the expression has been parsed and all the operation table entries have been generated, the last target field is replaced with the result field passed to ZC_CALC and then the operation table is scanned and the generation macros for each operation are called to generate code to perform the operation. Just prior to generating code for an operation, the two input parameter types are used to determine the required type of result to minimize any loss of precision during the calculations. A call to GEN_MOVE is made to move the first operand field to the target field prior to performing add, subtract, etc. on the target field for operation. If the first operand is the same as the target field, the move can be omitted but that is not always possible to determine in the case of subscripting and indexing where different variables may just happen to have the same value. The called generation macros GEN_ADD, GEN_SUB, GEN_MPY, and GEN_DIV check the field types and perform the necessary conversion when types do not match. See demo added in zcobol/demo/callcomp directory which contains CALLCALC.MLC main assembler program which calls subroutine COMPSUM.CBL which uses COMPUTE statement to calculate sum of 15 different numeric data field types and returns sum as packed decimal for editing and display by calling program. There is a paper about this demo here: zcobol_COMPUTE.pdf -- Dead link zCOBOL Target Source Language Generation Macros All the target source language generation macros called by the COBOL verb macros in z390/zcobol are stored in the following directories by target language: Directory Notes zcobol/z390 Generate HLASM compatible mainframe assembler source program zcobol/java Generate J2SE java compatible source program zcobol/vce Generate MS Visual Express C compatible source program zcobol/i586 Generate HLA/MASM Intel assembler compatible source program Current only the z390 HLASM compatible source generation macros are being fully developed along with the required runtime support functions stored in the zcobol/lib/ZC390LIB.390 dynamically loaded runtime module. zCOBOL demos include a hello world COBOL program which can be compiled and executed in each of the target environments form the same zcobol/demo/HELLO.CBL source program. The following commands generate the corresponding source language equivalent and executable: Command Generated Source Code Target Generated Executable Code Notes cblclg zcobol/demo/HELLO zcobol/demo/HELLO.MLC/BAL zcobol/demo/HELLO.390 requires z390 and J2SE on Windows/Linux ZCJAVCLG zcobol/demo/HELLO zcobol/demo/HELLO.java zcobol/demo/HELLO.class requires J2SE on Windows/Linux ZCVCECLG zcobol/demo/HELLO zcobol/demo/HELLO.ccp zcobol/demo/HELLO.exe requires MS VCE runtime on Windows ZC586CLG zcobol/demo/HELLO zcobol/demo/HELLO.HLA/ASM zcobol/demo/HELLO.exe requires HLA, MASM, and MS VCE runtime on Windows If you are interested in joining in the open source zCOBOL development effort in any of the 4 target language environments or want to add another target language environment, join the zcobol development email discussion group and make your interests known. Melvyn Maltz is currently developing additional EXEC CICS support for zCOBOL programs. ZC390LIB Runtime Library The zcobol\\lib code generation macro directory also contains all the source code and the ZC390CVT.CPY copybook required to build the linklib\\ZC390LIB.390 runtime load module which is dynamically loaded by all generated z390 zCOBOL programs. This module contains the following components: The ZC390CVT.CPY copybook is used in every zCOBOL generated program to define the DSECT addressed by register 9. The same copybook is also used in ZC390LIB.MLC to generate the CVT at the beginning of the ZC390LIB.390 runtime load module with addresses of all the entries followed by work areas used by the code generation macros. Library Element Notes ZC390LIB.MLC Contains ZC390LIB CSECT and COPY ZC390CVT to include all object modules following the CVT at the beginning ZC390NUC.MLC Included module with system function routines such as CALL, GOBACK, STOPRUN, PERFORM, and PMCHECK to check for end of current performed paragraph or section ABORT.MLC Contains module called to abort execution with reason code ACCEPT.MLC Contains support for ACCEPT date, time, day of week DISPLAY.MLC Display any type field or literal INSPECT.MLC Inspect field tallying, replacing, or transforming Base Free Code Generation The zCOBOL code generation macros in zcobol/lib generate base free code for the procedure division using relative instructions for both branch addressing and for literal addressing as required. The only address constants generated in zCOBOL programs are for statically linked CALL's to other zCOBOL or assembler programs. The only limit on the combined size of working storage and the procedure division is 16MB. In order to use relative addressing for literals, all odd length literals are padded to even lengths. The LARL instruction is used to set address of data field or literal field as required for use in following RX type instructions. To address working storage and linkage section data fields, conventional base registers are dynamically allocated as required for use in RX type instructions. Since R13 always points to the beginning of working-storage, no dynamic base registers are required for access to data items in the first 4K of working storage. zCOBOL EXEC CICS Support When the option CICS is specified on the command line for ZC390C, ZC390CL, or ZC390CLG, then the zcobol\\ZCOBOL MAC global option &ZC_CICS is set on and the following changes in code generation are made: The CICS option will generate call to DFHEIENT to initialize CICS prior to executing user code starting at the first program CSECT. A DFHEISTG DSECT is generated at the beginning of working-storage instead of WSLOC LOCTR and warnings are generated for any data VALUE clauses defined in working-storage section. zCOBOL Data Types The zCOBOL option FLOAT(HEX/BINARY/DECIMAL) can be used to change the default from DECIMAL to HEX or BINARY for the generic types FLOAT-SHORT, FLOAT-LONG, and FLOAT-EXTENDED. 2 COMP-3 packed and also zoned decimal are limited to 18 digits per COBOL standard unless option EXTEND is set allowing up to 31 digits for both packed decimal and zoned decimal fields. USAGE PICTURE Z390 Assembler Type Description COMP S9(4) H 16 bit binary COMP S9(9) F 32 bit binary COMP S9(18) G 64 bit binary COMP S9(39) Q 128 bit binary FLOAT-HEX-7 COMP-1 EH HFP short 7 digits FLOAT-HEX-15 COMP-2 DH HFP long - 15 digits FLOAT-HEX-30 LH HFP extended - 30 digits FLOAT-BINARY-7 EB BFP short 7 digits FLOAT-BINARY-16 DB BFP long - 16 digits FLOAT-BINARY-34 LB BFP extended - 34 digits FLOAT-DECIMAL-7 FLOAT-SHORT EB DFP short 7 digits FLOAT-DECIMAL-16 FLOAT-LONG DB DFP long - 16 digits FLOAT-DECIMAL-34 FLOAT-EXTENDED LB DFP extended - 34 digits FLOAT-DECIMAL-7 FLOAT-SHORT EB DFP short 7 digits FLOAT-DECIMAL-16 FLOAT-LONG DB DFP long - 16 digits FLOAT-DECIMAL-34 FLOAT-EXTENDED D LB COMP-3 S9(31) P(3) Packed decimal up to 31 digits with option EXTEND S9(31) Z(3) Zoned Decimal up to 31 digits with option EXTEND (uses PD support) X X Characters FLOAT-SHORT EH,EB,ED Use option FLOAT(HFP/BFP/DFP) FLOAT-LONG DH,DB,DD Use option FLOAT(HFP/BFP/DFP) FLOAT-EXTENDED LH,LB,LD Use option FLOAT(HFP/BFP/DFP) Command Line options for zCOBOL Compiler Options are passed to the zCOBOL macro stage via CBL macro call with the options defined as positional parameters. To turn off an option that is on, prefix the option name with NO on command line or in OPT options file.","title":"zCOBOL System Programmer's Guide"},{"location":"user_guide/zCOBOL/zCOBOL_System_Programmer_Guide/#zcobol-system-programmers-guide","text":"Warning There are still a number of missing functions in zCOBOL, and until such time as zCOBOL successfully passes the NIST ANSI COBOL 1985 Test Suite, zCOBOL should be considered to still be in a beta test state.","title":"zCOBOL System Programmer's Guide"},{"location":"user_guide/zCOBOL/zCOBOL_System_Programmer_Guide/#zcobol-internals","text":"The zCOBOL compiler translates COBOL source language programs into executable code using the following 3 major components: The java program zc390.class in z390.jar reads COBOL language source program with file extension CBL and generates a z390 HLASM compatible mainframe assembler source program with MLC extension. Each COBOL verb becomes a macro call opcode and all the words following up to the next verb or period become positional parameters for the macro call. Periods generate a PERIOD macro call to terminate all structures which may be missing the optional END-IF type words. All dashes in words are converted to underscores unless in quotes. The level numbers in data division statements are mapped to WS macro call with level as first positional operand. The macros in COBOL verb macro library zcobol/*.mac parse the parameters for each verb, access global macro symbol table, and call code generation macros to generated executable code. For example the IF macro issues calls to GEN_COMP macro to generate executable source code to compare two fields, and issues call to GEN_BC to generate executable source code to branch on condition. There are currently 4 optional zCOBOL executable code generation macro libraries. The zcobol/z390 HLASM code generation library is the primary focus currently. There is a COBOL demo program zcobol/demo/HELLO.CBL which can be compiled and executed in all 4 different target language environments using the initial zCOBOL release. The following libraries are available: zcobol/z390 - zCOBOL code generation macros for HLASM native z9/10 code zcobol/java - zCOBOL code generation macros for J2SE Java zcobol/vce - zCOBOL code generation macros for MS Visual Express C++ zcobol/i586 - zCOBOL code generation macros for HLA and MASM native Intel code Once the z390 HLASM code generation macros are complete and all the NIST COBOL 1985 standards tests have been completed successfully as a first milestone, then these macros can be copied to the other libraries and modified to replace HLASM source code model statements with the other target language statements.","title":"zCOBOL internals"},{"location":"user_guide/zCOBOL/zCOBOL_System_Programmer_Guide/#zc390-translator","text":"The zc390 translator is a java regular expression based parser which reads COBOL source program and generates HLASM compatible mainframe assembler source program in one pass. Each recognized COBOL verb starts a new assembler macro call statement with all the parameters up to the next verb, period, or paragraph label passed as positional parameters. Periods generate a separate macro call to PERIOD to generate end to all the structures in the previous sentence. Paragraph and section labels generate call to LABEL with the name and type of label to generate. All hyphens in names are translated to underscores for HLASM compatibility.","title":"zc390 Translator"},{"location":"user_guide/zCOBOL/zCOBOL_System_Programmer_Guide/#cobol-language-verb-macros","text":"All the macros for the COBOL language verbs and section headings are stored in the macro library zcobol/mac . These macros parse the parameters, validate them for any syntax errors, and issue calls to generation macros in separate directory as described below. For example, the zcobol/mac/IF.MAC macro generates multiple calls to the generation macros GEN_COMP , GEN_BC , GEN_B , and GEN_LABEL . There are no language specific code generation macros in the zCOBOL directory so it is shared across multiple target language environments. All the macros are written in structured form using the z390 ZSTRMAC SPE structured programming extensions such as AIF, AELSEIF, AELSE, AEND, AWHILE, etc. As a result there are no explicit AGO or AIF labels in these macros. See Structured Macro Entensions documentation for more details.","title":"COBOL Language Verb Macros"},{"location":"user_guide/zCOBOL/zCOBOL_System_Programmer_Guide/#compute-statement-example","text":"The COBOL compute statement is a good example to study to understand how the zCOBOL compiler works. The steps followed to compile the following MOVE and COMPUTE statements are as follows: 77 FLT - SRT USAGE FLOAT-SHORT OCCURS 2 . MOVE 1 . 1 TO FLT-SRT ( 2 ). COMPUT E FLT-SRT ( 2 ) = FLT-SRT ( 2 ) + 2 . 2 . zc390 translator generates the following 2 zCOBOL verb macro call statements: MOVE 1 . 1 , 'TO' , FLT_SRT , \"(',2,')'` COMPUT E FLT_SRT , '(' , 2 , ')' , = , FLT_SRT , '(\",2,' ) ',+,2.2 The MOVE macro uses shared copybook routine GET_FIELD_PARM to parse the two fields for MOVE and store resulting field name and symbol table index. For the literal 1.1 the index is 0, for the subscripted field, the name is set to explicit register reference including length offset(length,register) and the code is generated to set the register to address of the subscripted field. The MOVE macro next issues call to GEN_MOVE with the source and target field names and system table indexes. The GEN_MOVE macro checks the type of each field and generates appropriate code to move value from source to target field. In this case it uses LARL to set register to address of DFP short value of 1.1 in literal table and then generates MVC to move the literal to the target subscripted field. The COMPUTE uses GET_FIELD_PARM to obtain name and index of target field and then extracts parms in expression following the = and then calls ZC_CALC macro to generate code for expression and store result in specified target field. This macro can be used by IF and other verb macros to calculate expression for loop etc. The ZC_CALC macro parses the expression parameters into Backus Normal Form using two stacks. One stack has the operators in expression and the other has the field parm index pointers. Following the rules of precedence, the operators and associated parameter pointers are removed from the stacks and stored sequentially in an operation table containing the operators, 2 operands, and the target field for each operation. Temporary storage fields are represented using negative indexes instead of position and a table of temporary fields created along with their type is maintained. A queue of free temporary fields is maintained and once a temporary field has been used in an operation, that temporary field is on the free queue for reuse rather than allocating a new temporary storage field. Once the expression has been parsed and all the operation table entries have been generated, the last target field is replaced with the result field passed to ZC_CALC and then the operation table is scanned and the generation macros for each operation are called to generate code to perform the operation. Just prior to generating code for an operation, the two input parameter types are used to determine the required type of result to minimize any loss of precision during the calculations. A call to GEN_MOVE is made to move the first operand field to the target field prior to performing add, subtract, etc. on the target field for operation. If the first operand is the same as the target field, the move can be omitted but that is not always possible to determine in the case of subscripting and indexing where different variables may just happen to have the same value. The called generation macros GEN_ADD, GEN_SUB, GEN_MPY, and GEN_DIV check the field types and perform the necessary conversion when types do not match. See demo added in zcobol/demo/callcomp directory which contains CALLCALC.MLC main assembler program which calls subroutine COMPSUM.CBL which uses COMPUTE statement to calculate sum of 15 different numeric data field types and returns sum as packed decimal for editing and display by calling program. There is a paper about this demo here: zcobol_COMPUTE.pdf -- Dead link","title":"COMPUTE Statement Example"},{"location":"user_guide/zCOBOL/zCOBOL_System_Programmer_Guide/#zcobol-target-source-language-generation-macros","text":"All the target source language generation macros called by the COBOL verb macros in z390/zcobol are stored in the following directories by target language: Directory Notes zcobol/z390 Generate HLASM compatible mainframe assembler source program zcobol/java Generate J2SE java compatible source program zcobol/vce Generate MS Visual Express C compatible source program zcobol/i586 Generate HLA/MASM Intel assembler compatible source program Current only the z390 HLASM compatible source generation macros are being fully developed along with the required runtime support functions stored in the zcobol/lib/ZC390LIB.390 dynamically loaded runtime module. zCOBOL demos include a hello world COBOL program which can be compiled and executed in each of the target environments form the same zcobol/demo/HELLO.CBL source program. The following commands generate the corresponding source language equivalent and executable: Command Generated Source Code Target Generated Executable Code Notes cblclg zcobol/demo/HELLO zcobol/demo/HELLO.MLC/BAL zcobol/demo/HELLO.390 requires z390 and J2SE on Windows/Linux ZCJAVCLG zcobol/demo/HELLO zcobol/demo/HELLO.java zcobol/demo/HELLO.class requires J2SE on Windows/Linux ZCVCECLG zcobol/demo/HELLO zcobol/demo/HELLO.ccp zcobol/demo/HELLO.exe requires MS VCE runtime on Windows ZC586CLG zcobol/demo/HELLO zcobol/demo/HELLO.HLA/ASM zcobol/demo/HELLO.exe requires HLA, MASM, and MS VCE runtime on Windows If you are interested in joining in the open source zCOBOL development effort in any of the 4 target language environments or want to add another target language environment, join the zcobol development email discussion group and make your interests known. Melvyn Maltz is currently developing additional EXEC CICS support for zCOBOL programs.","title":"zCOBOL Target Source Language Generation Macros"},{"location":"user_guide/zCOBOL/zCOBOL_System_Programmer_Guide/#zc390lib-runtime-library","text":"The zcobol\\lib code generation macro directory also contains all the source code and the ZC390CVT.CPY copybook required to build the linklib\\ZC390LIB.390 runtime load module which is dynamically loaded by all generated z390 zCOBOL programs. This module contains the following components: The ZC390CVT.CPY copybook is used in every zCOBOL generated program to define the DSECT addressed by register 9. The same copybook is also used in ZC390LIB.MLC to generate the CVT at the beginning of the ZC390LIB.390 runtime load module with addresses of all the entries followed by work areas used by the code generation macros. Library Element Notes ZC390LIB.MLC Contains ZC390LIB CSECT and COPY ZC390CVT to include all object modules following the CVT at the beginning ZC390NUC.MLC Included module with system function routines such as CALL, GOBACK, STOPRUN, PERFORM, and PMCHECK to check for end of current performed paragraph or section ABORT.MLC Contains module called to abort execution with reason code ACCEPT.MLC Contains support for ACCEPT date, time, day of week DISPLAY.MLC Display any type field or literal INSPECT.MLC Inspect field tallying, replacing, or transforming","title":"ZC390LIB Runtime Library"},{"location":"user_guide/zCOBOL/zCOBOL_System_Programmer_Guide/#base-free-code-generation","text":"The zCOBOL code generation macros in zcobol/lib generate base free code for the procedure division using relative instructions for both branch addressing and for literal addressing as required. The only address constants generated in zCOBOL programs are for statically linked CALL's to other zCOBOL or assembler programs. The only limit on the combined size of working storage and the procedure division is 16MB. In order to use relative addressing for literals, all odd length literals are padded to even lengths. The LARL instruction is used to set address of data field or literal field as required for use in following RX type instructions. To address working storage and linkage section data fields, conventional base registers are dynamically allocated as required for use in RX type instructions. Since R13 always points to the beginning of working-storage, no dynamic base registers are required for access to data items in the first 4K of working storage.","title":"Base Free Code Generation"},{"location":"user_guide/zCOBOL/zCOBOL_System_Programmer_Guide/#zcobol-exec-cics-support","text":"When the option CICS is specified on the command line for ZC390C, ZC390CL, or ZC390CLG, then the zcobol\\ZCOBOL MAC global option &ZC_CICS is set on and the following changes in code generation are made: The CICS option will generate call to DFHEIENT to initialize CICS prior to executing user code starting at the first program CSECT. A DFHEISTG DSECT is generated at the beginning of working-storage instead of WSLOC LOCTR and warnings are generated for any data VALUE clauses defined in working-storage section.","title":"zCOBOL EXEC CICS Support"},{"location":"user_guide/zCOBOL/zCOBOL_System_Programmer_Guide/#zcobol-data-types","text":"The zCOBOL option FLOAT(HEX/BINARY/DECIMAL) can be used to change the default from DECIMAL to HEX or BINARY for the generic types FLOAT-SHORT, FLOAT-LONG, and FLOAT-EXTENDED. 2 COMP-3 packed and also zoned decimal are limited to 18 digits per COBOL standard unless option EXTEND is set allowing up to 31 digits for both packed decimal and zoned decimal fields. USAGE PICTURE Z390 Assembler Type Description COMP S9(4) H 16 bit binary COMP S9(9) F 32 bit binary COMP S9(18) G 64 bit binary COMP S9(39) Q 128 bit binary FLOAT-HEX-7 COMP-1 EH HFP short 7 digits FLOAT-HEX-15 COMP-2 DH HFP long - 15 digits FLOAT-HEX-30 LH HFP extended - 30 digits FLOAT-BINARY-7 EB BFP short 7 digits FLOAT-BINARY-16 DB BFP long - 16 digits FLOAT-BINARY-34 LB BFP extended - 34 digits FLOAT-DECIMAL-7 FLOAT-SHORT EB DFP short 7 digits FLOAT-DECIMAL-16 FLOAT-LONG DB DFP long - 16 digits FLOAT-DECIMAL-34 FLOAT-EXTENDED LB DFP extended - 34 digits FLOAT-DECIMAL-7 FLOAT-SHORT EB DFP short 7 digits FLOAT-DECIMAL-16 FLOAT-LONG DB DFP long - 16 digits FLOAT-DECIMAL-34 FLOAT-EXTENDED D LB COMP-3 S9(31) P(3) Packed decimal up to 31 digits with option EXTEND S9(31) Z(3) Zoned Decimal up to 31 digits with option EXTEND (uses PD support) X X Characters FLOAT-SHORT EH,EB,ED Use option FLOAT(HFP/BFP/DFP) FLOAT-LONG DH,DB,DD Use option FLOAT(HFP/BFP/DFP) FLOAT-EXTENDED LH,LB,LD Use option FLOAT(HFP/BFP/DFP)","title":"zCOBOL Data Types"},{"location":"user_guide/zCOBOL/zCOBOL_System_Programmer_Guide/#command-line-options-for-zcobol-compiler","text":"Options are passed to the zCOBOL macro stage via CBL macro call with the options defined as positional parameters. To turn off an option that is on, prefix the option name with NO on command line or in OPT options file.","title":"Command Line options for zCOBOL Compiler"},{"location":"user_guide/zCOBOL/zCOBOL_User_Guide/","text":"zCOBOL User Guide Warning There are still a number of missing functions in zCOBOL, and until such time as zCOBOL successfully passes the NIST ANSI COBOL 1985 Test Suite, zCOBOL should be considered to still be in a beta test state. Overview zCOBOL is an open source portable mainframe COBOL compiler available as part of the z390 open source portable mainframe assembler. The zCOBOL compiler has been developed as a flexible tool for testing and modernizing COBOL applications without requiring rewriting existing programs. Getting Started First, you will need to install z390 Next, try the zCOBOL Quickstart which walks through how to create and run your first zCOBOL program. You can compile and run the provided HELLO COBOL program by using the following command: Windows cblclg zcobol\\demo\\HELLO MacOS/Unix cblclg zcobol/demo/HELLO The above command uses the zCOBOL to HLASM compile, link, and execute command to compile the COBOL hello world program HELLO.CBL into an executable HLASM compatible assembler program HELLO.MLC which is assembled using zCOBOL macro libraries zcobol+zcobol\\z390 and linked into z390 executable load module HELLO.390 which is then executed to generate WTO display of \"Hello World\" on the display log and on the console log file HELLO.LOG . Running your program You can compile, link, and execute a COBOL program in any directory by specifying the path and name of the program in the cblclg command. The source COBOL program must be in ASCII format and have the extension of CBL . Use the compiler command cblc to compile to relocatable object form. Use the compiler command cblcl to compile and link to 390 load module form with statically linked z390 and/or zCOBOL programs included. Once the programs have been successfully linked, then you can use the z390 exec command to execute a load module. For more about all the options available for z390 executable programs see the z390 User Guide Debugging your program Once you have successfully compiled a COBOL program into a z390 load module, you can run it with the command EXEC <filename> . If the program aborts or fails to produce the expected results, the next step is to debug the problem. The zCOBOL option TRACE can be specified to generate a WTO display of the name of each COBOL paragraph when it is entered. Along with listing of the program, this is sometimes enough to figure out why the program did not work. If it is necessary to examine the generated HLASM compatible assembler code, there are several steps that can be taken: First the assembly listing with suffix PRN produced by the zCOBOL compiler can be examined to see if the generated assembler instructions to perform the correct operation specified in the COBOL statement which precedes the generated code as a comment statement. See zcobol/demo/HELLO.PRN as an example. Next an execution trace of every assembler instruction executed along with the data values associated with each instruction can be produced by adding the option TRACE(E) which results in file with TRE suffix. If you also specify TRACE option, the WTO for every paragraph will also appear in the TRE trace file which can be handy for finding the start of code in a particular paragraph. For example, if you run the command cblclg zcobol/demo/POWERS TRACE(E) then you can view the resulting executing trace file zcobol/demo/POWERS.TRE as well as the log file zcobol/demo/POWERS.LOG . If the execution trace fails to pinpoint the problem, another option is to include debug test and display statements in the program to further isolate where the problem is occurring. zCOBOL demos and regression tests To run all the zCOBOL demo programs, you can execute the script runcbldemos (located in bash and bat folders) which will compile and execute them. You can then view the log file for each demo program to see the output produced. You can also run all the zCOBOL regression tests using the command runcbltests (located in bash and bat folders) and look at the source code and generated output. Demo Programs The following zCOBOL demo programs can be found in zcobol/demo Program Notes HELLO Display \"Hello World\" and STOP RUN DATETIME ACCEPT current date and time and display month, day of week, and year COPYFILE Read line sequential ASCII file and copy it to new output line sequential file POWERS Calculate and display powers of 2 up to 2^31^ Regression test programs The following zCOBOL regression test programs can be found in zcobol/test Program Notes TESTADD1 Test 225 combinations of ADD TESTADD2 Test 225 combinations of ADD with different implied decimals TESTASM4 Assembler module statically linked with TESTCAL3.CBL TESTBFP1 Test Binary Floating Point support TESTCAL1 CALL TESTCAL2 statically linked TESTCAL2 CALL TESTCAL3 dynamically TESTCAL3 Dynamically loaded zcobol module which calls statically linked TESTASM4 assembler routine TESTCMP1 ADD, SUBTRACT, MULTIPLY, and DIVIDE all formats TESTCMP2 Test ADD, SUBTRACT, MULTIPLY, and DIVIDE TESTCMP3 Test COMPUTE with implied decimal points for data type F, G, H, P, Q, and Z TESTCMP4 Test COMPUTE with literals and different numberic values and implied decimals TESTCMP5 Test 225 combinations of COMPUTE TESTCMP6 Test 225 combinations of COMPUTE with different implied decimals TESTCPY1 COPY TESTCPY2 nested COPY TESTDFP1 Test Decimal Floating Point )DFP) support TESTDIV1 Test 225 combinations of DIVIDE TESTDIV2 Test 225 combinations of DIVIDE with different implied decimals TESTDSP1 DISPLAY all formats TESTFIL1 Test file access TESTFIL2 Test file access TESTFUN1 ACCEPT, TRANSFORM, NUMERIC, etc. TESTGO1 GO TO DEPENDING ON TESTHFP1 Test Hexidecimal Floating Point (HFP) support TESTIF1 Compound IF requiring use of intermediate T/F flags TESTIF2 Test IF with omitted operands such as IF A = B OR C TESTIF3 Test IF with parenthesis TESTINT1 Test integer data types H, F, G, Q, P, and Z TESTISP1 INSPECT TALLYING, REPLACING, TRANSFORMING TESTMOV1 MOVE all formats TESTMOV2 Test alignment for non-floating point moves TESTMOV3 Test scaling for implied decimal for non-floating point moves TESTMPY1 Test 225 combinations of MULTIPLY TESTMPY2 Test 225 combinations of MULTIPLY with different implied decimals TESTPM1 PERFORM VARYING and PERFORM TIMES TESTPM2 Test PERFORM with duplicate paragraph names in different sections TESTPM3 Test reading file using nested PERFORM VARYING TESTRMD1 Test move reference modification of the form MOVE F1(var1+lit1:len1) TO F2(var2+lit2:len2) TESTSIX1 Test multiple subscripts TESTSIX2 Test SET and INDEXED form of subscripting TESTSUB1 Test 225 combinations of SUBTRACT TESTSUB2 Test 225 combinations of SUBTRACT with different implied decimals TESTTRC1 TRUNC TESTTRC2 NOTRUNC with ONSIZE TESTTRC3 TRUNC and NOR64 to test use of DXR versus DSG TESTWS1 Working storage REDEFINE and OCCURS with padding","title":"zCOBOL User Guide"},{"location":"user_guide/zCOBOL/zCOBOL_User_Guide/#zcobol-user-guide","text":"Warning There are still a number of missing functions in zCOBOL, and until such time as zCOBOL successfully passes the NIST ANSI COBOL 1985 Test Suite, zCOBOL should be considered to still be in a beta test state.","title":"zCOBOL User Guide"},{"location":"user_guide/zCOBOL/zCOBOL_User_Guide/#overview","text":"zCOBOL is an open source portable mainframe COBOL compiler available as part of the z390 open source portable mainframe assembler. The zCOBOL compiler has been developed as a flexible tool for testing and modernizing COBOL applications without requiring rewriting existing programs.","title":"Overview"},{"location":"user_guide/zCOBOL/zCOBOL_User_Guide/#getting-started","text":"First, you will need to install z390 Next, try the zCOBOL Quickstart which walks through how to create and run your first zCOBOL program. You can compile and run the provided HELLO COBOL program by using the following command: Windows cblclg zcobol\\demo\\HELLO MacOS/Unix cblclg zcobol/demo/HELLO The above command uses the zCOBOL to HLASM compile, link, and execute command to compile the COBOL hello world program HELLO.CBL into an executable HLASM compatible assembler program HELLO.MLC which is assembled using zCOBOL macro libraries zcobol+zcobol\\z390 and linked into z390 executable load module HELLO.390 which is then executed to generate WTO display of \"Hello World\" on the display log and on the console log file HELLO.LOG .","title":"Getting Started"},{"location":"user_guide/zCOBOL/zCOBOL_User_Guide/#running-your-program","text":"You can compile, link, and execute a COBOL program in any directory by specifying the path and name of the program in the cblclg command. The source COBOL program must be in ASCII format and have the extension of CBL . Use the compiler command cblc to compile to relocatable object form. Use the compiler command cblcl to compile and link to 390 load module form with statically linked z390 and/or zCOBOL programs included. Once the programs have been successfully linked, then you can use the z390 exec command to execute a load module. For more about all the options available for z390 executable programs see the z390 User Guide","title":"Running your program"},{"location":"user_guide/zCOBOL/zCOBOL_User_Guide/#debugging-your-program","text":"Once you have successfully compiled a COBOL program into a z390 load module, you can run it with the command EXEC <filename> . If the program aborts or fails to produce the expected results, the next step is to debug the problem. The zCOBOL option TRACE can be specified to generate a WTO display of the name of each COBOL paragraph when it is entered. Along with listing of the program, this is sometimes enough to figure out why the program did not work. If it is necessary to examine the generated HLASM compatible assembler code, there are several steps that can be taken: First the assembly listing with suffix PRN produced by the zCOBOL compiler can be examined to see if the generated assembler instructions to perform the correct operation specified in the COBOL statement which precedes the generated code as a comment statement. See zcobol/demo/HELLO.PRN as an example. Next an execution trace of every assembler instruction executed along with the data values associated with each instruction can be produced by adding the option TRACE(E) which results in file with TRE suffix. If you also specify TRACE option, the WTO for every paragraph will also appear in the TRE trace file which can be handy for finding the start of code in a particular paragraph. For example, if you run the command cblclg zcobol/demo/POWERS TRACE(E) then you can view the resulting executing trace file zcobol/demo/POWERS.TRE as well as the log file zcobol/demo/POWERS.LOG . If the execution trace fails to pinpoint the problem, another option is to include debug test and display statements in the program to further isolate where the problem is occurring.","title":"Debugging your program"},{"location":"user_guide/zCOBOL/zCOBOL_User_Guide/#zcobol-demos-and-regression-tests","text":"To run all the zCOBOL demo programs, you can execute the script runcbldemos (located in bash and bat folders) which will compile and execute them. You can then view the log file for each demo program to see the output produced. You can also run all the zCOBOL regression tests using the command runcbltests (located in bash and bat folders) and look at the source code and generated output.","title":"zCOBOL demos and regression tests"},{"location":"user_guide/zCOBOL/zCOBOL_User_Guide/#demo-programs","text":"The following zCOBOL demo programs can be found in zcobol/demo Program Notes HELLO Display \"Hello World\" and STOP RUN DATETIME ACCEPT current date and time and display month, day of week, and year COPYFILE Read line sequential ASCII file and copy it to new output line sequential file POWERS Calculate and display powers of 2 up to 2^31^","title":"Demo Programs"},{"location":"user_guide/zCOBOL/zCOBOL_User_Guide/#regression-test-programs","text":"The following zCOBOL regression test programs can be found in zcobol/test Program Notes TESTADD1 Test 225 combinations of ADD TESTADD2 Test 225 combinations of ADD with different implied decimals TESTASM4 Assembler module statically linked with TESTCAL3.CBL TESTBFP1 Test Binary Floating Point support TESTCAL1 CALL TESTCAL2 statically linked TESTCAL2 CALL TESTCAL3 dynamically TESTCAL3 Dynamically loaded zcobol module which calls statically linked TESTASM4 assembler routine TESTCMP1 ADD, SUBTRACT, MULTIPLY, and DIVIDE all formats TESTCMP2 Test ADD, SUBTRACT, MULTIPLY, and DIVIDE TESTCMP3 Test COMPUTE with implied decimal points for data type F, G, H, P, Q, and Z TESTCMP4 Test COMPUTE with literals and different numberic values and implied decimals TESTCMP5 Test 225 combinations of COMPUTE TESTCMP6 Test 225 combinations of COMPUTE with different implied decimals TESTCPY1 COPY TESTCPY2 nested COPY TESTDFP1 Test Decimal Floating Point )DFP) support TESTDIV1 Test 225 combinations of DIVIDE TESTDIV2 Test 225 combinations of DIVIDE with different implied decimals TESTDSP1 DISPLAY all formats TESTFIL1 Test file access TESTFIL2 Test file access TESTFUN1 ACCEPT, TRANSFORM, NUMERIC, etc. TESTGO1 GO TO DEPENDING ON TESTHFP1 Test Hexidecimal Floating Point (HFP) support TESTIF1 Compound IF requiring use of intermediate T/F flags TESTIF2 Test IF with omitted operands such as IF A = B OR C TESTIF3 Test IF with parenthesis TESTINT1 Test integer data types H, F, G, Q, P, and Z TESTISP1 INSPECT TALLYING, REPLACING, TRANSFORMING TESTMOV1 MOVE all formats TESTMOV2 Test alignment for non-floating point moves TESTMOV3 Test scaling for implied decimal for non-floating point moves TESTMPY1 Test 225 combinations of MULTIPLY TESTMPY2 Test 225 combinations of MULTIPLY with different implied decimals TESTPM1 PERFORM VARYING and PERFORM TIMES TESTPM2 Test PERFORM with duplicate paragraph names in different sections TESTPM3 Test reading file using nested PERFORM VARYING TESTRMD1 Test move reference modification of the form MOVE F1(var1+lit1:len1) TO F2(var2+lit2:len2) TESTSIX1 Test multiple subscripts TESTSIX2 Test SET and INDEXED form of subscripting TESTSUB1 Test 225 combinations of SUBTRACT TESTSUB2 Test 225 combinations of SUBTRACT with different implied decimals TESTTRC1 TRUNC TESTTRC2 NOTRUNC with ONSIZE TESTTRC3 TRUNC and NOR64 to test use of DXR versus DSG TESTWS1 Working storage REDEFINE and OCCURS with padding","title":"Regression test programs"},{"location":"user_guide/zCOBOL/zCOBOL_filetypes/","text":"zCOBOL file types TYPE Format File Description File or Report Format Description CBL ASCII COBOL source program 1-6 sequence #, 7 comment if not space, 8-11 area A, 12-72 area B. CPZ ASCII COBOL copy book member 1-6 sequence #, 7 comment if not space, 8-11 area A, 12-72 area B. MLC ASCII Macro assembler source program generated by phase 1 of the zCOBOL compiler which uses zcobol.class regular expression based parser in z390.jar to read CBL source file and create MLC source file in one pass. Macro call for each COBOL statement starting in area A and for each COBOL verb found in area B. Working storage data items are mapped to WS macro call with level as first parameter. Each macro call name is followed by positional parameters found following verb up to next verb or period. Periods are mapped to PERIOD macro call. Parameters of the form keyword(..) are passed as single parameter. Other ( and ) are passed as separate parameter in quotes. BAL ASCII HLASM compatible source code generated by phase 2 of the zCOBOL compiler when using CBLC, CBLCL or CBLCLG commands. HLASM compatible source statements generated by the zCOBOL macros during expansion of the generated MLC file. CPY ASCII Generated copy file containing macro calls to define labels defined in a zCOBOL program. LABEL generated zCOBOL name.","title":"zCOBOL file types"},{"location":"user_guide/zCOBOL/zCOBOL_filetypes/#zcobol-file-types","text":"TYPE Format File Description File or Report Format Description CBL ASCII COBOL source program 1-6 sequence #, 7 comment if not space, 8-11 area A, 12-72 area B. CPZ ASCII COBOL copy book member 1-6 sequence #, 7 comment if not space, 8-11 area A, 12-72 area B. MLC ASCII Macro assembler source program generated by phase 1 of the zCOBOL compiler which uses zcobol.class regular expression based parser in z390.jar to read CBL source file and create MLC source file in one pass. Macro call for each COBOL statement starting in area A and for each COBOL verb found in area B. Working storage data items are mapped to WS macro call with level as first parameter. Each macro call name is followed by positional parameters found following verb up to next verb or period. Periods are mapped to PERIOD macro call. Parameters of the form keyword(..) are passed as single parameter. Other ( and ) are passed as separate parameter in quotes. BAL ASCII HLASM compatible source code generated by phase 2 of the zCOBOL compiler when using CBLC, CBLCL or CBLCLG commands. HLASM compatible source statements generated by the zCOBOL macros during expansion of the generated MLC file. CPY ASCII Generated copy file containing macro calls to define labels defined in a zCOBOL program. LABEL generated zCOBOL name.","title":"zCOBOL file types"},{"location":"user_guide/zCOBOL/zCOBOL_options/","text":"zCOBOL options Use of parameters with parentheses in *nix shells Unix shells like sh and bash interpret parentheses if not quoted. For this reason, if you need to specify a parameter that contains parentheses, then that parameter should be quoted. For example, the FLOAT parameter is quoted as it uses parentheses, whereas the COMMENT parameter is not. \"FLOAT(BINARY)\" COMMENT Option Default Description @file NO Retrieve additional options from free form text file with default suffix OPT. Options can be specified delimited by spaces on as many lines as required. All characters on a line following * are ignored as comments. The @file option can be nested. The default path is the program path. CICS NO Parse COBOL EXEC CICS commands into z390 EXEC CICS compatible macro calls and also rename working storage to DFHEISTG. COMMENT YES Generate MLC comments showing original COBOL statement preceding each macro call statement. EXTEND YES Support up to 31 digits for DISPLAY (Z) and COMP-3 (P) type data items rather than limiting precision to ANSI 1985 standard of 18. FLOAT(DECIMAL) YES Set type of floating point for usage FLOAT-SHORT, FLOAT-LONG, and FLOAT-EXTENDED. The choices are FLOAT(HEX) for Hexadecimal Floating Point (HFP) like COMP-1 and COMP-2, FLOAT(BINARY) for Binary Floating Point (BFP), or the default FLOAT(DECIMAL) for Decimal Floating Point (DFP). R64 YES Generate 64 bit instructions for the 16 GPR registers where appropriate. NOR64 restricts code generation to only use lower 32 bits of 16 GPR registers as required by z/VSE and some other operating environments. (Note option TRUNC and NOR64 results in use of DXR instead of DGR which is more efficient.) TRACE NO Generate WTO display of paragraph name at entry to each new paragraph in procedure division. This provides high level trace as opposed to using the z390 TRACE(E) option which generates instruction level trace. TRUNC NO Truncate binary data types F, G, and H to specified number of digits in PICTURE. WARN YES Generate level 4 MNOTE warnings from zCOBOL macros.","title":"zCOBOL options"},{"location":"user_guide/zCOBOL/zCOBOL_options/#zcobol-options","text":"Use of parameters with parentheses in *nix shells Unix shells like sh and bash interpret parentheses if not quoted. For this reason, if you need to specify a parameter that contains parentheses, then that parameter should be quoted. For example, the FLOAT parameter is quoted as it uses parentheses, whereas the COMMENT parameter is not. \"FLOAT(BINARY)\" COMMENT Option Default Description @file NO Retrieve additional options from free form text file with default suffix OPT. Options can be specified delimited by spaces on as many lines as required. All characters on a line following * are ignored as comments. The @file option can be nested. The default path is the program path. CICS NO Parse COBOL EXEC CICS commands into z390 EXEC CICS compatible macro calls and also rename working storage to DFHEISTG. COMMENT YES Generate MLC comments showing original COBOL statement preceding each macro call statement. EXTEND YES Support up to 31 digits for DISPLAY (Z) and COMP-3 (P) type data items rather than limiting precision to ANSI 1985 standard of 18. FLOAT(DECIMAL) YES Set type of floating point for usage FLOAT-SHORT, FLOAT-LONG, and FLOAT-EXTENDED. The choices are FLOAT(HEX) for Hexadecimal Floating Point (HFP) like COMP-1 and COMP-2, FLOAT(BINARY) for Binary Floating Point (BFP), or the default FLOAT(DECIMAL) for Decimal Floating Point (DFP). R64 YES Generate 64 bit instructions for the 16 GPR registers where appropriate. NOR64 restricts code generation to only use lower 32 bits of 16 GPR registers as required by z/VSE and some other operating environments. (Note option TRUNC and NOR64 results in use of DXR instead of DGR which is more efficient.) TRACE NO Generate WTO display of paragraph name at entry to each new paragraph in procedure division. This provides high level trace as opposed to using the z390 TRACE(E) option which generates instruction level trace. TRUNC NO Truncate binary data types F, G, and H to specified number of digits in PICTURE. WARN YES Generate level 4 MNOTE warnings from zCOBOL macros.","title":"zCOBOL options"}]}